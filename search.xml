<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[week 14] 後端基礎：資料庫 &amp; 系統設計</title>
    <url>/backend-system-design/</url>
    <content><![CDATA[<blockquote>
<p>本篇為「程式導師實驗計畫：Lesson 8-2 之資料庫」這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<a id="more"></a>
<h2 id="學習目標"><a href="#學習目標" class="headerlink" title="學習目標"></a>學習目標</h2><ul>
<li>瞭解 NoSQL 和 SQL 的差別</li>
<li>瞭解什麼是 ACID 原則</li>
<li>什麼是 Transaction（交易）</li>
<li>為什麼需要 Lock（資料鎖定）</li>
<li>瞭解什麼是 Google Public DNS</li>
<li>瞭解什麼是系統設計</li>
</ul>
<hr>
<h2 id="NoSQL（Not-Only-SQL）"><a href="#NoSQL（Not-Only-SQL）" class="headerlink" title="NoSQL（Not Only SQL）"></a>NoSQL（Not Only SQL）</h2><p>非關聯式資料庫，例如 <span class="exturl" data-url="aHR0cHM6Ly93d3cubW9uZ29kYi5jb20vY2xvdWQvYXRsYXMvbHAvdHJ5Mj91dG1fc291cmNlPWdvb2dsZSZ1dG1fY2FtcGFpZ249Z3NfYXBhY190YWl3YW5fc2VhcmNoX2JyYW5kX2F0bGFzX2Rlc2t0b3AmdXRtX3Rlcm09bW9uZ29kYiZ1dG1fbWVkaXVtPWNwY19wYWlkX3NlYXJjaCZ1dG1fYWQ9ZSZ1dG1fYWRfY2FtcGFpZ25faWQ9NjQ5ODU1NDA5MCZnY2xpZD1DajBLQ1Fqd3VMXzhCUkNYQVJJc0FHaUM1MUEyZm5uOGN5MEpRUGRmR0dHQ2x1c3MwUHVCQ0c5NngzLU56VGZTRTlqeTBpYkFKTVRMeTFJYUFoQXBFQUx3X3djQg==">mongodb<i class="fa fa-external-link-alt"></i></span>；與之對應的是關聯式資料庫，例如之前實作 PHP 留言板使用的 MySQL。</p>
<ol>
<li>沒有 Schema，可以想像成存 JSON 資料進 Database</li>
<li>使用 key-value 儲存</li>
<li>不支援 JOIN，因為是非關聯式資料庫</li>
<li>通常用來存一些結構不固定的資料，例如：log</li>
</ol>
<h3 id="NoSQL-跟-SQL-的差別在哪裡？"><a href="#NoSQL-跟-SQL-的差別在哪裡？" class="headerlink" title="NoSQL 跟 SQL 的差別在哪裡？"></a>NoSQL 跟 SQL 的差別在哪裡？</h3><p>SQL（Structured Query Language），中文為「結構化查詢語言」，是一種專門用來管理與查詢「關聯式資料庫」的程式語言。與之相對的是 NoSQL（Not Only SQL），「非關聯式資料庫」，也就是不限定為關聯式資料庫的資料庫管理系統。</p>
<p>以下是關聯式與非關聯式資料庫的差別：</p>
<h4 id="關聯式資料庫（RDBMS）"><a href="#關聯式資料庫（RDBMS）" class="headerlink" title="關聯式資料庫（RDBMS）"></a>關聯式資料庫（RDBMS）</h4><ul>
<li>全名：Relational Database Management System</li>
<li>以 SQL 語言操作</li>
<li>儲存方式：使用不同 table 存取不同類型的內容</li>
<li>特性：資料之間保有相關性，也避免不相關的資料互相干擾</li>
<li>常見程式：MySQL、PostgreSQL、Microsoft SQL Server</li>
<li>例如：會員資料庫，其中明確關聯是會員 ID</li>
</ul>
<h4 id="非關聯式資料庫（NoSQL）"><a href="#非關聯式資料庫（NoSQL）" class="headerlink" title="非關聯式資料庫（NoSQL）"></a>非關聯式資料庫（NoSQL）</h4><ul>
<li>全名：Not Only SQL</li>
<li>不限定使用 SQL 語言</li>
<li>儲存方式：使用 key-value 儲存資料，且沒有 Schema，可想像成把 JSON 資料存進資料庫</li>
<li>特性：彈性較高，通常用來存一些結構不固定的資料，因此不支援 JOIN</li>
<li>常見程式：mongoDB</li>
<li>例如：存取 log 日誌、社交網站上的大量資訊（文章被分享、按讚數等）</li>
</ul>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRob21lLmNvbS50dy9uZXdzLzkyNTA2">了解NoSQL不可不知的5項觀念<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS90dy9ub3NxbC8=">NoSQL (非關聯式) 資料庫如何運作？<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="Transaction-交易"><a href="#Transaction-交易" class="headerlink" title="Transaction 交易"></a>Transaction 交易</h2><ul>
<li>可解釋為一筆交易。</li>
<li>例如：A 轉帳 100 元給 B，要確保 A 少 20 元的同時 B 多了 20 元。</li>
</ul>
<p>實際應用：</p>
<ol>
<li>轉帳</li>
<li>購物（一次買多個品項）</li>
<li>其他一次牽扯到多個 query 的操作</li>
</ol>
<h2 id="ACID-原則"><a href="#ACID-原則" class="headerlink" title="ACID 原則"></a>ACID 原則</h2><p>為了保證 Transaction 的正確性，執行資料庫事務須符合的四個特性：</p>
<p>在執行資料庫事務時，為了保證 Transaction（交易）的正確性，必須符合 ACID 四個特性：</p>
<ol>
<li>原子性 atomicity：全部失敗 or 全部成功<ul>
<li>例如：小明轉帳 100 元給小美，成功的話小明 -100 元，小美 +100 元；失敗的話資料不會有任何變化。</li>
</ul>
</li>
<li>一致性 consistency：維持資料的一致性<ul>
<li>例如：交易前後，錢的總數均不會改變。</li>
</ul>
</li>
<li>隔離性 isolation：多筆交易不會互相影響，也就是不能同時變動同一個值<ul>
<li>例如：小明只有 100 元，如果要同時轉帳 100 元給小美和小華，會產生負值這樣的系統錯誤。因此交易時使用需要 Lock 鎖，鎖定交易資料，即可避免同時修改到同一個值。</li>
</ul>
</li>
<li>持久性 durability：交易成功之後，寫入的資料不會不見</li>
</ol>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMxMzQ2Mzky">如何理解數據庫事務中的一致性的概念？<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="如何在-MySQL-執行-Transaction"><a href="#如何在-MySQL-執行-Transaction" class="headerlink" title="如何在 MySQL 執行 Transaction"></a>如何在 MySQL 執行 Transaction</h3><p>一個 Transaction 可同時執行多個 SQL，以下列程式碼為例：</p>
<pre><code class="php=">$conn-&gt;autocommit(FALSE);    // 避免每次自動變成 transaction
$conn-&gt;begin_transaction();  // 開始 transaction
$conn-&gt;query(&quot;update from money set amount = 20&quot;);
$conn-&gt;query(&quot;update from money set sum = 10&quot;);
$conn-&gt;commit();        // 當發出 commit 後才會執行</code></pre>
<hr>
<h2 id="Lock-資料鎖定"><a href="#Lock-資料鎖定" class="headerlink" title="Lock 資料鎖定"></a>Lock 資料鎖定</h2><p>資料庫的交易資料鎖定。</p>
<p>當多筆交易在讀取或寫入資料時，彼此會相互影響。因此為了交易的並行性與獨立性，需透過做「記號」來標記該資料狀態正在被讀取或寫入，其他交易則根據該記號決定能否執行其他操作，而這個記號就是所謂的 lock（交易鎖定）。但由於鎖定後會需要等待執行，也須考慮到效能上的損耗。</p>
<p>程式碼範例如下：</p>
<pre><code class="php=">$conn-&gt;autocommit(FALSE);
$conn-&gt;begin_transaction();
$conn-&gt;query(&quot;SELECT amount from products where id = 1 for update&quot;);
// 加上 for update: 更新後就會把這行鎖起來，沒有指定欄位的話會鎖住 Schema
$conn-&gt;commit();</code></pre>
<h3 id="什麼情況需要-Lock-鎖"><a href="#什麼情況需要-Lock-鎖" class="headerlink" title="什麼情況需要 Lock 鎖"></a>什麼情況需要 Lock 鎖</h3><p>舉例來說，當某個商品限定數量，造成搶購時可能會發生「超賣」情形，此現象又稱作 race condition（競爭危害）。若能在交易時加上 lock，即可避免同時讀取和寫入同一筆資料時產生的資料衝突，避免系統發生錯誤。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucWEta25vd2hvdy5jb20vP3A9Mzgz">資料庫的交易鎖定 Locks<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="再探-DNS"><a href="#再探-DNS" class="headerlink" title="再探 DNS"></a>再探 DNS</h2><p>在課程<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMC9UaGlzLWlzLUNvZGVkaWFyeS9ibG9iL21hc3Rlci93ZWVrNF8lRTclQjYlQjIlRTglQjclQUYlRTUlOUYlQkElRTclQTQlOEUlRTYlQTYlODIlRTglQUIlOTYubWQ=">第四週的網路基礎概論<i class="fa fa-external-link-alt"></i></span>時我們也曾提過 DNS（域名系統）。</p>
<ul>
<li>全名是 Domain Name System</li>
<li>負責將域名轉換成 IP 位置。可將 DNS 伺服器作為一個分散式資料庫<ul>
<li>域名（Domain）：即常用的網址。google.com 就是一個域名，類似景點名稱</li>
<li>IP 位置：每個主機都有個 IP 位置，是網路溝通的地址。由四個數字組成，範圍是 0 ~ 255</li>
</ul>
</li>
<li>功能類似網路上的電話簿，我們在搜尋網站的同時，是由 DNS 提供將網站名稱（域名）轉成號碼（IP 位置）的目錄服務</li>
</ul>
<h3 id="Google-有提供的公開的-DNS，對-Google-的好處以及對一般大眾的好處？"><a href="#Google-有提供的公開的-DNS，對-Google-的好處以及對一般大眾的好處？" class="headerlink" title="Google 有提供的公開的 DNS，對 Google 的好處以及對一般大眾的好處？"></a>Google 有提供的公開的 DNS，對 Google 的好處以及對一般大眾的好處？</h3><h4 id="對-Google-的好處"><a href="#對-Google-的好處" class="headerlink" title="對 Google 的好處"></a>對 Google 的好處</h4><ul>
<li>透過搜尋引擎來蒐集大數據，藉以分析使用者行為，以應用於商業目的</li>
<li>日後可提供更符合該使用地區的資料，或是投放更精準的廣告</li>
</ul>
<h4 id="對一般大眾的好處"><a href="#對一般大眾的好處" class="headerlink" title="對一般大眾的好處"></a>對一般大眾的好處</h4><ul>
<li>使用免費</li>
<li>提升網路安全性，例如：擋下惡意網站訊息</li>
<li>加速瀏覽體驗：可能增加上網速度</li>
<li>直接取得 DNS 查詢結果：因為已經快取，就不需查詢上層 DNS 記錄</li>
</ul>
<hr>
<h2 id="系統設計"><a href="#系統設計" class="headerlink" title="系統設計"></a>系統設計</h2><p>系統設計為了能夠穩定地提供高效率的服務，其實必須不斷思考，當使用者增加，需要擴展系統來增進效能時，可能遇到哪些問題、解決方式還有其優缺點。</p>
<p>通常會由下列兩個觀點作切入：</p>
<ul>
<li>擴展性（Scalability）：每當投入更多的資源，例如多增加一台伺服器，系統的效能（performance）也能成比例地增加。</li>
<li>可用性（Availability）：系統任何時候都要能回應使用者的請求，簡單來說，就是希望系統掛掉的時間越少越好。</li>
</ul>
<p>以下是有關系統設計的名詞解釋：</p>
<h3 id="Load-Balancer（負載平衡器）"><a href="#Load-Balancer（負載平衡器）" class="headerlink" title="Load Balancer（負載平衡器）"></a>Load Balancer（負載平衡器）</h3><p>提供類似路由器的功能，幫忙自動分配新進來的請求要導到哪一台 Server。</p>
<h3 id="主從模式（Master-slave）"><a href="#主從模式（Master-slave）" class="headerlink" title="主從模式（Master-slave）"></a>主從模式（Master-slave）</h3><p>資料的變動一律透過 Master 完成，它會再將結果同步到各個 slave。這種設計特別適合讀取的頻率大於寫入的系統。例如購物網站。可大幅減少資料庫的負擔。</p>
<h3 id="Sticky-sessions（會話保持）"><a href="#Sticky-sessions（會話保持）" class="headerlink" title="Sticky sessions（會話保持）"></a>Sticky sessions（會話保持）</h3><p>解決 Load Balancer 遺失狀態的問題，將用戶端與服務器之間建立的多個連接，都發送到相同的服務器進行處理。</p>
<h3 id="Single-Point-of-Failure（單點故障）"><a href="#Single-Point-of-Failure（單點故障）" class="headerlink" title="Single Point of Failure（單點故障）"></a>Single Point of Failure（單點故障）</h3><p>系統中一旦失效，就會讓整個系統無法運作的部件，例如負載均衡器就是脆弱的單點，解決方法如引入冗餘來故障轉移。</p>
<h3 id="資料庫快取"><a href="#資料庫快取" class="headerlink" title="資料庫快取"></a>資料庫快取</h3><p>資料庫的傳輸速度，是影響整個系統效能最大的因素，因此存取資料庫其實是一個高成本的行為。為了減少對資料庫的存取，我們可利用「快取（Cache）」，也就是將曾經查詢過的結果保存起來。通常會再加上有效期限，過期後快取結果就消失。</p>
<p>藉由快取機制，可大幅降低資料庫的負擔，使應用程式伺服器處理請求的速度更快，進而提升整個系統的效能。</p>
<h2 id="hw1：短網址系統設計"><a href="#hw1：短網址系統設計" class="headerlink" title="hw1：短網址系統設計"></a>hw1：短網址系統設計</h2><p>請你畫出一張短網址服務的後端系統架構圖，越詳細越好，可以考慮到如何增進效能、scaling 以及備份資料。</p>
<p>沒靈感的話可參考：短网址(short URL)系统的原理及其实现，或是用「短網址 系統設計」之類的關鍵字去搜尋。</p>
<hr>
<p>最後完成的短網址系統設計示意圖如下：</p>
<p><img src="https://i.imgur.com/ODL6mPz.png"></p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tLyVFNSVCRSU4QyVFNyVBQiVBRiVFNiU5NiVCMCVFNiU4OSU4QiVFNiU5RCU5MS9iYWNrZW5kLWFyY2hpdGVjdHVyZS0xMDEtNWM0MjVlNzYwYTEz">系統設計101—大型系統的演進（上）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0tVzlGX19EM29ZNA==">CS75 (Summer 2012) Lecture 9 Scalability Harvard Web Development David Malan<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5heXF5Lm5ldC9ibG9nL3NjYWxhYmlsaXR5XyVlNyViMyViYiVlNyViYiU5ZiVlOCVhZSViZSVlOCVhZSVhMSVlNyVhYyU5NCVlOCVhZSViMDEv">Scalability_系統設計筆記1<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRyZWFkMDEuY29tL2FydGljbGVzLzE0NzUyNDE2MjYuaHRtbA==">負載均衡常見問題之會話保持-粘滯會話(Sticky Sessions)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>Back-End</tag>
        <tag>System Design</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 16] 淺談 JavaScript：同步與非同步 &amp; Callback Function &amp; Event Loop</title>
    <url>/callback-event-loop/</url>
    <content><![CDATA[<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmh1bGkudHcvMjAxOS8xMC8wNC9qYXZhc2NyaXB0LWFzeW5jLXN5bmMtYW5kLWNhbGxiYWNrLw==">JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！<i class="fa fa-external-link-alt"></i></span> 這篇文章的學習筆記。</p>
<a id="more"></a>

<h2 id="JavaScript-的執行環境"><a href="#JavaScript-的執行環境" class="headerlink" title="JavaScript 的執行環境"></a>JavaScript 的執行環境</h2><p>JavaScript 是一個程式語言，會有程式語言本身規範能用的東西，例如 var 宣告變數，if else 判斷式，或者是使用 function 宣告函式。</p>
<p>但如果是使用 DOM 物件操作 body 並反映在瀏覽器畫面上，這其實是由瀏覽器提供，讓 JavaScript 能透過 document 這個物件與瀏覽器進行溝通。</p>
<p>其他還有像是用來計時的 setTimeout 與 setInterval，拿來做 AJAX 的 XMLHttpRequest 與 fetch，這些都是瀏覽器這個執行環境所提供的東西。</p>
<p>除了瀏覽器以外，Node.js 其實也是 JavaScript 的一個執行環境，而非單純提供套件的 Library。如同官網所言：</p>
<blockquote>
<p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.</p>
</blockquote>
<h3 id="瀏覽器-vs-Node-js"><a href="#瀏覽器-vs-Node-js" class="headerlink" title="瀏覽器 vs Node.js"></a>瀏覽器 vs Node.js</h3><p>JS 程式碼可以選擇跑在瀏覽器上，透過瀏覽器這個執行環境提供的東西操控畫面，或是發送 Request。</p>
<p>也可以選擇跑在 Node.js 這個執行環境上面，就可以利用 Node.js 提供的東西，例如使用 file system（控制檔案的介面），或是利用 http這個模組來寫 server。</p>
<p>可參考下方示意圖：</p>
<p><img src="https://i.imgur.com/nP7n8as.png"></p>
<p>也就是說，執行環境不同，能夠使用的就不同，執行方式也會不同。</p>
<p>以瀏覽器來說，是用 <code>&lt;script src=&quot;index.js&quot;&gt;</code> 引入一個 JavaScript 檔案，然後就可以在瀏覽器上執行。</p>
<p>以 Node.js 來說，則必須先在電腦上安裝 Node.js 這個執行環境，然後以 CLI 的方式輸入 <code>node index.js</code> 這個指令來執行。</p>
<h2 id="阻塞與非阻塞"><a href="#阻塞與非阻塞" class="headerlink" title="阻塞與非阻塞"></a>阻塞與非阻塞</h2><p>前面有提過 Node.js 有提供控制檔案的介面，讓我們能夠寫 JavaScript 程式碼來讀取與寫入檔案。</p>
<p>以下方程式碼作為範例：</p>
<pre><code class="javascript=">const fs = require(&#39;fs&#39;)
const file = fs.readFileSync(&#39;./README.md&#39;) // 在這邊等好幾秒才往下執行
console.log(file)

const arr = []
for (let i = 2; i &lt;= 99999999; i+=2) &#123;
  arr.push(i)
&#125;

console.log(arr)</code></pre>
<p>上面這段程式碼，意思是先引入 Node.js 提供的內建模組 fs，再來使用 fs.readFileSync 來讀取檔案，最後把檔案的內容用 console.log 給印出來。</p>
<p>但因為程式碼在讀取檔案之前會卡住，必須等到執行完畢並且拿到回傳值為止，程式才會繼續往下執行，這種情況就稱為阻塞（blocking）。</p>
<p>難道不能用非阻塞（non-blocking）的方式讀取檔案嗎？有的！我們能使用 readFile 的 method 來進行。以下為程式碼範例：</p>
<pre><code class="javascript=">// 讀取內建 fs 模組
const fs = require(&#39;fs&#39;)

// 定義讀取檔案完成以後，要執行的 function
function readFileFinished(err, data) &#123;
  if (err) &#123;
    console.log(err)
  &#125; else &#123;
    console.log(data)
  &#125;
&#125;

// 讀取檔案，第二個參數是 callback function
fs.readFile(&#39;./README.md&#39;, readFileFinished);
</code></pre>
<p>可發現 readFile 的用法跟 readFileSync 差不多，但兩種讀取檔案的方式差別在於：</p>
<h4 id="readFileSync"><a href="#readFileSync" class="headerlink" title="readFileSync"></a>readFileSync</h4><ul>
<li>有回傳值，回傳值就是檔案內容</li>
<li>必須等到回傳後才能繼續往下執行，也因此會造成阻塞</li>
</ul>
<h4 id="readFile"><a href="#readFile" class="headerlink" title="readFile"></a>readFile</h4><ul>
<li>多了一個參數，而且要傳進參數的是一個 function</li>
<li>執行完即可跳到下一行，檔案讀取完畢以後會把結果傳進 callback function</li>
</ul>
<p>而這同時也是 blocking 與 non-blocking 的差別，在不討論 JavaScript 的其他層面來說：</p>
<h4 id="阻塞（blocking）"><a href="#阻塞（blocking）" class="headerlink" title="阻塞（blocking）"></a>阻塞（blocking）</h4><p>代表執行時程式會卡住，會直接回傳結果，因此必須等檔案讀取完畢才能執行下一行。例如 readFileSync。</p>
<h4 id="非阻塞（non-blocking）"><a href="#非阻塞（non-blocking）" class="headerlink" title="非阻塞（non-blocking）"></a>非阻塞（non-blocking）</h4><p>代表執行時不會卡住，但執行結果不會放在回傳值，而是透過回呼函式（callback function）來接收結果。例如 readFile。</p>
<h2 id="Callback-function"><a href="#Callback-function" class="headerlink" title="Callback function"></a>Callback function</h2><p>callback function 的意思其實就是：「當某事發生的時候，請利用這個 function 通知我」。</p>
<p>通常 callback function 會簡化成匿名函式（Anonymous function）的寫法，也就是直接在第二個參數的地方宣告一個 function。</p>
<p>常見的形式會像這樣：</p>
<pre><code class="javascript=">// 讀取內建 fs 模組
const fs = require(&#39;fs&#39;)

// 讀取檔案
fs.readFile(&#39;./README.md&#39;, function(err, data) &#123;
  if (err) &#123;
    console.log(err)
  &#125; else &#123;
    console.log(data)
  &#125;
&#125;);</code></pre>
<p>在使用 callback function 時，需注意常見的錯誤：</p>
<ul>
<li>傳進去的參數是 callback function，是一個「function」，而不是 function 執行後的結果</li>
<li>舉例來說，fn 是一個 function；fn() 則是執行 function，並且會把執行完的回傳結果當作 callback function</li>
</ul>
<p>這裡以 setTimeout() 來作為範例：</p>
<pre><code class="javascript=">// 正確
setTimeout(2000, tick)
function tick() &#123;
  alert(&#39;時間到！&#39;)
&#125;

===以下是錯誤範例===

// 錯誤
setTimeout(2000, tick())
function tick() &#123;
  alert(&#39;時間到！&#39;)
&#125;

// 上面錯誤會等同於
let fn = tick()
setTimeout(2000, fn)
function tick() &#123;
  alert(&#39;時間到！&#39;)
&#125;
</code></pre>
<h2 id="Node-js-上的同步與非同步"><a href="#Node-js-上的同步與非同步" class="headerlink" title="Node.js 上的同步與非同步"></a>Node.js 上的同步與非同步</h2><p>其實到這邊已經差不多把同步與非同步的觀念講完了。而在 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2RvY3MvZ3VpZGVzL2Jsb2NraW5nLXZzLW5vbi1ibG9ja2luZy8=">Node.js 的官方文件<i class="fa fa-external-link-alt"></i></span>是這麼說的：</p>
<blockquote>
<p>Blocking methods execute synchronously and non-blocking methods execute asynchronously.</p>
</blockquote>
<p>阻塞的方法會同步地（synchronously）執行，而非阻塞的方法會非同步地（asynchronously）執行。</p>
<p>因此，當我們討論到 JavaScript 的同步與非同步問題時，基本上可以把非同步跟非阻塞劃上等號。</p>
<p>如果執行一個同步的方法（例如 readFileSync），就一定會阻塞；如果執行一個非同步的方法（例如 readFile），就一定不會阻塞。</p>
<p>也就是說，其實我們可以直接把上段重點改成：</p>
<ul>
<li>同步（synchronous）：代表執行時程式會卡住，會直接回傳結果，因此必須等檔案讀取完畢才能執行下一行。例如 readFileSync</li>
<li>非同步（asynchronous）：代表執行時不會卡住，但執行結果不會放在回傳值，而是透過回呼函式（callback function）來接收結果。例如 readFile</li>
</ul>
<h2 id="瀏覽器上的同步與非同步"><a href="#瀏覽器上的同步與非同步" class="headerlink" title="瀏覽器上的同步與非同步"></a>瀏覽器上的同步與非同步</h2><p>前面是以 Node.js 當做例子，再來回到我們熟悉的瀏覽器。</p>
<p>假設我們今天在 JavaScript 有一個函式叫做 假設我們有一個函式叫做getAPIResponse，能後和後端 API 串接拿取資料。</p>
<p>同步版本：</p>
<pre><code class="javascript=">const response = getAPIResponse()
console.log(response)</code></pre>
<p>JavaScript 執行後會一直等到回傳後，才會繼續執行下一行程式碼。假如今天要等到 10 秒後，API Server 才會回傳資料，這段期間等於說讓執行 JavaScript 的執行緒（thread）凍結。</p>
<p>在瀏覽器裡面，負責執行 JavaScript 的叫做 main thread，負責處理跟畫面渲染相關的也是 main thread。換句話說，如果這個 thread 凍結 10 秒，會造成無法點擊畫面，因為瀏覽器沒有資源去處理其他事情。</p>
<p>而瀏覽器裡執行 JavaScript 的 main thread 同時也負責畫面的 render，因此非同步顯得更加重要而且必須，否則等待的時候畫面會凍結，就像電腦當機了一樣。</p>
<p>那麼依照之前所學的，把程式碼改成非同步，也就是利用 callback function 來接收結果。這裡有三種寫法，解果都會相同：</p>
<pre><code class="javascript=">// 範例一：額外宣告函式
function handleResponst() &#123;
  console.log(response)
&#125;
getAPIResponse(handleResponst)

// 範例二：匿名函式
getAPIResponse(function(err, response) &#123;
  console.log(response)
&#125;)

// 範例三：利用 ES6 箭頭函式簡化過後
getAPIResponse((err, response) =&gt; &#123;
  console.log(response)
&#125;)</code></pre>
<hr>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><blockquote>
<p>推薦影片：<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj04YUdoWlFrb0ZiUQ==">What the heck is the event loop anyway? | Philip Roberts | JSConf EU<i class="fa fa-external-link-alt"></i></span><br>影片中的 Demo：<span class="exturl" data-url="aHR0cDovL2xhdGVudGZsaXAuY29tL2xvdXBlLz9jb2RlPUpDNXZiaWduWW5WMGRHOXVKeXdnSjJOc2FXTnJKeXdnWm5WdVkzUnBiMjRnYjI1RGJHbGpheWdwSUhzS0lDQWdJSE5sZEZScGJXVnZkWFFvWm5WdVkzUnBiMjRnZEdsdFpYSW9LU0I3Q2lBZ0lDQWdJQ0FnWTI5dWMyOXNaUzVzYjJjb0oxbHZkU0JqYkdsamEyVmtJSFJvWlNCaWRYUjBiMjRoSnlrN0lDQWdJQW9nSUNBZ2ZTd2dNakF3TUNrN0NuMHBPd29LWTI5dWMyOXNaUzVzYjJjb0lraHBJU0lwT3dvS2MyVjBWR2x0Wlc5MWRDaG1kVzVqZEdsdmJpQjBhVzFsYjNWMEtDa2dld29nSUNBZ1kyOXVjMjlzWlM1c2IyY29Ja05zYVdOcklIUm9aU0JpZFhSMGIyNGhJaWs3Q24wc0lEVXdNREFwT3dvS1kyOXVjMjlzWlM1c2IyY29JbGRsYkdOdmJXVWdkRzhnYkc5MWNHVXVJaWs3ISEhUEdKMWRIUnZiajVEYkdsamF5QnRaU0U4TDJKMWRIUnZiajQ9">Event Loop 流程<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>因為 JavaScript 是單執行緒（single thread）的程式語言，用白話文解釋就是「JavaScript 一次只能做一件事情」，因此 JS 中等待執行的任務會被放入 Call Stack。</p>
<p>JavaScript 在調用一個執行環境時，其實會經過兩個階段：</p>
<ol>
<li>建立階段：呼叫堆疊（Call Stack）</li>
</ol>
<p>當開始執行 JavaScript 時，會先進入 Global EC。直到我們呼叫一個 function 時，才會建立一個新的執行環境繼續往 Global EC 的上層依序堆疊。</p>
<p>而尚未被執行的任務會進入 call stack，裡面會放著每個 function 執行時需要用到的資源，以及記錄 function 執行的順序。</p>
<p>這些過程都發生在開始執行內部程式碼之前，也就是建立階段。對 JS 引擎來說，屬於執行前的編譯階段，而 hoisting 就是在此階段進行處理。</p>
<ol start="2">
<li>執行階段：執行堆疊（Execution Stack）</li>
</ol>
<p>接著 JavaScript 會優先處理執行堆疊中最上面的執行環境。一旦執行完該 function 後，該執行環境就會從最上面被移除（pop off），同時儲存在該 function 中的資訊也會被銷毀，然後再回到之前的執行環境，直到回到 Global EC 為止。</p>
<p>可參考下方示意圖：</p>
<p><img src="https://i.imgur.com/SiRxsOL.png"><br>（參考來源：<span class="exturl" data-url="aHR0cHM6Ly9kZXYudG8vYWhtZWR0YWhpci93aGF0LWlzLXRoZS1leGVjdXRpb24tY29udGV4dC1leGVjdXRpb24tc3RhY2stc2NvcGUtY2hhaW4taW4tanMtMjZuYyVFRiVCQyU4OQ==">https://dev.to/ahmedtahir/what-is-the-execution-context-execution-stack-scope-chain-in-js-26nc）<i class="fa fa-external-link-alt"></i></span></p>
<p>但 call stack 能夠存取的內容是有限的，一旦超出 stack 負荷就有可能出現錯誤 stack overflow。例如遞迴呼叫一個 function 十萬次，因為 stack 沒辦法存這麼多東西，就會拋出錯誤。</p>
<p>既然 JavaScript 同一個時間只能執行一件事，那要如何達到非同步操作呢？回到先前談的執行環境。</p>
<p>這裡以 setTimeout 為例：</p>
<p>setTimeout(fn, 2000) 只是在告訴瀏覽器說：「2 秒以後幫我呼叫 fn 這個 function」，瀏覽器就可以開另外一個 thread 去計時，而不是利用 main thread 做這件事。</p>
<p>當這些其他 thread 的事情做完以後，要再重新丟回 main thread 執行 JavaScript，這就是 Event Loop 在做的事情。</p>
<p>可參考這張 Event Loop 示意圖：</p>
<p><img src="https://i.imgur.com/F4oAQmS.png"></p>
<p>（圖片來源：<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BSYWh1bHgxL3VuZGVyc3RhbmRpbmctZXZlbnQtbG9vcC1jYWxsLXN0YWNrLWV2ZW50LWpvYi1xdWV1ZS1pbi1qYXZhc2NyaXB0LTYzZGNkMmM3MWVjZA==">Understanding Event Loop, Call Stack, Event &amp; Job Queue in Javascript<i class="fa fa-external-link-alt"></i></span>）</p>
<p>以執行 setTimeout(fn, 2000) 這行程式碼來說，步驟可想像成：</p>
<ol>
<li>執行 setTimeout(fn, 2000)，先把 setTimeout(fn, 2000) 丟到 call stack 去執行</li>
<li>因為 setTimeout 屬於 Web API，會告訴瀏覽器「設定計時，經過 2000 毫秒以後呼叫 fn」</li>
<li>執行結束，從 call stack 移除任務</li>
<li>當瀏覽器計時 2000 毫秒後，會呼叫 fn 並丟到 callback queue 等待執行</li>
</ol>
<p>接著是 Event Loop，藉由這個機制不斷偵測 call stack 是否為空，如果是空的，就把 callback queue 裡面的東西丟到 call stack。</p>
<p>Event Loop 其實有 loop（迴圈）概念在，可以表示成這樣：</p>
<pre><code class="javascript=">while(true) &#123;
  // 如果 call stack 為空 且 callback quere 有排程
  if (callStack.length === 0 &amp;&amp; callbackQueue.length &gt; 0) &#123;
    // 拿出 callbackQueue 的第一個元素，並放到 callStack
    callStack.push(callbackQueue.dequeue())
  &#125;
&#125;</code></pre>
<p>簡單來說，非同步的 callback function 會先被放到 callback queue，並且等到 call stack 為空時候才被 Event loop 丟進去 call stack，真正負責執行的還是 JavaScript 的 main thread。</p>
<h3 id="牛刀小試"><a href="#牛刀小試" class="headerlink" title="牛刀小試"></a>牛刀小試</h3><p>再舉一個常見例子，下面程式碼中應該哪行會先被執行？</p>
<pre><code class="javascript=">setTimeout(() =&gt; &#123;
  console.log(&#39;零秒出手&#39;)
&#125;, 0)
console.log(&#39;hello&#39;)
// hello</code></pre>
<p>思考方式：</p>
<ol>
<li>在 0ms 後，callback function 會被放到 callback queue 中等待執行</li>
<li>因為 call stack 還不是空的，這裡會先繼續執行 console.log(‘hello’)</li>
<li>執行結束，call stack 被清空</li>
<li>event loop 才會把 callback 放到 call stack</li>
<li>執行 callback 裡面的 console.log(‘零秒出手’)</li>
</ol>
<p>因此輸出順序會先是 <code>hello</code>，然後才是 <code>零秒出手</code>。</p>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>閱讀完這篇文章，原本對 callback 概念薄弱的自己，對同步與非同步又有了新的一層認識。</p>
<p>尤其是前幾天才剛學完有關 <span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWpzMjAxLWhvaXN0aW5n">Hoisting<i class="fa fa-external-link-alt"></i></span> 的運作原理，瞭解什麼是執行環境以及執行堆疊以後，再回來看 Event Loop 似乎也更能夠理解當中的執行流程。</p>
<p>是說現在再次看到 Node.js 是 JavaScript 的 runtime（執行環境）這句話時，會想到 Execution context 中文也被翻成執行環境，但兩者指的對象不同。前者指的是「執行時系統」（run-time system）；後者指的是 JavaScript 在執行時會建立的環境，又可分為全域與函式執行環境。翻成中文的壞處就是容易撞名混淆，還是讓自己盡量去理解原文的意思。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 13] 前端進階 - 如何優化執行 CSS 效能</title>
    <url>/css-optimization/</url>
    <content><![CDATA[<h2 id="前端優化"><a href="#前端優化" class="headerlink" title="前端優化"></a>前端優化</h2><p>關於前端優化方式，可從下列幾個方向進行：</p>
<ul>
<li>資源本身的大小</li>
<li>資源載入的方式</li>
<li>資源執行的方式<a id="more"></a>
<h2 id="CSS-優化"><a href="#CSS-優化" class="headerlink" title="CSS 優化"></a>CSS 優化</h2></li>
</ul>
<h3 id="節省資源大小"><a href="#節省資源大小" class="headerlink" title="節省資源大小"></a>節省資源大小</h3><ul>
<li>Minify：省略空白字元，電腦可直接辨識<ul>
<li>例如：<code>nps sass --style=compressed main.sass masin.css</code></li>
</ul>
</li>
<li>gzip*：壓縮，會進行編碼，通常是在 server 端進行，電腦會經過解碼後再使用</li>
</ul>
<p>通常會先進行 Minify 再進行 gzip*，藉此壓縮資源大小。</p>
<h3 id="載入方式"><a href="#載入方式" class="headerlink" title="載入方式"></a>載入方式</h3><ul>
<li>Critical CSS：分批載入，先載入重要的部分<ul>
<li>例如：把 navbar、banner 樣式放到 index.html，在讀取 css 之前即可先被載入</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/sywJHI7.png"></p>
<ul>
<li>CSS Sprites：將每個小檔案打包後，只需發出一個 Request  ，載入完成後再拆開引用<ul>
<li>例如：將小圖片打包成大圖片，再取用需要的區塊</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/XV6V5ak.png"></p>
<ul>
<li>Cache*：將資料暫存在瀏覽器，只有第一次登入網站需下載，之後就能快速讀取暫存檔</li>
</ul>
<p><img src="https://i.imgur.com/8n3U6Qj.png"></p>
<h3 id="執行方式"><a href="#執行方式" class="headerlink" title="執行方式"></a>執行方式</h3><ul>
<li><p>選擇器：降低選擇器的複雜性</p>
<ul>
<li>例如：使用 Sass 巢狀語法時，需考慮到編譯後程式碼的複雜性</li>
</ul>
</li>
<li><p>屬性渲染：需考慮到屬性載入的順序</p>
<ul>
<li>例如：特效網頁或有 SEO 考量的網站，需注意動畫或特效會在哪個階段匯入</li>
</ul>
</li>
</ul>
<hr>
<h2 id="CSS-Sprites-與-Data-URI-的優缺點"><a href="#CSS-Sprites-與-Data-URI-的優缺點" class="headerlink" title="CSS Sprites 與 Data URI 的優缺點"></a>CSS Sprites 與 Data URI 的優缺點</h2><h3 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h3><p>CSS Sprite 是將頁面中所使用到的小圖片整合到一張大圖上。也就是說，在加載一個包含多個圖片的頁面上時，只需使用一個HTTP請求而不需要 JavaScript 代碼。</p>
<ul>
<li>優點：減少 http 請求</li>
<li>缺點：圖片合併定位費時費力</li>
</ul>
<h4 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h4><ul>
<li>切圖前就需構思拼接好圖片</li>
<li>排序有序，便於後期維護。有利於 background-position 定位</li>
<li>定位時避免使用 right, bottom 等</li>
<li>合理預留空白位置（空太多檔案變大，太小引起圖示重疊）</li>
</ul>
<h3 id="Data-URI"><a href="#Data-URI" class="headerlink" title="Data URI"></a>Data URI</h3><p>image data URI 是將圖片資源轉換為 base64 字串格式嵌到頁面或樣式中。不需要圖片的請求連結。</p>
<ul>
<li>優點：<ul>
<li>減少 HTTP 請求</li>
<li>避免某些檔案跨域</li>
<li>無圖片快取等問題</li>
</ul>
</li>
<li>缺點：<ul>
<li>相容性（IE6,7 不相容，可使用 MHTML 來解決）</li>
<li>瀏覽器不會快取該圖片</li>
<li>增加 css 檔案大小</li>
<li>編碼成本及維護</li>
</ul>
</li>
</ul>
<h4 id="使用技巧-1"><a href="#使用技巧-1" class="headerlink" title="使用技巧"></a>使用技巧</h4><ul>
<li>data URI 可使用在：<ul>
<li>圖片尺寸很小，使用一條 http 請求有點浪費，如：漸變背景框</li>
<li>圖片在全站大規模使用，且很少被更新的，如：loading 圖</li>
</ul>
</li>
<li>標籤語法<ul>
<li>data：取得資料協議</li>
<li>image/png：取得資料的協議名稱（注意這裡也圖片資源也可以使用字型等）</li>
<li>base64：資料編碼方式</li>
<li>iVBOR…：編碼後資料</li>
</ul>
</li>
</ul>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlcnR3LmNvbS8lRTUlODklOEQlRTclQUIlQUYlRTklOTYlOEIlRTclOTklQkMvMTg0MDAzLyNvdXRsaW5lX18x">主流CSS image比較<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cub3NjaGluYS5uZXQvdHJhbnNsYXRlL2Nzcy1zcHJpdGVzLXZzLWRhdGEtdXJpcy13aGljaC1pcy1mYXN0ZXItb24tbW9iaWxlP3ByaW50">CSS Sprites vs. Data URIs:在移动端，谁更快？<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>Front-End</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 6] CSS - 認識基礎標籤 &amp; 屬性</title>
    <url>/css/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUxMDEtaHRtbC1jc3M=">[FE101] 前端基礎：HTML 與 CSS<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<pre><code>學習目標:

 P1 你知道 CSS 是什麼
 P1 你知道 inline、block 跟 inline-block 的區別
 P1 你知道什麼是 box model
 P1 你知道 position 的所有屬性及其差別
 P2 你知道 :hover, :before, :after
 P2 你知道 :nth-child 的各種用法
 P2 你熟悉 CSS selector，可以輕鬆選到想選到的元素</code></pre>
<a id="more"></a>
<h2 id="什麼是-CSS？"><a href="#什麼是-CSS？" class="headerlink" title="什麼是 CSS？"></a>什麼是 CSS？</h2><p>Cascading Style Sheets 階層式樣式表</p>
<h2 id="如何引入-CSS"><a href="#如何引入-CSS" class="headerlink" title="如何引入 CSS"></a>如何引入 CSS</h2><h3 id="使用內部-CSS"><a href="#使用內部-CSS" class="headerlink" title="使用內部 CSS"></a>使用內部 CSS</h3><ol>
<li>直接在 body 的元素內加上 <code>style=&quot;&quot;</code></li>
</ol>
<pre><code class="htmlmixed=">&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;網頁前端&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!--   文字變紅色 --&gt;
    &lt;div style=&quot;color: red;&quot;&gt;
      網頁前端課程
    &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<ol start="2">
<li>在 head 裡加上 <code>&lt;style&gt;</code> 標籤：</li>
</ol>
<pre><code class="htmlmixed=">&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;網頁前端&lt;/title&gt;
        &lt;style&gt;
          div &#123;
            color: blue;
          &#125;
        &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!--   文字變藍色 --&gt;
    &lt;div&gt;
      網頁前端課程
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="使用外部-CSS"><a href="#使用外部-CSS" class="headerlink" title="使用外部 CSS"></a>使用外部 CSS</h3><p>使用 <code>&lt;link&gt;</code> 元素，從外部引用 CSS 檔，這是一個空白的元素（不需要結束標記）：</p>
<ul>
<li><code>href</code>：指定 CSS 檔的路徑，通常放在 css 或 styles 資料夾</li>
<li><code>rel</code>：表示 HTML 頁面與連結其連結檔案的關係，連到 CSS 檔其值應為 stylesheet</li>
</ul>
<p>將 style.css 引入 index.html 為例：</p>
<pre><code class="htmlmixed=">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;網頁前端&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; &gt;
&lt;/head&gt;
&lt;body&gt;
  網頁前端課程
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>內部引入的兩種方法，因不易維護而較少使用。使用外部引入的優點如下：</p>
<ol>
<li>將內容和外觀分開，結構較清楚</li>
<li>可在不同頁面使用同一個樣式規則，不需修改每個檔案，便於維護</li>
</ol>
<h2 id="CSS-Selector"><a href="#CSS-Selector" class="headerlink" title="CSS Selector"></a>CSS Selector</h2><p>利用 CSS 選取器，可將規則套用在 HTML 文件的特定元素上，寫法如下：</p>
<pre><code class="htmlmixed=">&lt;!-- 選取器 --&gt;
selector &#123;
  &lt;!--   宣告（分成屬性和值兩個部分） --&gt;
  attribute: value;
&#125;</code></pre>
<h3 id="全域選擇器"><a href="#全域選擇器" class="headerlink" title="全域選擇器"></a>全域選擇器</h3><ul>
<li>Universal Selector：套用到文件的所有元素。</li>
</ul>
<pre><code class="htmlmixed=">&lt;!-- 所有背景均為藍色 --&gt;
* &#123;
  background: blue
&#125;</code></pre>
<h3 id="標籤選取器"><a href="#標籤選取器" class="headerlink" title="標籤選取器"></a>標籤選取器</h3><ul>
<li>找出符合的元素名稱。</li>
</ul>
<pre><code class="htmlmixed=">&lt;!-- 將所有 &lt;h3&gt; 元素套用該樣式 --&gt;
h3 &#123;
  color: red
&#125;</code></pre>
<h3 id="類別選取器"><a href="#類別選取器" class="headerlink" title="類別選取器"></a>類別選取器</h3><ul>
<li>CLASS Selector：找出 class 屬性值符合句號後之值的元素。</li>
</ul>
<pre><code class="htmlmixed=">&lt;!-- 找出所有 class 屬性之值為 note 的元素 --&gt;
.note &#123;&#125;

&lt;!-- 找出所有 class 屬性之值為 note 的 &lt;h3&gt; 元素 --&gt;
h3.note&#123;&#125;</code></pre>
<h3 id="ID-選取器"><a href="#ID-選取器" class="headerlink" title="ID 選取器"></a>ID 選取器</h3><ul>
<li>和 class 的最大不同，在於整個網頁上 id 只能有一個。</li>
</ul>
<pre><code class="htmlmixed=">&lt;!-- 找出 id 為 name 的元素 --&gt;
#name &#123;&#125;</code></pre>
<h3 id="子元素選取器"><a href="#子元素選取器" class="headerlink" title="子元素選取器"></a>子元素選取器</h3><ul>
<li>利用 <code>&gt;</code> 區隔兩個元素，表示在有父子關係的元素才會套用。</li>
<li>與後代選取器的差異在於中間不能插入其他元素。</li>
</ul>
<pre><code class="htmlmixed=">&lt;!-- 找出任何身為 &lt;li&gt; 元素之子的 &lt;a&gt; 元素 --&gt;
li &gt; a &#123;
  color: red;
&#125;</code></pre>
<h3 id="後代選取器"><a href="#後代選取器" class="headerlink" title="後代選取器"></a>後代選取器</h3><ul>
<li>利用空白鍵區隔兩個元素。</li>
<li>中間可堆疊其他元素。</li>
</ul>
<pre><code class="htmlmixed=">&lt;!-- 找出任何位在 &lt;li&gt; 元素內的 &lt;a&gt; 元素 --&gt;
li a &#123;
  color: yellow;
&#125;</code></pre>
<h3 id="偽類選取器"><a href="#偽類選取器" class="headerlink" title="偽類選取器"></a>偽類選取器</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL1BzZXVkby1jbGFzc2Vz">Pseudo-classes 偽類一覽表<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>以 hover（滑鼠滑入的樣式）為例：</p>
<pre><code class="htmlmixed=">&lt;!-- 當滑鼠移至任何 a 連結上時，背景會變成黃色 --&gt;
a:hover &#123;
  background: yellow
&#125;</code></pre>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS9jc3NyZWYvY3NzX3NlbGVjdG9ycy5hc3A=">CSS Selectors Reference - W3Schools<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="nth-child-n-選擇器"><a href="#nth-child-n-選擇器" class="headerlink" title="nth-child(n) 選擇器"></a>nth-child(n) 選擇器</h3><p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRyZWFkMDEuY29tL2NvbnRlbnQvMTU0MTEwNTgyMy5odG1s">CSS選取第幾個標籤元素：nth-child(n)、first-child、last-child<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="CSS-Selector-的權重計算方式"><a href="#CSS-Selector-的權重計算方式" class="headerlink" title="CSS Selector 的權重計算方式"></a>CSS Selector 的權重計算方式</h3><p>當選擇器作用在同一元素上時：</p>
<ul>
<li>兩個權重不同：權重值高的規則生效</li>
<li>兩個權重相同：後面覆蓋前面</li>
</ul>
<p>權重由高到低如下：</p>
<pre><code>!important &gt; inline style &gt; id &gt; class &gt; tag &gt; *</code></pre>
<p>各類選擇器：</p>
<ul>
<li>!important：權重最高，但在實際開發過程，幾乎不會使用 !important 來覆蓋其他規則</li>
<li>inline style 行內樣式<ul>
<li>權重為 1-0-0-0</li>
</ul>
</li>
<li>id 選擇器（<code>#</code>）<ul>
<li>權重為 0-1-0-0</li>
</ul>
</li>
<li>class 類別選擇器、pseudo class 偽類選擇器、attribute 屬性選擇器<ul>
<li>權重為 0-0-1-0</li>
</ul>
</li>
<li>tag 標籤選擇器、pseudo elements 偽元素選擇器<ul>
<li>權重為 0-0-0-1</li>
</ul>
</li>
<li>萬用選擇器（<code>*</code>）：選擇所有元素<ul>
<li>預設為 0-0-0-0</li>
</ul>
</li>
</ul>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9tdWtpLnR3L3RlY2gvY3NzLXNwZWNpZmljaXR5LWRvY3VtZW50Lw==">強烈推薦收藏好物 – CSS Specificity (CSS 權重一覽)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWZhOThiZjUxODgyNTQyYzgzMmU1ZWM=">你對 CSS 權重真的足夠了解嗎？<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h2 id="box-model-盒模型"><a href="#box-model-盒模型" class="headerlink" title="box model 盒模型"></a>box model 盒模型</h2><p>盒模型又稱為區塊模型，意思是所有 HTML 元素均可被視為一個盒子。我們能透過 CSS 控制內距、外距、邊框屬性，來調整盒子的外觀及位置。</p>
<p><img src="https://i.imgur.com/HzfLkAY.png" alt="box model"></p>
<p>盒模型的組成由外而內分別為：</p>
<ul>
<li>margin（外邊距）</li>
<li>border（邊框）</li>
<li>padding（內邊距）</li>
<li>content（內容）</li>
</ul>
<h3 id="box-sizing-屬性"><a href="#box-sizing-屬性" class="headerlink" title="box-sizing 屬性"></a>box-sizing 屬性</h3><p>透過這個屬性，我們能控制盒模型長寬的計算方式。</p>
<p>以長寬同樣為 150px 的 box 為例：</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="Box Model" src="https://codepen.io/heidiliu2020/embed/GRoeoaO?height=265&theme-id=dark&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/heidiliu2020/pen/GRoeoaO'>Box Model</a> by Heidi-Liu
  (<a href='https://codepen.io/heidiliu2020'>@heidiliu2020</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<p>我們可以使用 DevTool 看盒模型：</p>
<ul>
<li><code>box-sizing: content-box</code>：為預設屬性。「內容」就等於長寬度。</li>
</ul>
<p><img src="https://i.imgur.com/euaGSlb.png" alt="content-box"><br>加上 border 和 padding 會導致元素實際大小比設定值還大。</p>
<ul>
<li><code>box-sizing: border-box</code>：「邊框到邊框之間的範圍」等於長寬度。</li>
</ul>
<p><img src="https://i.imgur.com/BdytGoL.png" alt="border-box"><br>此時長寬設定會套用到 border、padding、content。</p>
<p>而 margin 在兩種盒模型都是額外加上去的，並不會影響盒子長寬。</p>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvR3VpZGUvQ1NTL0dldHRpbmdfc3RhcnRlZC9Cb3hlcw==">盒模型- Web 开发者指南| MDN<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cud2liaWJpLmNvbS9pbmZvLnBocD90aWQ9Q1NTX2JveF9tb2RlbF8lRTclOUIlOTIlRTUlQUQlOTAlRTYlQTglQTElRTUlOUUlOEI=">CSS box model 盒子模型- Wibibi<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3Bhc3Npb25yZWQvY3NzJUU2JThFJTkyJUU3JTg5JTg4JUU1JTlGJUJBJUU3JUE0JThFJUU4JUE3JTgwJUU1JUJGJUI1LSVFNCVCOCU4MC1ib3gtbW9kZWwtMTNhOWEzZGZlODRm">CSS排版基礎觀念（一）—— box-model<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h2 id="display-inline-block-跟-inline-block-的差別"><a href="#display-inline-block-跟-inline-block-的差別" class="headerlink" title="display: inline, block 跟 inline-block 的差別"></a>display: inline, block 跟 inline-block 的差別</h2><p>display 是 CSS 中用於控制排版的屬性。每個 HTML 元素都有一個預設的 display 值，大部分的元素可分為 block（區塊元素）和 inline（行內元素）兩類：</p>
<h3 id="block：區塊元素"><a href="#block：區塊元素" class="headerlink" title="block：區塊元素"></a>block：區塊元素</h3><ul>
<li>元素寬度預設會占滿整行</li>
<li>可設定寬高/margin/padding，但會占滿一整行</li>
<li>常見區塊元素：div、h1~h6、p、ul、li 等</li>
</ul>
<h3 id="inline：行內元素"><a href="#inline：行內元素" class="headerlink" title="inline：行內元素"></a>inline：行內元素</h3><ul>
<li>元素可在同一行內呈現</li>
<li>無法設定寬高，元素的寬高靠內容物撐開</li>
<li>仍可設定上下 margin/padding，但字仍在行內，排版不會隨設定改變</li>
<li>常見行內元素：a、span、input、img 等</li>
</ul>
<h3 id="inline-block：行內區塊元素"><a href="#inline-block：行內區塊元素" class="headerlink" title="inline-block：行內區塊元素"></a>inline-block：行內區塊元素</h3><ul>
<li>以 inline 方式呈現：可水平排列</li>
<li>擁有 block 的屬性：可設定元素的寬高/margin/padding</li>
</ul>
<h3 id="以長寬同樣為-100px-的-box-為例："><a href="#以長寬同樣為-100px-的-box-為例：" class="headerlink" title="以長寬同樣為 100px 的 box 為例："></a>以長寬同樣為 100px 的 box 為例：</h3><h4 id="display-block"><a href="#display-block" class="headerlink" title="display: block"></a><code>display: block</code></h4><p><img src="https://i.imgur.com/jx5DjYZ.png" alt="block"></p>
<h4 id="display-inline"><a href="#display-inline" class="headerlink" title="display: inline"></a><code>display: inline</code></h4><p><img src="https://i.imgur.com/SBjWPnH.png" alt="inline"></p>
<h4 id="display-inline-block"><a href="#display-inline-block" class="headerlink" title="display: inline-block"></a><code>display: inline-block</code></h4><p><img src="https://i.imgur.com/I4pokc3.png" alt="inline-block"></p>
<h3 id="以文字排版為例："><a href="#以文字排版為例：" class="headerlink" title="以文字排版為例："></a>以文字排版為例：</h3><iframe height="265" style="width: 100%;" scrolling="no" title="Box Model" src="https://codepen.io/heidiliu2020/embed/xxZBNPR?height=265&theme-id=dark&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/heidiliu2020/pen/xxZBNPR'>display</a> by Heidi-Liu
  (<a href='https://codepen.io/heidiliu2020'>@heidiliu2020</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<h3 id="Display-實戰篇：以製作圖文小卡為例"><a href="#Display-實戰篇：以製作圖文小卡為例" class="headerlink" title="Display 實戰篇：以製作圖文小卡為例"></a>Display 實戰篇：以製作圖文小卡為例</h3><iframe height="327" style="width: 100%;" scrolling="no" title="Display 實戰：切出圖文小卡" src="https://codepen.io/heidiliu2020/embed/VweNLwm?height=327&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/heidiliu2020/pen/VweNLwm'>Display 實戰：切出圖文小卡</a> by Heidi-Liu
  (<a href='https://codepen.io/heidiliu2020'>@heidiliu2020</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0B3ZW5keTE5OTI4OC9jc3MlRTYlOTUlOTklRTUlQUQlQjgtJUU5JTk3JTlDJUU2JTk2JUJDZGlzcGxheS1pbmxpbmUtaW5saW5lLWJsb2NrLWJsb2NrJUU3JTlBJTg0JUU1JUI3JUFFJUU1JTg4JUE1LTEwMzRmMzhlZGE4Mg==">CSS教學-關於display:inline、block、inline-block的差別<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIwNDk1Ng==">金魚都能懂網頁設計入門 : 網頁兩大主角 (鐵人賽第十天)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC10dy5sZWFybmxheW91dC5jb20vZGlzcGxheS5odG1s">關於”display” 屬性 - CSS<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h2 id="Position-屬性"><a href="#Position-屬性" class="headerlink" title="Position 屬性"></a>Position 屬性</h2><ul>
<li>position 屬性可用來指定元素定位方式，以進行版面配置。</li>
<li>當我們使用定位元素時，若元素方框重疊，可搭配 z-index 屬性設定元素堆疊順序。</li>
</ul>
<h3 id="static：正常流向"><a href="#static：正常流向" class="headerlink" title="static：正常流向"></a>static：正常流向</h3><ul>
<li>為預設值。在瀏覽器中會依照預設配置，由上而下自動排列</li>
</ul>
<h3 id="relative：相對定位"><a href="#relative：相對定位" class="headerlink" title="relative：相對定位"></a>relative：相對定位</h3><ul>
<li>以「原本顯示的位置」作為基準，且該元素原本所佔的空間仍會保留</li>
</ul>
<h3 id="absolute：絕對定位"><a href="#absolute：絕對定位" class="headerlink" title="absolute：絕對定位"></a>absolute：絕對定位</h3><ul>
<li>跳脫排版流，不會影響頁面其他元素</li>
<li>以「基準元素」左上角為起點，進行絕對位移。基準元素是往上層找的「第一個 position 不是 static 的元素」，才可作為定位點</li>
<li>若沒有指定基準元素，預設是以 body 元素（整個視窗）左上角為起點</li>
</ul>
<h3 id="fixed：固定定位"><a href="#fixed：固定定位" class="headerlink" title="fixed：固定定位"></a>fixed：固定定位</h3><ul>
<li>跳脫排版流。是一種絕對定位，同樣不影響其他元素</li>
<li>將元素固定在瀏覽器視窗的相對位置，捲動頁面時仍會在固定位置</li>
</ul>
<h3 id="以文字排版為例：-1"><a href="#以文字排版為例：-1" class="headerlink" title="以文字排版為例："></a>以文字排版為例：</h3><iframe height="265" style="width: 100%;" scrolling="no" title="定位元素：relative, absolute, fixed" src="https://codepen.io/heidiliu2020/embed/BajbgEK?height=265&theme-id=dark&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/heidiliu2020/pen/BajbgEK'>定位元素：relative, absolute, fixed</a> by Heidi-Liu
  (<a href='https://codepen.io/heidiliu2020'>@heidiliu2020</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<h3 id="Position-實戰篇：以製作彈窗為例"><a href="#Position-實戰篇：以製作彈窗為例" class="headerlink" title="Position 實戰篇：以製作彈窗為例"></a>Position 實戰篇：以製作彈窗為例</h3><iframe height="265" style="width: 100%;" scrolling="no" title="Position 實戰：製作彈窗" src="https://codepen.io/heidiliu2020/embed/xxZBobX?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/heidiliu2020/pen/xxZBobX'>Position 實戰：製作彈窗</a> by Heidi-Liu
  (<a href='https://codepen.io/heidiliu2020'>@heidiliu2020</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC10dy5sZWFybmxheW91dC5jb20vcG9zaXRpb24uaHRtbA==">關於position 屬性 - 學習CSS 版面配置<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cud2liaWJpLmNvbS9pbmZvLnBocD90aWQ9MTU2">CSS position 位置屬性（定位） - Wibibi<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3VpLXV4JUU3JUI3JUI0JUU1JThBJTlGJUU1JTlEJThBL3Bvc2l0aW9uLSVFNSVCMSVBQyVFNiU4MCVBNyVFNyU5QSU4NCVFNSU5RiVCQSVFNyVBNCU4RSVFNiVBNiU4MiVFNSVCRiVCNS01OTMxMjU0ZTUyMDM=">position 屬性的基礎概念 - Medium<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h2 id="水平置中："><a href="#水平置中：" class="headerlink" title="水平置中："></a>水平置中：</h2><h3 id="margin-auto"><a href="#margin-auto" class="headerlink" title="margin: auto;"></a><code>margin: auto;</code></h3><p>設定左右外邊距（margin-left 與 margin-right）為 auto 可達成水平居中。</p>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly96aC10dy5sZWFybmxheW91dC5jb20vbWFyZ2luLWF1dG8uaHRtbA==">學習 CSS 版面配置<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="補充：盒模型為什麼無法貼邊？"><a href="#補充：盒模型為什麼無法貼邊？" class="headerlink" title="補充：盒模型為什麼無法貼邊？"></a>補充：盒模型為什麼無法貼邊？</h2><p>盒模型在瀏覽器中會有默認的外邊距。此時只要利用 CSS Reset 即可解決空隙問題。</p>
<h3 id="CSS-Reset"><a href="#CSS-Reset" class="headerlink" title="CSS Reset"></a>CSS Reset</h3><ul>
<li>方法一：利用全域選擇器</li>
</ul>
<pre><code class="htmlmixed=">* &#123;
  margin: 0;
  padding: 0;
&#125;</code></pre>
<ul>
<li>方法二：直接對元素進行設定</li>
</ul>
<pre><code class="htmlmixed=">/* 設定基底字體大小 */
html &#123;
  font-size: 12px;
&#125;
/* 取消預設空隙 */
html, body, h1, h2, h3, h4, p&#123;
  padding: 0;
  margin: 0 ;
&#125;</code></pre>
<h3 id="CSS-Reset-與-CSS-normalize"><a href="#CSS-Reset-與-CSS-normalize" class="headerlink" title="CSS Reset 與 CSS normalize"></a>CSS Reset 與 CSS normalize</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZXllcndlYi5jb20vZXJpYy90b29scy9jc3MvcmVzZXQv">CSS Reset<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>優點：統整、重置了各個瀏覽器的樣式設定。<br>缺點：必須全部重新做設定，比較沒有彈性。且在使用開發者工具時，會看到一大坨的繼承鏈（inheritance chain）。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9uZWNvbGFzLmdpdGh1Yi5pby9ub3JtYWxpemUuY3NzLw==">Normalize.css<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>最大的特色就是保留原本預設 HTML 標籤的樣式，僅針對不同瀏覽器與各版本間不相容的標籤進行些微調整。</p>
<p>參考資料：<br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDE5NjUyOA==">Day21：小事之CSS Reset 與CSS normalize<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="切版注意事項"><a href="#切版注意事項" class="headerlink" title="切版注意事項"></a>切版注意事項</h2><h3 id="盡量不要把高度寫死"><a href="#盡量不要把高度寫死" class="headerlink" title="盡量不要把高度寫死"></a>盡量不要把高度寫死</h3><p>例如：.header、.content、.footer 不用寫死高度，以內容撐出高度，並用 padding 產生留白，往後若更動內容才不易跑版。</p>
<h3 id="如何垂直置中？"><a href="#如何垂直置中？" class="headerlink" title="如何垂直置中？"></a>如何垂直置中？</h3><ul>
<li>加上 padding 留白</li>
<li>使用行高，但僅限只有一行字的時候才能使用</li>
</ul>
<p>原理：「DIV 區塊的高度設定 = 文字的 line-height（行高）」</p>
<h3 id="如何水平置中？"><a href="#如何水平置中？" class="headerlink" title="如何水平置中？"></a>如何水平置中？</h3><ul>
<li>文字水平置中：<code>text-align: center</code> </li>
<li>區塊元素本身置中：<code>margin: 0 auto</code></li>
</ul>
<hr>
<h2 id="如何讓-img-自適應容器大小"><a href="#如何讓-img-自適應容器大小" class="headerlink" title="如何讓 img 自適應容器大小"></a>如何讓 img 自適應容器大小</h2><p>不管容器有多大，只要將 img 的寬高設定成 100 %（這裡的100%是相對於父級寬高而言）就能自適應容器大小。</p>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRyZWFkMDEuY29tL2NvbnRlbnQvMTU0NjY3MzI1MC5odG1s">css讓圖片自適應容器（div）大小- IT閱讀 - ITREAD01.COM<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="CSS-屬性用法紀錄"><a href="#CSS-屬性用法紀錄" class="headerlink" title="CSS 屬性用法紀錄"></a>CSS 屬性用法紀錄</h2><ol>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmphLWFueXRoaW5nLmNvbS8yMDE4LzAxLzE3L2Nzcy0lRTglQUUlOTMlRTklODElOEUlRTklOTUlQjclRTclOUElODQlRTYlOTYlODclRTUlQUQlOTclRTklOUElQjElRTglOTclOEYlRTglQUUlOEEtY3NzLXRvLW1ha2UtdGV4dC1vdmVyZmxvdy1lbGVnYW50LWlzLXdpdGgtZWxsaXBzZXMtc2luZ2xlLW9yLW11bHRpcGxlLWxpbmVzLw==">CSS 限制字數/行數，讓過長的文字隱藏變”…”<i class="fa fa-external-link-alt"></i></span></p>
<pre><code class="css">/* 修飾過長的文字，ellipsis：用點點點來表示被切斷的字串 */
text-overflow: ellipsis;
/* 不進行換行 */
white-space: nowrap</code></pre>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNjcGx1cy5jb20vY29udGVudC9jc3MzLWJveC1zaGFkb3c=">box-shadow 屬性的參數<i class="fa fa-external-link-alt"></i></span></p>
<pre><code class="css">/* 投影方式 X軸偏移 Y軸偏移 模糊半徑 擴展半徑 顏色&#125;*/
box-shadow:inset x-offset y-offset blur-radius spread-radius color</code></pre>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWlud3QuY29tL3dlYmRlc2lnbi1kZXYvY3NzLzIxNTM4Lmh0bWw=">[教學] CSS3 半透明背景的四種設定方法 (RGBa、HSLa、Opacity、HEX)<i class="fa fa-external-link-alt"></i></span></p>
<pre><code class="css">opacity: x
/* x　取值 0~1，該區塊元素均會調整透明度 */
background: rgba(red, green, blue, alpha)
/* alpha 代表透明度，取值 0~1 */</code></pre>
</li>
<li><p>決定換行的屬性</p>
<pre><code class="css">/* 預設不換行 */
flex-wrap: no-wrap;
/* 換行 */
flex-wrap: wrap;</code></pre>
</li>
<li><p>文字跑板問題</p>
</li>
</ol>
<ul>
<li><code>word-break</code>：文字斷行效果</li>
</ul>
<p><code>word-break: break-all;</code>：遇到邊界就換行</p>
<ul>
<li><code>white-space</code>：如何處理元素內的空白</li>
</ul>
<p><code>white-space: pre-line;</code>：自動合併多個空白，但保留換行符號</p>
]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>Front-End</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 3] 設定 ESLint：用來檢查語法的工具</title>
    <url>/eslint/</url>
    <content><![CDATA[<h2 id="什麼是-ESLint？"><a href="#什麼是-ESLint？" class="headerlink" title="什麼是 ESLint？"></a>什麼是 ESLint？</h2><p>ESLint（ECMAScript + lint）是用來檢查 JavaScript 程式碼的工具。可在 commit 前檢查語法錯誤、提示潛在的 bug，藉此有效提高程式碼質量，和統一基本的 coding style。</p>
<blockquote>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9sYXJyeWx1LmJsb2cvaW1wcm92ZS1jb2RlLXF1YWxpdHktdXNpbmctZXNsaW50LTc0MmNmMWYzODRmMQ==">[JS] 使用 ESLint 提高程式碼品質<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlcnR3LmNvbS8lRTclQTglOEIlRTUlQkMlOEYlRTglQUElOUUlRTglQTglODAvNjkzMzcwLw==">深入淺出eslint——關於我學習eslint的心得<i class="fa fa-external-link-alt"></i></span></li>
</ol>
</blockquote>
<a id="more"></a>
<h3 id="如何安裝"><a href="#如何安裝" class="headerlink" title="如何安裝"></a>如何安裝</h3><p>要在 Node.js 上運行 ESLint，必須安裝 npm，接著運行下列程式碼：</p>
<h4 id="npm-install-g-eslint-：安裝-eslint-套件"><a href="#npm-install-g-eslint-：安裝-eslint-套件" class="headerlink" title="npm install -g eslint ：安裝 eslint 套件"></a><code>npm install -g eslint </code>：安裝 eslint 套件</h4><p>在 package.json &gt; scripts &gt; lint，可查看 eslint 的檢查範圍：</p>
<pre><code class="js">// 代表 homeworks 底下所有的 js 檔案都要經過 eslint 的規則檢查
&#123;
    &quot;scripts&quot;: &#123;
        &quot;lint&quot;: &quot;eslint ./homeworks/**/*.js&quot;
    &#125;
&#125;</code></pre>
<ul>
<li>若程式碼均符合規則，即可順利 commit：</li>
</ul>
<p><img src="https://i.imgur.com/c9Nv0Gh.png"></p>
<ul>
<li>若有不符合規則的程式碼，則會出現下列訊息，告知幾行幾欄出現 error 需進行修正，通過才可進行 commit：</li>
</ul>
<p><img src="https://i.imgur.com/FLkbnqX.png"></p>
<hr>
<h2 id="如何忽略檢查語法"><a href="#如何忽略檢查語法" class="headerlink" title="如何忽略檢查語法"></a>如何忽略檢查語法</h2><p>若想忽略規則，可在檔案中加入 <code>eslint-disable</code> 指令。</p>
<h3 id="忽略所有規則"><a href="#忽略所有規則" class="headerlink" title="忽略所有規則"></a>忽略所有規則</h3><p>放在檔案開頭：</p>
<pre><code>/* eslint-disable */                    // 在該檔案關閉 ESLint</code></pre>
<h3 id="忽略特定規則"><a href="#忽略特定規則" class="headerlink" title="忽略特定規則"></a>忽略特定規則</h3><pre><code>/* eslint no-unused-vars: 0 */            // off 或 0 代表關閉規則</code></pre>
<h3 id="忽略單行"><a href="#忽略單行" class="headerlink" title="忽略單行"></a>忽略單行</h3><p>忽略所有規則。可分為「忽略同一行」或「忽略下一行」兩種寫法。</p>
<pre><code>var a = 10;   // eslint-disable-line

// eslint-disable-next-line
var result = &#39;&#39;;</code></pre>
<p>忽略特定規則。直接在指令後面加「想要忽略的規則名稱」。</p>
<pre><code>alert(&#39;Hello&#39;);       // eslint-disable-line no-alert

// eslint-disable-next-line no-alert
alert(&#39;Hello&#39;);</code></pre>
<hr>
<h2 id="eslint-報錯例子"><a href="#eslint-報錯例子" class="headerlink" title="eslint 報錯例子"></a>eslint 報錯例子</h2><h3 id="1-換行符問題"><a href="#1-換行符問題" class="headerlink" title="1. 換行符問題"></a>1. 換行符問題</h3><p><code>Expected linebreaks to be &#39;LF&#39; but found &#39;CRLF&#39; </code></p>
<p>原因：不同系統不同工具下換行符的問題。</p>
<p>解決方法：如果是 windows 系統，點擊vscode右下角，將默認 CRLF 改為 LF。</p>
<blockquote>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudHdibG9ncy5uZXQvYS81YmIwMjA0YzJiNzE3Nzc4MWEwZmMwMzg=">項目中 eslint 報錯： Expected linebreaks to be ‘LF’ but found ‘CRLF’<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM0Mjk3NS9hcnRpY2xlL2RldGFpbHMvODE0ODYzNzM=">VUE項目中eslint報錯： Expected linebreaks to be ‘LF’ but found ‘CRLF’<i class="fa fa-external-link-alt"></i></span></li>
</ol>
</blockquote>
<h3 id="2-宣告變數需使用-const-或-let"><a href="#2-宣告變數需使用-const-或-let" class="headerlink" title="2. 宣告變數需使用 const 或 let"></a>2. 宣告變數需使用 const 或 let</h3><p><code>&#39;arr&#39; is never reassigned. Use &#39;const&#39; instead       prefer-const</code></p>
<p>原因：eslint 會嚴格的抓 const 跟 let 的使用，而不是用 var 宣告變數。</p>
<p>解決方法：沒有重新賦值過的變數都要用 const 宣告，其餘則是let。</p>
<ul>
<li>const（常數）：代表不變的數值。宣告時就要同時賦值，且不能再更動。</li>
<li>let：和 var 作用差不多，但 let 所宣告的變數，只在代碼塊區域內有效。也就是說，被所屬 <code>&#123; &#125;</code> 包起來的 let 變數，不會被外面（全域）影響。</li>
</ul>
<p>舉個例子：</p>
<pre><code>let price = 20;          // 全域變數
if (true) &#123;              
  let price = 30;        // 區域變數
&#125;
console.log(price)      // 印出 20，因為區域變數不會覆蓋全域變數</code></pre>
<blockquote>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIxMzE4OA==">Day02【ES6 小筆記】變數宣告 - let、const 哪裡好？跟 var 說掰掰<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h4 id="3-縮排問題"><a href="#3-縮排問題" class="headerlink" title="3. 縮排問題"></a>3. 縮排問題</h4><p>原因：開頭必須使用 2 個空白來設定縮排，但 VSCode 預設是 4 個空白。</p>
<p>解決方法：</p>
<ol>
<li>點選狀態列上的 [空白:4] </li>
<li>選擇 [使用空格鍵進行縮排]</li>
<li>選擇定位點長度 2 </li>
<li>即可修改成 2 個空白設定縮排</li>
</ol>
<blockquote>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0B5dWppZXdhbmcvcmFpbHMtdmlzdWFsLXN0dWRpby1jb2RlLSVFNCVCRiVBRSVFNiU5NCVCOS10YWIlRTglQTglQUQlRTUlQUUlOUEtNzRiMGZjNzQ4ZjI4">[Rails] Visual Studio Code 修改 Tab設定<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 12] 前端工具之一 - jQuery 與 Bootstrap</title>
    <url>/fe201-jquery-bootstrap/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUyMDE=">[FE201] 前端中階：那些前端會用到的工具們<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用新工具之前，大致會依照下列步驟：</p>
<ol>
<li>安裝工具</li>
<li>閱讀官方文件</li>
<li>更改設定檔<a id="more"></a>
</li>
</ol>
<hr>
<h2 id="jQuery：JS-函式庫"><a href="#jQuery：JS-函式庫" class="headerlink" title="jQuery：JS 函式庫"></a>jQuery：JS 函式庫</h2><p><img src="https://i.imgur.com/KKhdOms.png"></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9qcXVlcnkuY29tLw==">jQuery<i class="fa fa-external-link-alt"></i></span> 是一個 JavaScript 函式庫（Javascipt Framework），是幫助加速網頁程式開發的工具。可解決跨瀏覽器的問題，能夠快速又方面操作 DOM，縮短開發時間與簡化程式碼。</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>和引入 JavaScript 方法類似：</p>
<pre><code class="javascript=">&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;</code></pre>
<h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><p>使用 jQuery 的基本語法如下，意即指派元素到指定的事件：</p>
<pre><code class="javascript=">// 選取 `$(selector)` 元素，並指派它進行 `.action()` 事件
$(selector).action()

// 範例
$( &quot;button.continue&quot; ).html( &quot;Next Step...&quot; )</code></pre>
<p>其中的 <code>$()</code> 符號就是 jQuery 常用的選擇器，善用選擇器可以快速找到網頁當中的物件。</p>
<p>以按鈕 Button 的點擊事件為例：</p>
<h4 id="JavaScript-原生語法"><a href="#JavaScript-原生語法" class="headerlink" title="JavaScript 原生語法"></a>JavaScript 原生語法</h4><pre><code class="javascript">// 使用 DOMContentLoaded 或 load 事件，可確保 DOM 結構被完整的讀取跟解析
document.addEventListener(&#39;DOMContentLoaded&#39;, function () &#123;
  document.querySelector(&#39;.btn&#39;).addEventListener(&#39;click&#39;, function() &#123;
    alert(&#39;click!&#39;)
  &#125;)
&#125;)</code></pre>
<p>兩者結構其實非常類似，多數情況下 JavaScript 和 jQuery 的語法兩者也能夠混用。</p>
<h4 id="使用-jQuery"><a href="#使用-jQuery" class="headerlink" title="使用 jQuery"></a>使用 jQuery</h4><pre><code class="javascript=">// jQuery === $
$(document).ready (function() &#123;
  $(&#39;.btn&#39;).click(function(e) &#123;
    alert(&#39;click jq!&#39;)
  &#125;)
&#125;)</code></pre>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2FpemhlbmJvL3AvNjY3OTQ3OC5odG1s">DOMContentLoaded與load的區別<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9sb2FkLWV2ZW50LyNsb2FkMQ==">jQuery Core API Documentation<i class="fa fa-external-link-alt"></i></span>：用來查閱官方說明文件</li>
<li><span class="exturl" data-url="aHR0cDovL3lvdW1pZ2h0bm90bmVlZGpxdWVyeS5jb20v">You might not need jQuery<i class="fa fa-external-link-alt"></i></span>：可對照 jQuery 和 JavaScript 的寫法</li>
</ul>
<h3 id="相關語法"><a href="#相關語法" class="headerlink" title="相關語法"></a>相關語法</h3><h4 id="淡入淡出效果"><a href="#淡入淡出效果" class="headerlink" title="淡入淡出效果"></a>淡入淡出效果</h4><pre><code class="javascript=">&lt;style&gt;
  .box &#123;
    height: 200px;
    width: 200px;
    background: brown;
  &#125;
&lt;/style&gt;
&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  var isHide = false
  $(document).ready (function() &#123;
    $(&#39;.btn&#39;).click(function(e) &#123;
      if (isHide) &#123;
        $(&#39;.box&#39;).fadeIn(500)    // show()
      &#125; else &#123;
        $(&#39;.box&#39;).fadeOut(500)   // hide()
      &#125;
      isHide = !isHide
    &#125;)
  &#125;)
  &lt;/script&gt;
&lt;body&gt;
  &lt;button class=&quot;btn&quot;&gt;I am a button&lt;/button&gt;
  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/body&gt;</code></pre>
<h4 id="簡易-todo-list"><a href="#簡易-todo-list" class="headerlink" title="簡易 todo list"></a>簡易 todo list</h4><p>首先建立點擊事件，來拿取 input 欄位輸入的值：</p>
<pre><code class="javascript=">&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
$(document).ready (function() &#123;
  $(&#39;.btn&#39;).click(function(e) &#123;
    console.log($(&#39;.todo-input&#39;).val()) // 測試是否讀取成功
  &#125;)
&#125;)
&lt;/script&gt;
&lt;body&gt;
  &lt;input class=&quot;todo-input&quot; /&gt;
  &lt;button class=&quot;btn&quot;&gt;Add todo&lt;/button&gt;
  &lt;div class=&quot;todos&quot;&gt;&lt;/div&gt;
&lt;/body&gt;</code></pre>
<p>再來加入新增 todo 到 todos 的功能：</p>
<ul>
<li><code>prepend()</code>：新增元素到最上面</li>
<li><code>append()</code>：新增元素到最下面</li>
</ul>
<pre><code class="javascript=">&lt;style&gt;
  .todo &#123;
    padding: 10px;
    border: 1px solid #eee;
  &#125;
&lt;/style&gt;
&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  $(document).ready (function() &#123;
    $(&#39;.btn&#39;).click(function(e) &#123;             // 建立點擊事件
      const value = $(&#39;.todo-input&#39;).val()    // 拿取 value 值
      $(&#39;.todo-input&#39;).val(&#39;&#39;)                // 讀取完後清空 input 欄位
      $(&#39;.todos&#39;).prepend(`&lt;div class=&quot;todo&quot;&gt;$&#123;value&#125;&lt;/div&gt;`)    // 把該元素新增到 todos
    &#125;)
  &#125;)
&lt;/script&gt;
&lt;body&gt;
  &lt;input class=&quot;todo-input&quot; /&gt;
  &lt;button class=&quot;btn&quot;&gt;Add todo&lt;/button&gt;
  &lt;div class=&quot;todos&quot;&gt;&lt;/div&gt;</code></pre>
<h4 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h4><pre><code class="javascript=">$.ajax(&#123;
  type: &quot;GET&quot;, // 指定 method
  url: &#39;ajax/test.html&#39;,
  success: function(data) &#123;
  $(&#39;.result&#39;).html(data);
  alert(&#39;Load was performed.&#39;);
  &#125;
&#125;);

// 取得 HTML: load()
$(&quot;#htmDoc&quot;).load(&quot;test.html&quot;);

// 取得 JSON 格式的資料: getJSON()
$.getJSON(&quot;test.json&quot;, function(data)&#123;  
  for (var idx in data)  
    $(&quot;#menu&quot;).append(&quot;&lt;li&gt;&quot; + data[idx] + &quot;&lt;/li&gt;&quot;); 
&#125;);  

// document ready 事件
$(document).ready(function() &#123;  
  alert(&#39;Hello&#39;);    // 網頁下載完成後立即執行 alert()
&#125;);
</code></pre>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdzMxMC5naXRodWIuaW8vMjAyMC8wMS8xNi9qUXVlcnktYmFzZS8jJUU0JUJEJUJGJUU3JTk0JUE4LWpRdWVyeQ==">jQuery 簡單介紹<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDA5MjU5Mg==">JQuery 筆記 (一) – 淺談 JQuery<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="Bootstrap：UI-Library"><a href="#Bootstrap：UI-Library" class="headerlink" title="Bootstrap：UI Library"></a>Bootstrap：UI Library</h2><p><span class="exturl" data-url="aHR0cHM6Ly9nZXRib290c3RyYXAuY29tLw==">Bootstrap<i class="fa fa-external-link-alt"></i></span> 是一個由 HTML、CSS 和 JavaScript 寫成的前端框架，內建多項模組化的版型與元件樣式。例如：字體排印、表單、按鈕、導航及其他各種元件及 Javascript 擴充套件。主要用於創建網站和 Web 應用程式，能幫助快速開發響應式網頁。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90dy5hbHBoYWNhbXAuY28vYmxvZy9ib290c3RyYXAtNC1pbnRyb2R1Y3Rpb24=">Bootstrap 是什麼？給網頁設計新手的 Bootstrap 4入門教學<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib290c3dhdGNoLmNvbS8=">Bootswatch<i class="fa fa-external-link-alt"></i></span>：提供各種經過調整顏色的 Bootstrap 版本，可以套用在已有的 Bootstrap 網站上</li>
</ul>
]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>Front-End</tag>
        <tag>jQuery</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 13] Fetch &amp; Promise 補充</title>
    <url>/fetch-promise/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 Limedy「Fetch 與 Promise 補充系列」課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<p>以下內容將涵蓋：</p>
<ol>
<li>如何發出 HTTP 請求</li>
<li>回顧 XMLHttpRequest</li>
<li>如何使用 Fetch</li>
<li>什麼是 Promise<a id="more"></a>
</li>
</ol>
<hr>
<h2 id="如何發出-HTTP-請求"><a href="#如何發出-HTTP-請求" class="headerlink" title="如何發出 HTTP 請求"></a>如何發出 HTTP 請求</h2><p>想要在前端網頁發出 Ajax Request，可以有下列兩種方式：</p>
<ol>
<li>XMLHttpRequest</li>
<li>Fetch</li>
</ol>
<h2 id="回顧-XMLHttpRequest"><a href="#回顧-XMLHttpRequest" class="headerlink" title="回顧 XMLHttpRequest"></a>回顧 XMLHttpRequest</h2><p><a href="(https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest)">XMLHttpRequest</a>，簡稱 XHR。在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMC9UaGlzLWlzLUNvZGVkaWFyeS9ibG9iL21hc3Rlci93ZWVrOF8lRTUlODIlQjMlRTklODAlODElRTglQjMlODclRTYlOTYlOTklRTclOUElODQlRTYlOTYlQjklRTUlQkMlOEYlRTMlODAlODElRTclODAlOEYlRTglQTYlQkQlRTUlOTklQTglRTclOUElODQlRTklOTklOTAlRTUlODglQjYubWQ=">課程第八週<i class="fa fa-external-link-alt"></i></span>時曾提到，我們可利用 XMLHttpRequest 物件來實現非同步請求，以下列程式碼為例：</p>
<pre><code class="javascript=">function reqListener () &#123;
 if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123;
  console.log(request.responseText)
 &#125; else &#123;
  console.log(&quot;err&quot;)
&#125;

const request = new XMLHttpRequest();
request.addEventListener(&quot;load&quot;, reqListener);

// 加載失敗會回傳 error
request.onerror = function () &#123;
  console.log(&#39;error&#39;);
&#125;;

request.open(&quot;GET&quot;, &quot;http://www.example.org/example.txt&quot;, true);
request.send();</code></pre>
<ol>
<li>建立一個 XMLHttpRequest 物件：request</li>
<li>開啟一個 URL <code>.open()</code><ul>
<li>設定三個參數：請求方法﹑請求的 URL、是否非同步傳送請求</li>
</ul>
</li>
<li>掛載 load callback：加載完成時會呼叫 reqListener 函式</li>
<li>發起一個請求 <code>.send()</code></li>
</ol>
<p>如果利用 Fetch 來達到相同結果，程式碼如下：</p>
<pre><code class="javascript=">fetch(&quot;http://www.example.org/example.txt&quot;)
 .then(res=&gt;res.text())
 .then(console.log)</code></pre>
<p>若不指定方法，Fetch 預設方法是使用 GET，與前者相比可發現程式碼簡潔許多。</p>
<h2 id="初探-Fetch"><a href="#初探-Fetch" class="headerlink" title="初探 Fetch"></a>初探 Fetch</h2><p>要進行 API 串接，發出 GET Request，可利用這個網站：<span class="exturl" data-url="aHR0cHM6Ly9kZXNpZ25lci5tb2NreS5pby8=">Mocky: The world easiest &amp; fastest tool to mock your APIs<i class="fa fa-external-link-alt"></i></span>，能夠自行創造 Response 並指定內容。</p>
<h3 id="如何發出-Request"><a href="#如何發出-Request" class="headerlink" title="如何發出 Request"></a>如何發出 Request</h3><p>在 index.html 加上 <code>fetch(&#39;請求的 URL&#39;)</code> 即可發出最簡單的 Resquest：</p>
<pre><code class="javascript=">&lt;script&gt;
  fetch(&#39;https://run.mocky.io/v3/d49195d4-9e5b-4b63-8b13-6f97e46eb605&#39;)
&lt;/script&gt;</code></pre>
<p>使用開發者工具查看 Network，確實有收到 Response：</p>
<p><img src="https://i.imgur.com/eOZlngN.png"></p>
<p>或是直接將結果印出來，可知 fetch 其實會回傳一個 Promise：</p>
<pre><code class="javascript=">&lt;script&gt;
  const result = fetch(&#39;https://run.mocky.io/v3/d49195d4-9e5b-4b63-8b13-6f97e46eb605&#39;);
  console.log(result)
&lt;/script&gt;</code></pre>
<p><img src="https://i.imgur.com/QtvlDpl.png"></p>
<hr>
<h2 id="什麼是-Promise"><a href="#什麼是-Promise" class="headerlink" title="什麼是 Promise"></a>什麼是 Promise</h2><p>Promist 是一個獨特的物件，簡單來說就是一個容器，裡面儲存著某個未來才會結束的事件（也就是非同步操作）的結果。</p>
<h3 id="then-：拿取-Promise-Response"><a href="#then-：拿取-Promise-Response" class="headerlink" title="then()：拿取 Promise Response"></a><code>then()</code>：拿取 Promise Response</h3><p>那麼該如何拿到 Promise 結果呢？我們可利用 <code>.then()</code> 來拿到 Response，如下列程式碼：</p>
<pre><code class="javascript=">&lt;script&gt;
  function pringResult(response) &#123;
    console.log(response)
  &#125;
  const result = fetch(&#39;https://run.mocky.io/v3/d49195d4-9e5b-4b63-8b13-6f97e46eb605&#39;);
  result.then(pringResult)
&lt;/script&gt;</code></pre>
<p><img src="https://i.imgur.com/d88g2Ox.png"></p>
<p>可把上述程式碼簡化如下：</p>
<pre><code class="javascript=">fetch(&#39;https://run.mocky.io/v3/d49195d4-9e5b-4b63-8b13-6f97e46eb605&#39;)
  .then( response =&gt; &#123;
    console.log(response)
  &#125;)</code></pre>
<h3 id="text-amp-json-：處理-Response-Body"><a href="#text-amp-json-：處理-Response-Body" class="headerlink" title=".text() &amp; .json()：處理 Response Body"></a><code>.text()</code> &amp; <code>.json()</code>：處理 Response Body</h3><h4 id="text"><a href="#text" class="headerlink" title=".text()"></a><code>.text()</code></h4><p>利用 <code>.text()</code> 我們會同樣會得到一個 Promise，再以 <code>.then()</code> 處理，可讀取 Response 的 body：</p>
<pre><code class="javascript=">const api200 = &#39;https://run.mocky.io/v3/d49195d4-9e5b-4b63-8b13-6f97e46eb605&#39;

fetch(api200)
  .then(response =&gt; &#123;
    response.text().then(text =&gt; &#123;
      console.log(text)
    &#125;)
  &#125;)</code></pre>
<p>確認可在瀏覽器上印出 text 內容：</p>
<p><img src="https://i.imgur.com/rqFF0In.png"></p>
<h4 id="jaon"><a href="#jaon" class="headerlink" title=".jaon()"></a><code>.jaon()</code></h4><p>若確定 Response 是 JSON 格式，可使用 <code>.json()</code> 以相同寫法來處理，回傳的結果會如同 <code>JSON.parse()</code> 幫我們轉成 json 格式：</p>
<pre><code class="javascript=">const api200 = &#39;https://run.mocky.io/v3/d49195d4-9e5b-4b63-8b13-6f97e46eb605&#39;

fetch(api200)
  .then(response =&gt; &#123;
    response.json().then(json =&gt; &#123;
      console.log(json)
    &#125;)
  &#125;)</code></pre>
<p>確認得到 JSON 格式的結果：</p>
<p><img src="https://i.imgur.com/3ZOk7YA.png"></p>
<h3 id="簡化再簡化"><a href="#簡化再簡化" class="headerlink" title="簡化再簡化"></a>簡化再簡化</h3><p>由於 <code>response.json()</code> 這個 Promise 的回傳值是 text，我們可將程式碼簡化如下：</p>
<pre><code class="javascript=">fetch(api200)
  .then(response =&gt; &#123;
    return response.json()  // 回傳值
  &#125;).then(json =&gt; &#123;         // then() 會將回傳值帶到 Response
    console.log(json)       // 取到回傳值
  &#125;)</code></pre>
<p>若使用 return 的寫法，可減少縮排層數，簡化程式碼的複雜程度。</p>
<h3 id="Chaining-特性"><a href="#Chaining-特性" class="headerlink" title="Chaining 特性"></a>Chaining 特性</h3><p>上述的寫法，其實是利用 Promise 具有的 Chaining 特性。</p>
<p>由於 <code>.then()</code> 裡面回傳的還是一個 promise 物件，我們可以一直使用 <code>.then()</code> 來對回傳的 promise 做處理。</p>
<pre><code class="javascript=">fetch() ⇒ Promise
response.text() ⇒ Promise
response.json() ⇒ Promise
respose.json.then() ⇒ Promise</code></pre>
<p>透過這個特性，我們能夠有效減少層數，以第八週串接 twitch API 為例：</p>
<ul>
<li>Callback function</li>
</ul>
<pre><code class="javascript=">getGames(()=&gt;&#123;
  getStreams(()=&gt;&#123;
    getChannel(()=&gt;&#123;
      getTitle(()=&gt;&#123;
          ...
      &#125;)
    &#125;)
  &#125;)
&#125;)</code></pre>
<ul>
<li>Promise</li>
</ul>
<pre><code class="javascript=">getGames(() =&gt; &#123;
  return getStreams();
&#125;).then((streams) =&gt; &#123;
  return getChannel();
&#125;).then((channel) =&gt; &#123;
  return getTitle();
&#125;);</code></pre>
<hr>
<h2 id="如何處理-Error"><a href="#如何處理-Error" class="headerlink" title="如何處理 Error"></a>如何處理 Error</h2><p>這裡指的錯誤，並非 http status 400、500 那種錯誤，而是根本無法拿到 Response，Fetch 才會回傳錯誤訊息。</p>
<p>在過去課程中，以同步方式傳送請求，可使用 <code>try / catch</code> 來處理錯誤訊息：</p>
<pre><code class="javascript=">try &#123;
  // 正常執行..
&#125; catch(e) &#123;
  // 出錯執行..
&#125;</code></pre>
<p>但這個錯誤處理無法應用在 callback function，因為 Fetch 使用非同步方式發出請求。</p>
<h3 id="catch-：處理錯誤訊息"><a href="#catch-：處理錯誤訊息" class="headerlink" title=".catch()：處理錯誤訊息"></a><code>.catch()</code>：處理錯誤訊息</h3><p>程式碼範例如下：</p>
<pre><code class="javascript=">fetch(api200)
  .then(response =&gt; &#123;
    return response.json()
  &#125;).then(json =&gt; &#123;
    console.log(json)
  &#125;).catch(err =&gt; &#123;
    console.log(&#39;error&#39;, err)
  &#125;)</code></pre>
<p>再把原先的請求 URL 稍作修改，確認可接收錯誤訊息：</p>
<p><img src="https://i.imgur.com/qN3HBCE.png"></p>
<p>簡言之，我們可使用 <code>then()</code> 來接收回傳的結果，<code>catch()</code> 來接收回傳的錯誤。</p>
<h2 id="利用-Fetch-發-POST"><a href="#利用-Fetch-發-POST" class="headerlink" title="利用 Fetch 發 POST"></a>利用 Fetch 發 POST</h2><p>前面提到過，Fetch 預設方法是使用 GET，若要發出 POST Request，需帶入其他參數，以下列程式碼為例：</p>
<pre><code class="javascript=">const data = &#123;
  name: &#39;heidi&#39;
&#125;
fetch(api200, &#123;
  method: &#39;POST&#39;,
  body: JSON.stringify(data),
  headers: new Headers(&#123;
    &#39;Content-Type&#39;: &#39;application/json&#39;
  &#125;)
&#125;)
  .then(response =&gt; &#123;
    return response.json()
  &#125;).then(json =&gt; &#123;
    console.log(json)
  &#125;).catch(err =&gt; &#123;
    console.log(&#39;error&#39;, err)
  &#125;)</code></pre>
<h3 id="Fetch-使用時的注意事項"><a href="#Fetch-使用時的注意事項" class="headerlink" title="Fetch 使用時的注意事項"></a>Fetch 使用時的注意事項</h3><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><ul>
<li>決定 server 如何處理 Request</li>
<li>根據不同的 Content-Type，需修改 body 如何解析接收到的資料格式</li>
</ul>
<h4 id="credential"><a href="#credential" class="headerlink" title="credential"></a>credential</h4><p>發 request 給不同來源 domain 的 API 時，並不會自動把 cookie 帶上去，需加上 <code>credentials: &#39;includes&#39;</code>，如下列程式碼：</p>
<pre><code class="javascript=">const data = &#123;
  name: &#39;heidi&#39;
&#125;
fetch(api200, &#123;
  method: &#39;POST&#39;,
  body: JSON.stringify(data),
  credentials: &#39;includes&#39;,
  headers: new Headers(&#123;
    &#39;Content-Type&#39;: &#39;application/json&#39;
  &#125;)
&#125;)
  .then(response =&gt; &#123;
    return response.json()
  &#125;).then(json =&gt; &#123;
    console.log(json)
  &#125;).catch(err =&gt; &#123;
    console.log(&#39;error&#39;, err)
  &#125;)</code></pre>
<h4 id="對-mode-的誤解"><a href="#對-mode-的誤解" class="headerlink" title="對 mode 的誤解"></a>對 mode 的誤解</h4><ul>
<li><code>mode: &#39;no-cors&#39;</code> 並不能突破 CORS 限制，而是會回傳一個空的 response</li>
<li>這條指令只是跟瀏覽器說：「我沒有要拿 response，不用傳錯誤訊息給我」</li>
<li>要在瀏覽器解決 CORS 限制，必須在 Server 端加上開 CORS 的 header</li>
</ul>
<hr>
<h2 id="建立-Promise-物件"><a href="#建立-Promise-物件" class="headerlink" title="建立 Promise 物件"></a>建立 Promise 物件</h2><p>根據上述結論，要處理非同步，我們可利用 callback function 或 Promise。</p>
<p>以下程式碼示範如何建立 Promise 物件，也就是把一個 Promise 物件 new 出來：</p>
<pre><code class="javascript=">function init(resolve, reject) &#123;
  resolve(3)
&#125;
const myPromise = new Promise(init)

myPromise.then((data) =&gt; &#123;
    console.log(&#39;data&#39;, data)       // 正確
  &#125;).catch(err =&gt; &#123;
    console.log(&#39;err&#39;, err)         // 錯誤
  &#125;)

// 印出 data 3</code></pre>
<p>簡化 function 如下：</p>
<pre><code class="javascript=">const myPromise = new Promise((resolve, reject) =&gt; &#123;
  resolve(3)
&#125;)

myPromise.then((data) =&gt; &#123;
    console.log(&#39;data&#39;, data)       // 正確
  &#125;).catch(err =&gt; &#123;
    console.log(&#39;err&#39;, err)         // 錯誤
  &#125;)</code></pre>
<h3 id="應用範例"><a href="#應用範例" class="headerlink" title="應用範例"></a>應用範例</h3><p>透過 <code>setTimeout()</code> 結合 promise 應用：</p>
<pre><code class="javascript=">const myPromise = new Promise((resolve) =&gt; &#123;
  setTimeout(resolve, 3000)         // 3 秒後呼叫 resolve()
&#125;)

myPromise.then((data) =&gt; &#123;
  console.log(&#39;myPromise data&#39;, data)
&#125;).catch(err =&gt; &#123;
  console.log(&#39;err&#39;, err)
&#125;)

// 經過 3 秒後會印出 myPromise Data undefined</code></pre>
<p>再來利用 <code>function sleep()</code> 宣告一個叫做 myPromise 的 Promise 再回傳回去。如下列程式碼：</p>
<pre><code class="javascript=">function sleep(ms) &#123;
  const myPromise = new Promise(resolve =&gt; &#123;
    setTimeout(resolve, ms)      // 把秒數設為參數
  &#125;)
  return myPromise;
&#125;

sleep(1500).then((data) =&gt; &#123;      // 執行完 sleep() 會得到 Promise
  console.log(&#39;myPromise Data&#39;, data);
&#125;)
  .catch(err =&gt; &#123;
    console.log(&#39;err&#39;, err);
  &#125;)</code></pre>
<p>上述的 <code>sleep()</code> 函式可簡化成：</p>
<pre><code class="javascript=">function sleep(ms) &#123;
  return new Promise(resolve =&gt; &#123;
    setTimeout(resolve, ms)
  &#125;)
&#125;</code></pre>
<p>若以箭頭函式表達則是：</p>
<pre><code class="javascript=">const sleep = ms =&gt; &#123;
  return new Promise(resolve =&gt; &#123;
    setTimeout(resolve, ms)
  &#125;)
&#125;</code></pre>
<p>還可以簡化成這樣，省略 return 的大括號：</p>
<pre><code class="javascript=">const sleep = ms =&gt; new Promise(resolve =&gt; &#123;
    setTimeout(resolve, ms)
  &#125;)</code></pre>
<p>最終可簡化成一行：</p>
<pre><code class="javascript=">const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))</code></pre>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h2><p>利用 <code>async / await</code> 可以用看起來像同步的語法，做到非同步的事情。</p>
<p>方法是用 async 宣告一個非同步的 function，裡面放 await 接一個 Promise 物件，會等到執行完 await 裡面的 promise 才往下執行。</p>
<p>以下列程式碼為例：</p>
<pre><code class="javascript=">const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))

async function main() &#123;
  console.log(&#39;enter main&#39;);
  await sleep(1000);        // 接一個 Promise
  console.log(&#39;exit main&#39;);
&#125;

main();
// 執行 main() 會發現兩個 console.log 會相隔一秒印出</code></pre>
<p>對照使用 Promise 的寫法：</p>
<pre><code class="javascript=">const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))

function mainPromise() &#123;
  console.log(&#39;enter main&#39;);
  sleep(1000).then(() =&gt; &#123;
    console.log(&#39;exit main&#39;);
  &#125;)
&#125;</code></pre>
<h4 id="應用練習"><a href="#應用練習" class="headerlink" title="應用練習"></a>應用練習</h4><pre><code class="javascript=">const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))

function getData() &#123;
  const api200 = &#39;https://run.mocky.io/v3/d49195d4-9e5b-4b63-8b13-6f97e46eb605&#39;
  return fetch(api200)      // 回傳執行完的結果 =&gt; Promise
    .then(response =&gt; &#123;
      return response.json()
    &#125;)
&#125;

async function main() &#123;
  console.log(&#39;enter main&#39;);
  await sleep(1000);              // 等 1 秒
  const result = await getData();    // 接收到結果才會繼續執行
  console.log(&#39;result&#39;, result);
&#125;

main();</code></pre>
<p>甚至可使用同步方式的 <code>try / catch</code> 來處理錯誤訊息：</p>
<pre><code class="javascript=">async function main() &#123;
  console.log(&#39;enter main&#39;);
  await sleep(1000);              // 等 1 秒
  try &#123;
    const result = await getData();
    console.log(&#39;result&#39;, result);
  &#125; catch(err) &#123;
    console.log(&#39;err&#39;, err);
  &#125;
&#125;</code></pre>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRyZWFkMDEuY29tL2NvbnRlbnQvMTU3MDYwNjMyMy5odG1s">ES6入門之Promise物件<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9uaWNvbGFrYWNoYS5jb2RlcmJyaWRnZS5pby8yMDIwLzA5LzExL3N5bmMtYXN5bmMv">JavaScript 的同步與非同步 - 從 Callback function 到 Promise<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>Back-End</tag>
        <tag>fetch</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 1] 版本控制 - Git 進階指令 &amp; GitHub</title>
    <url>/git-github/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZ2l0MTAx">[GIT101] Git 超新手入門<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。</p>
</blockquote>
<p>在上一節我們學到 <span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWdpdA==">Git 基本指令<i class="fa fa-external-link-alt"></i></span>，接下來要學習什麼是 Branch（分支），以及如何送出的 Pull Request 進行共同開發，以及介紹提供視覺化介面操作 Git 的 GitHub。</p>
<pre><code>學習目標：

 知道怎麼使用 branch 並送出 Pull Request
 熟悉 Git Workflow（也就是交作業的流程）</code></pre>
<a id="more"></a>

<hr>
<h2 id="為什麼需要-Branch（分支）？"><a href="#為什麼需要-Branch（分支）？" class="headerlink" title="為什麼需要 Branch（分支）？"></a>為什麼需要 Branch（分支）？</h2><p> 簡言之，Branch 的作用就是讓開發過程各自獨立。</p>
<h3 id="例如：今天公司產品在開發新功能，途中發現有個嚴重的-bug-必須修正"><a href="#例如：今天公司產品在開發新功能，途中發現有個嚴重的-bug-必須修正" class="headerlink" title="例如：今天公司產品在開發新功能，途中發現有個嚴重的 bug 必須修正"></a>例如：今天公司產品在開發新功能，途中發現有個嚴重的 bug 必須修正</h3><h4 id="若以一條線的開發模式（如同上一節學的-Git-基本指令）："><a href="#若以一條線的開發模式（如同上一節學的-Git-基本指令）：" class="headerlink" title="若以一條線的開發模式（如同上一節學的 Git 基本指令）："></a>若以一條線的開發模式（<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWdpdA==">如同上一節學的 Git 基本指令<i class="fa fa-external-link-alt"></i></span>）：</h4><ol>
<li>在同一個 commit 上進行修改，容易產生衝突</li>
<li><code>穩定版 + bug fix</code> 還參雜未完成的新功能，也可能產生更多問題</li>
</ol>
<p><img src="https://i.imgur.com/MuDKdgK.png" alt="一條線開發"></p>
<h4 id="若能分成「穩定版本」和「新功能開發」，兩條分支就不會互相干擾："><a href="#若能分成「穩定版本」和「新功能開發」，兩條分支就不會互相干擾：" class="headerlink" title="若能分成「穩定版本」和「新功能開發」，兩條分支就不會互相干擾："></a>若能分成「穩定版本」和「新功能開發」，兩條分支就不會互相干擾：</h4><ol>
<li><code>穩定版 + 修好 bug</code> → 得到新的穩定版</li>
<li>待新功能開發完成，即可合併得到有新功能的版本，成為最新的穩定版</li>
</ol>
<p><img src="https://i.imgur.com/1S1hWYu.png" alt="兩條線開發"></p>
<hr>
<h2 id="操作-branch-基本指令"><a href="#操作-branch-基本指令" class="headerlink" title="操作 branch 基本指令"></a>操作 branch 基本指令</h2><p>使用 Git 進行版本控制時，系統最初會自動建立第一個 branch ，也就是 <code>master</code>。</p>
<p><img src="https://i.imgur.com/eDZEU1a.png" alt="預設分支為 master"></p>
<h3 id="git-branch-v：查看目前在哪個分支"><a href="#git-branch-v：查看目前在哪個分支" class="headerlink" title="git branch -v：查看目前在哪個分支"></a><code>git branch -v</code>：查看目前在哪個分支</h3><p>下列訊息分別表示：分支名稱、版本號、版本訊息。</p>
<p><img src="https://i.imgur.com/qbjckPW.png" alt="git branch -v 指令"></p>
<ul>
<li><code>git branch</code> ：如果後面沒接任何參數，只會顯示目前有哪些分支。</li>
</ul>
<h3 id="git-branch-lt-branchName-gt-：新增分支"><a href="#git-branch-lt-branchName-gt-：新增分支" class="headerlink" title="git branch &lt;branchName&gt;：新增分支"></a><code>git branch &lt;branchName&gt;</code>：新增分支</h3><blockquote>
<p>提醒：開發新功能之前，養成開新分支的好習慣！</p>
</blockquote>
<p><img src="https://i.imgur.com/r51pPLL.png" alt="git branch"></p>
<h3 id="git-branch-d-lt-branchName-gt-：刪除分支"><a href="#git-branch-d-lt-branchName-gt-：刪除分支" class="headerlink" title="git branch -d &lt;branchName&gt;：刪除分支"></a><code>git branch -d &lt;branchName&gt;</code>：刪除分支</h3><p><img src="https://i.imgur.com/OHjboYW.png" alt="git branch -d 指令"></p>
<h3 id="git-checkout-lt-branchName-gt-：切換分支"><a href="#git-checkout-lt-branchName-gt-：切換分支" class="headerlink" title="git checkout &lt;branchName&gt;：切換分支"></a><code>git checkout &lt;branchName&gt;</code>：切換分支</h3><p><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vT2hCQy14NVRSS1dGM001WlFESEJRUT9ib3RoI2dpdC1jaGVja291dA==">和上一節的切換版本指令<i class="fa fa-external-link-alt"></i></span>原理相同，這裡是將 <code>&lt;版本號碼&gt;</code> 換成 <code>&lt;分支名稱&gt;</code></p>
<ol>
<li><code>git checkout &lt;版本名稱&gt;</code>：切換版本</li>
<li><code>git checkout &lt;branchName&gt;</code>：切換分支</li>
<li><code>git branch checkout -b &lt;branchName&gt;</code>：「新增」並「切換」到該分支</li>
</ol>
<p><img src="https://i.imgur.com/oxKtRfm.png" alt="git checkout 指令"></p>
<h2 id="如何合併分支？"><a href="#如何合併分支？" class="headerlink" title="如何合併分支？"></a>如何合併分支？</h2><h3 id="git-merge-lt-branchName-gt-：把分支合併進來"><a href="#git-merge-lt-branchName-gt-：把分支合併進來" class="headerlink" title="git merge &lt;branchName&gt;：把分支合併進來"></a><code>git merge &lt;branchName&gt;</code>：把分支合併進來</h3><h4 id="範例：把分支-new-feature-合併到-master"><a href="#範例：把分支-new-feature-合併到-master" class="headerlink" title="範例：把分支 new-feature 合併到 master"></a>範例：把分支 <code>new-feature</code> 合併到 <code>master</code></h4><ol>
<li>輸入 <code>git checkout master</code> 切換到 <code>master</code> 這個分支</li>
<li>輸入 <code>git merge new-feature</code>，完成基本的分支合併<br>用 <code>git log</code> 查看版本紀錄，可知「合併」的過程會自動建立一個新版本</li>
</ol>
<p><img src="https://i.imgur.com/Mj5ABC7.png" alt="git merge 指令"></p>
<ol start="3">
<li>成功合併後，即可刪除分支 <code>new-feature</code></li>
</ol>
<p><img src="https://i.imgur.com/YZsSWZT.png" alt="合併後刪除分支"></p>
<h2 id="那在合併時發生-conflict（衝突）怎麼辦？"><a href="#那在合併時發生-conflict（衝突）怎麼辦？" class="headerlink" title="那在合併時發生 conflict（衝突）怎麼辦？"></a>那在合併時發生 conflict（衝突）怎麼辦？</h2><blockquote>
<p>所謂的衝突，就是「同一份檔案的兩個版本，裡面有一個或多個不同的內容」。</p>
</blockquote>
<p>但是 Git 無法幫你選擇哪一個當作最終版本，所以當發生衝突時，只能「自己手動調整」。</p>
<h4 id="範例：在-master-和-new-feature-這兩條支線上，均改了同一個檔案-code-js"><a href="#範例：在-master-和-new-feature-這兩條支線上，均改了同一個檔案-code-js" class="headerlink" title="範例：在 master 和 new-feature 這兩條支線上，均改了同一個檔案 code.js"></a>範例：在 <code>master</code> 和 <code>new-feature</code> 這兩條支線上，均改了同一個檔案 <code>code.js</code></h4><ol>
<li>此時若把分支 <code>new-feature</code> 合併到 <code>master</code> 上</li>
<li>顯示發生衝突，輸入 <code>git status</code> 可見提示說明：該檔案的兩個版本均有修改</li>
</ol>
<p><img src="https://i.imgur.com/G9ijEnc.png" alt="conflict"></p>
<ol start="3">
<li>進入該檔案會顯示衝突位置如下，需手動調整檔案內容</li>
</ol>
<p><img src="https://i.imgur.com/dGMmn2L.png" alt="conflict 手動調整"></p>
<p><img src="https://i.imgur.com/nCAxx1Q.png" alt="調整完成"></p>
<ol start="4">
<li>修改完後重新 commit，成功解決衝突</li>
</ol>
<p><img src="https://i.imgur.com/c3QKwyH.png" alt="conflict 解決"></p>
<hr>
<h2 id="如何共同開發專案？"><a href="#如何共同開發專案？" class="headerlink" title="如何共同開發專案？"></a>如何共同開發專案？</h2><p>熟悉 Git 的基本操作後，來談談最一開始提到的多人協作。這些被版本控制的專案，我們稱為「Repository（檔案庫）」，多人協作就是共享同一份 Repository 來完成共同開發。</p>
<h2 id="Git-vs-GitHub"><a href="#Git-vs-GitHub" class="headerlink" title="Git vs GitHub"></a>Git vs GitHub</h2><p>Git 是用來版本控制的程式。</p>
<p>GitHub 是目前全球最大的 Git Server，有許多開放原始碼的專案都是使用 Github 進行程式碼的管理。可以想成「提供存放使用 Git 專案倉庫（Repository) 的服務」。也可以不用 GitHub 選擇其他服務，或是自己架一個 Git Sever。</p>
<h3 id="GitHub：視覺化的-repository"><a href="#GitHub：視覺化的-repository" class="headerlink" title="GitHub：視覺化的 repository"></a>GitHub：視覺化的 repository</h3><p>透過 GitHub 的 GUI 介面能夠視覺化 repository，如此就可以在 repository 頁面查看該專案的 Commit 紀錄、檔案修改的歷史紀錄、修改者是誰等資訊，也可在 GitHub 執行 pull request 來進行合併。</p>
<h3 id="建立新專案"><a href="#建立新專案" class="headerlink" title="建立新專案"></a>建立新專案</h3><p><img src="https://i.imgur.com/pl31b7Q.png" alt="建立新專案"></p>
<h2 id="將本地端資料推上遠端-GitHub（Local→Remote）"><a href="#將本地端資料推上遠端-GitHub（Local→Remote）" class="headerlink" title="將本地端資料推上遠端 GitHub（Local→Remote）"></a>將本地端資料推上遠端 GitHub（Local→Remote）</h2><p>建立好新專案後，可分兩種方式開始專案：</p>
<ol>
<li>開始全新專案，再同步到 GitHub</li>
<li>已存在專案，將本地端的現存專案同步到 GitHub</li>
</ol>
<p><img src="https://i.imgur.com/Yc8mymH.png" alt="上傳本地專案到 GitHub"></p>
<h4 id="git-remote：主要是跟遠端有關的操作"><a href="#git-remote：主要是跟遠端有關的操作" class="headerlink" title="git remote：主要是跟遠端有關的操作"></a><code>git remote</code>：主要是跟遠端有關的操作</h4><ul>
<li><code>git remote add origin https://github.com/heidiliu2020/git101_test.git</code><br>代表加入遠端節點。也就是「為本地端檔案庫增加一個叫做 origin 的遠端檔案庫」。</li>
<li>這裡的 <code>origin</code> 是遠端檔案庫的代名詞，代表後面那串 GitHub 伺服器位置。如果從 Server 上 clone 下來，origin 是預設的遠端節點名稱。</li>
</ul>
<h4 id="git-push：把本地資料同步到遠端"><a href="#git-push：把本地資料同步到遠端" class="headerlink" title="git push：把本地資料同步到遠端"></a><code>git push</code>：把本地資料同步到遠端</h4><ul>
<li><code>git push -u origin &lt;branchName&gt; </code>：將本地端分支資料推到遠端分支</li>
<li><code>git push -u origin master</code>：將本地端檔案庫推到遠端檔案庫的 master 分支</li>
</ul>
<h2 id="將遠端資料拉回本地端（Remote→Local）"><a href="#將遠端資料拉回本地端（Remote→Local）" class="headerlink" title="將遠端資料拉回本地端（Remote→Local）"></a>將遠端資料拉回本地端（Remote→Local）</h2><h4 id="git-pull：把遠端資料同步到本地端"><a href="#git-pull：把遠端資料同步到本地端" class="headerlink" title="git pull：把遠端資料同步到本地端"></a><code>git pull</code>：把遠端資料同步到本地端</h4><ul>
<li><code>git pull origin &lt;branchName&gt;</code>：將遠端分支資料拉回並合併本地端分支</li>
</ul>
<h2 id="從-GitHub-Repository-複製專案"><a href="#從-GitHub-Repository-複製專案" class="headerlink" title="從 GitHub Repository 複製專案"></a>從 GitHub Repository 複製專案</h2><p>上面介紹的 Push 及 Pull 均使用於本地端現有的專案。</p>
<h3 id="git-clone：從-GitHub-下載-Repository-到本地端"><a href="#git-clone：從-GitHub-下載-Repository-到本地端" class="headerlink" title="git clone：從 GitHub 下載 Repository 到本地端"></a><code>git clone</code>：從 GitHub 下載 Repository 到本地端</h3><ol>
<li>在 GitHub 點選 <code>Clone or download</code>，可直接下載檔案</li>
</ol>
<p><img src="https://i.imgur.com/0yJIEim.png" alt="GitHub 點選 Clone"></p>
<ol start="2">
<li>或是複製網址，到 Terminal 輸入 <code>git clone &lt;網址&gt;</code>：可將內容下載到本地端</li>
</ol>
<p><img src="https://i.imgur.com/uiF2oX7.png" alt="git clone"></p>
<blockquote>
<p>但要注意使用 Clone 的 Repository 沒有權限修改，也就無法再 push 回遠端。</p>
</blockquote>
<h3 id="Fork：將別人的-Repository-複製一份成為自己的-Repository"><a href="#Fork：將別人的-Repository-複製一份成為自己的-Repository" class="headerlink" title="Fork：將別人的 Repository 複製一份成為自己的 Repository"></a><code>Fork</code>：將別人的 Repository 複製一份成為自己的 Repository</h3><ol>
<li>到想要複製的 Repository 頁面，點選 <code>Fork</code></li>
</ol>
<p><img src="https://i.imgur.com/Ms7FVgQ.png" alt="點選 fork"></p>
<ol start="2">
<li>即可複製一份 Repository 到自己的帳號底下</li>
</ol>
<p><img src="https://i.imgur.com/QKdoaYU.png" alt="fork 專案"></p>
<ol start="3">
<li>把專案 clone 到本地端，開新的 branch 進行修改</li>
<li>Push 回自己的專案</li>
<li>若為多人協作，可在自己的頁面提出 PR（pull request）給原作</li>
</ol>
<p><img src="https://i.imgur.com/leobPuk.png"></p>
<ol start="6">
<li>若原作同意修改內容，就會在他的頁面按下「Merge pull request」合併 commit</li>
</ol>
<p><img src="https://i.imgur.com/ov638xA.png"></p>
<hr>
<h3 id="補充：如何在-GitHub上同步-Fork-過來的-Repository"><a href="#補充：如何在-GitHub上同步-Fork-過來的-Repository" class="headerlink" title="補充：如何在 GitHub上同步 Fork 過來的 Repository"></a>補充：如何在 GitHub上同步 Fork 過來的 Repository</h3><ol>
<li><code>git remote -v</code>：查看目前的遠端節點。只有最一開始設的 origin 這個節點。</li>
</ol>
<p><img src="https://i.imgur.com/Dw3UoD7.png" alt="git remote -v 指令"></p>
<ol start="2">
<li><code>git remote add &lt;節點名稱&gt; &lt;網址&gt;</code>：新增一個遠端節點。</li>
</ol>
<ul>
<li><code>git remote add upstream https://github.com/Lidemy/mentor-program-4th.git</code>：為本地端檔案庫增加一個叫做 <code>upstream</code> 的遠端檔案庫。</li>
</ul>
<p><img src="https://i.imgur.com/YIsFYMS.png" alt="git remote add"></p>
<ol start="3">
<li><code>git pull upstream master</code>：把遠端 Repo 同步回本地端電腦。若發生衝突，則手動修改解決。</li>
</ol>
<p><img src="https://i.imgur.com/XFW7jEo.png" alt="git pull"></p>
<ol start="4">
<li>修改完成後，使用 <code>git commit -am &quot;同步課綱 repo&quot;</code> 重新 commit。</li>
<li><code>git push origin master</code>：同步回自己在 GitHub 的 遠端 Repo。</li>
</ol>
<blockquote>
<p>若要刪除舊有的 remote，可參考 <span class="exturl" data-url="aHR0cHM6Ly9hbmR5NjgwNHR3LmdpdGh1Yi5pby8yMDE5LzAxLzA0L2dpdC1yZW1vdmUtcmVtb3RlLw==">[Git筆記] 如何移除 remote origin<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
<p>想請問同步課綱 Repo，是不是就和「同步之前 Fork 過來的 Repo」情況相同呢？</p>
<ol>
<li><code>git remote add</code> 新增課綱 Repo 這個遠端節點</li>
<li><code>git pull</code> 把新課綱 Repo 同步到本地端，若發生衝突則手動解決再 <code>commit</code></li>
<li><code>git push</code> 同步回自己在 GitHub 的遠端 Repo</li>
</ol>
<p>自己依照這些步驟有成功把課綱 Repo 同步到 GitHub，想確認看看這觀念正不正確@@</p>
<hr>
<h2 id="常見狀況劇："><a href="#常見狀況劇：" class="headerlink" title="常見狀況劇："></a>常見狀況劇：</h2><h3 id="commit-message-送出後，發現打錯字了想要修改"><a href="#commit-message-送出後，發現打錯字了想要修改" class="headerlink" title="commit message 送出後，發現打錯字了想要修改"></a>commit message 送出後，發現打錯字了想要修改</h3><ol>
<li><code>git commit --amend</code>：進入 vim 編輯器，即可修改 commit message。但這個方法只能修改最後一次的 commit message</li>
</ol>
<p><img src="https://i.imgur.com/AD7xKzA.png" alt="git commit --amend"></p>
<ul>
<li>vim 編輯器介面如下，編輯完成後回到普通模式，輸入 <code>:wq</code> 存檔退出</li>
</ul>
<p><img src="https://i.imgur.com/Qc6ICVi.png" alt="Vim 編輯器"></p>
<ol start="2">
<li><code>git rebase</code>：可以修改更之前的 commit message，可參考<span class="exturl" data-url="aHR0cHM6Ly9naXRib29rLnR3L2NoYXB0ZXJzL3Jld3JpdGUtaGlzdG9yeS9jaGFuZ2UtY29tbWl0LW1lc3NhZ2UuaHRtbA==">詳細操作流程<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<blockquote>
<p>補充：若是在已經 commit 而且又 push 的情形下，在本地端進行修改 commit message 可能會造成其他人的困擾。最好的方法還是 push 之前先檢查一下，避免錯的東西被放到遠端。</p>
</blockquote>
<h3 id="我-commit-了可是我又不想-commit-了"><a href="#我-commit-了可是我又不想-commit-了" class="headerlink" title="我 commit 了可是我又不想 commit 了"></a>我 commit 了可是我又不想 commit 了</h3><p><code>git reset HEAD^</code>：回到上一個 commit 的狀態，保留檔案變更，需要再 commit 來新增版本。預設是 –mixed，可參考 <span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDE4NzMwMw==">Git reset 的三種模式( soft mixed hard )比較<i class="fa fa-external-link-alt"></i></span>。</p>
<ul>
<li><code>HEAD</code> 代表最新的，<code>^</code> 代表前一個。</li>
<li>因此 <code>HEAD^</code> 就是最新 commit 的前一個狀態，也就是上一個 commit 的狀態。</li>
</ul>
<h3 id="我還沒-commit，但我想把檔案回復到上次-commit-的狀態"><a href="#我還沒-commit，但我想把檔案回復到上次-commit-的狀態" class="headerlink" title="我還沒 commit，但我想把檔案回復到上次 commit 的狀態"></a>我還沒 commit，但我想把檔案回復到上次 commit 的狀態</h3><ol>
<li><code>git checkout -- &lt;file&gt;</code>：把檔案回復到上一次 commit 的狀態</li>
<li><code>git checkout -- .</code>：把專案內的所有檔案都回復</li>
</ol>
<p><img src="https://i.imgur.com/6gSEitU.png" alt="git checkout --"></p>
<ul>
<li>也可使用 <code>git restore &lt;file&gt;</code>，和 <code>git checkout -- &lt;file&gt;</code> 作用相同。</li>
</ul>
<p><img src="https://i.imgur.com/WcRW8cK.png" alt="git restore"></p>
<h3 id="改-branch-的名稱"><a href="#改-branch-的名稱" class="headerlink" title="改 branch 的名稱"></a>改 branch 的名稱</h3><p><code>git branch -m feature</code>：將分支名稱改成 feature。</p>
<p><img src="https://i.imgur.com/keijtFp.png" alt="git branch -m 指令"></p>
<hr>
<h2 id="GitHub-Flow"><a href="#GitHub-Flow" class="headerlink" title="GitHub Flow"></a>GitHub Flow</h2><p>GitHub 建議管理專案的流程：<span class="exturl" data-url="aHR0cHM6Ly9ndWlkZXMuZ2l0aHViLmNvbS9pbnRyb2R1Y3Rpb24vZmxvdy8=">官網說明<i class="fa fa-external-link-alt"></i></span></p>
<p>當參與多人開發時：（圖片出自 <span class="exturl" data-url="aHR0cHM6Ly9hcmNjd2lraS51d3lvLmVkdS9pbmRleC5waHAvR2l0X1dvcmtmbG93">arccwiki<i class="fa fa-external-link-alt"></i></span>）</p>
<p><img src="https://i.imgur.com/p0VjqBQ.png" alt="GitHub Flow step "></p>
<ol>
<li>先 Fork 專案到自己的 repository，開新的 branch 進行開發</li>
<li>修改內容後 commit 新增版本，再 push 回自己的 repository</li>
<li>pull request 到原本專案的 repository 請求合併</li>
<li>在上面進行討論，等待對方的 code review</li>
<li>在合併前進行最終測試</li>
<li>合併成功，刪掉 branch</li>
</ol>
<hr>
<h2 id="實戰演練"><a href="#實戰演練" class="headerlink" title="實戰演練"></a>實戰演練</h2><blockquote>
<p>假設今天已經建立好本地端和遠端的 resposity，那要如何進行往後的更新呢？</p>
</blockquote>
<ol>
<li>新建一個 branch：<code>git branch joke_1</code></li>
<li>切換到該 branch：<code>git checkout joke_1</code></li>
<li>編輯檔案<code>笑話大全.txt</code></li>
<li>完成後，若有新增檔案，可使用 <code>git add .</code> 把檔案加入版本控制</li>
<li>進行 commit：<code>git commit -am “new joke”</code></li>
<li>push 本地端分支回遠端 GitHub：<code>git push origin joke_1</code></li>
<li>到 Github 查看 branch 頁面，提出 PR（pull request）</li>
<li>完成合併到遠端 master，即可刪除分支 joke_1</li>
<li>把 GitHub 更新的 master 同步到本地端：<code>git push origin master</code></li>
<li>回到本地端，使用 <code>git branch -d joke_1</code> 刪除分支，結束！</li>
</ol>
<hr>
<h2 id="客製化各個階段：Git-hook"><a href="#客製化各個階段：Git-hook" class="headerlink" title="客製化各個階段：Git hook"></a>客製化各個階段：Git hook</h2><p>用途是「當發生某事的時候通知我」。例如：當有人 commit、有人push 時通知我。</p>
<p>通常使用在 commit 或是 push 之前，用來檢查程式碼是否符合規範、是否改到不能更改的檔案、是否有放一些不該放的檔案或帳號密碼。</p>
<h2 id="補充：本地端與遠端-相關指令"><a href="#補充：本地端與遠端-相關指令" class="headerlink" title="補充：本地端與遠端 - 相關指令"></a>補充：本地端與遠端 - 相關指令</h2><ul>
<li>以下示意圖出自<span class="exturl" data-url="aHR0cHM6Ly93d3cudXRzYy51dG9yb250by5jYS9+YXRhZmxpb3ZpY2gvY3NjYzAxL2xlY3R1cmVzLzAyLWNvbmZpZy1tYW5hZ2VtZW50LTIxLS5wZGY=">此處<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img src="https://i.imgur.com/avOoPLF.png" alt="git terminology"></p>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRlY2hicmlkZ2UuY2MvMjAxOC8wMS8xNy9sZWFybmluZy1wcm9ncmFtbWluZy1hbmQtY29kaW5nLXdpdGgtcHl0aG9uLWdpdC1hbmQtZ2l0aHViLXR1dG9yaWFsLw==">Git 與 Github 版本控制基本指令與操作入門教學<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtaWFoc3V3b3JrLyVFNyVBQyVBQyVFNCVCQSU4QyVFOSU4MCVCMS1naXQtJUU5JTgwJUIyJUU5JTlBJThFJUU0JUJEJUJGJUU3JTk0JUE4LWJyYW5jaC1tZXJnZS1hNTcxY2MwYTk1ZGU=">[第二週]Git 進階使用 Branch、Merge<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRib29rLnR3L2NoYXB0ZXJzL2dpdGh1Yi9wdXNoLXRvLWdpdGh1Yi5odG1s">Git教學：如何 Push 上傳到 GitHub？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ndWlkZXMuZ2l0aHViLmNvbS9pbnRyb2R1Y3Rpb24vZmxvdy8=">GitHub Guides - Understanding the GitHub flow<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcmNjd2lraS51d3lvLmVkdS9pbmRleC5waHAvR2l0X1dvcmtmbG93">Git Workflow - arccwiki<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRib29rLnR3L2NoYXB0ZXJzL3Jld3JpdGUtaGlzdG9yeS9jaGFuZ2UtY29tbWl0LW1lc3NhZ2UuaHRtbA==">【狀況題】修改歷史訊息<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudXRzYy51dG9yb250by5jYS9+YXRhZmxpb3ZpY2gvY3NjYzAxL2xlY3R1cmVzLzAyLWNvbmZpZy1tYW5hZ2VtZW50LTIxLS5wZGY=">CSCC01: Configuration Management<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRib29rLnR3L2NoYXB0ZXJzL2dpdGh1Yi9zeW5jaW5nLWEtZm9yay5odG1s">【狀況題】怎麼跟上當初 fork 專案的進度？<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制：如何進行多人協作 &amp; 同步分支 </title>
    <url>/git-workflow/</url>
    <content><![CDATA[<h2 id="實作新功能一定要在分支進行"><a href="#實作新功能一定要在分支進行" class="headerlink" title="實作新功能一定要在分支進行"></a>實作新功能一定要在分支進行</h2><p>不管是在個人專案，還是在多人協作時，都必須記得在實作新功能時，一定要在分支上進行：</p>
<a id="more"></a>

<pre><code>$ git branch &lt;new_branch&gt;  // 開新分支
$ git checkout &lt;new_branch&gt;  // 切換到新分支
$ git commit -am &#39;new_commit&#39; 
$ git push origin &lt;new_branch&gt;  // push 分支</code></pre>
<h2 id="多人協作之狀況劇"><a href="#多人協作之狀況劇" class="headerlink" title="多人協作之狀況劇"></a>多人協作之狀況劇</h2><p>在課程最一開始寫的 Git 筆記：<a href="https://heidiliu2020.github.io/git-github/">[week 1] 版本控制 - Git 進階指令 &amp; GitHub</a>，也有提到一些常見狀況劇。</p>
<p>最近在進行 Final Project 時，體驗到多人協作和個人專案的不同，有許多需要注意的地方，這裡舉幾個自己實際遇到的狀況以及解決方式：</p>
<ul>
<li>狀況一：如何同步分支</li>
<li>狀況二：如何新增要忽略版本控制的檔案</li>
<li>狀況三：如何撤回已經 push 的 branch</li>
<li>狀況四：我 commit 了可是我又不想 commit 了</li>
</ul>
<h3 id="狀況一：在-push-分支之前，該如何讓分支同步-master？"><a href="#狀況一：在-push-分支之前，該如何讓分支同步-master？" class="headerlink" title="狀況一：在 push 分支之前，該如何讓分支同步 master？"></a>狀況一：在 push 分支之前，該如何讓分支同步 master？</h3><p>當我們要 push 分支時，如果沒有先同步 master 進度，就會出現衝突問題，有兩種方式解決：</p>
<h4 id="第一種：切回-master-同步，直接再開一個新分支"><a href="#第一種：切回-master-同步，直接再開一個新分支" class="headerlink" title="第一種：切回 master 同步，直接再開一個新分支"></a>第一種：切回 master 同步，直接再開一個新分支</h4><p>這個方法可以確保新分支一定是同步遠端的狀態，缺點就是要記得先備份好要 commit 的內容，才能切回 master 同步：</p>
<pre><code>$ git checkout master  // 切回 master
$ git pull origin master  // 同步遠端 master
$ git branch &lt;new_branch&gt; // 新開分支
$ git checkout &lt;new_branch&gt;  // 切換到分支
$ git commit -am &#39;new_commit&#39; 
$ git push origin &lt;new_branch&gt; // push 分支</code></pre>
<h4 id="第二種：繼續在舊的分支開發，需要先同步分支"><a href="#第二種：繼續在舊的分支開發，需要先同步分支" class="headerlink" title="第二種：繼續在舊的分支開發，需要先同步分支"></a>第二種：繼續在舊的分支開發，需要先同步分支</h4><p>較推薦這個方法，直接在舊分支同步遠端，就不須再另外新開分支：</p>
<pre><code>$ git pull origin master  // 同步遠端 master
$ git commit -am &#39;new_commit&#39;
$ git push origin &lt;old_branch&gt; // push 分支</code></pre>
<p>依照上述其中一種方式，之後就可以在 GitHub 頁面發 PR 進行 merge，解決衝突問題。<br><br></p>
<h3 id="狀況二：不小心把要被忽略的檔案-push-上去了！"><a href="#狀況二：不小心把要被忽略的檔案-push-上去了！" class="headerlink" title="狀況二：不小心把要被忽略的檔案 push 上去了！"></a>狀況二：不小心把要被忽略的檔案 push 上去了！</h3><p>如果是在建立 <code>.gitignore</code> 之前，不小心把要被版本控制忽略的檔案給 push 上 GitHub 的話該怎麼辦呢？</p>
<p>以 React 中會自動生成的 <code>.eslintcache</code> 為例，如果在忽略之前就先把檔案 push 上去，之後多人協作要進行 merge 時，都必須解決衝突問題，這時只要按照以下步驟：</p>
<h4 id="1-切換到-master，同步專案"><a href="#1-切換到-master，同步專案" class="headerlink" title="1. 切換到 master，同步專案"></a>1. 切換到 master，同步專案</h4><pre><code>$ git pull origin master</code></pre>
<h4 id="2-刪掉本地端的-eslintcache-檔案"><a href="#2-刪掉本地端的-eslintcache-檔案" class="headerlink" title="2. 刪掉本地端的 .eslintcache 檔案"></a>2. 刪掉本地端的 <code>.eslintcache</code> 檔案</h4><h4 id="3-將-eslintcache-加入專案根目錄的-gitignore-忽略版本控制"><a href="#3-將-eslintcache-加入專案根目錄的-gitignore-忽略版本控制" class="headerlink" title="3. 將 .eslintcache 加入專案根目錄的 .gitignore 忽略版本控制"></a>3. 將 <code>.eslintcache</code> 加入專案根目錄的 <code>.gitignore</code> 忽略版本控制</h4><pre><code class="=">// .gitignore 檔案

*.eslintcache</code></pre>
<h4 id="4-commit-本次操作，commit-名稱可自行修改"><a href="#4-commit-本次操作，commit-名稱可自行修改" class="headerlink" title="4. commit 本次操作，commit 名稱可自行修改"></a>4. commit 本次操作，commit 名稱可自行修改</h4><pre><code>$ git commit -am &quot;fix: remove .eslintcache&quot;</code></pre>
<h4 id="5-push-到-GitHub-master，這時-GitHub-上的專案就不會出現應該被忽略的檔案了"><a href="#5-push-到-GitHub-master，這時-GitHub-上的專案就不會出現應該被忽略的檔案了" class="headerlink" title="5. push 到 GitHub master，這時 GitHub 上的專案就不會出現應該被忽略的檔案了"></a>5. push 到 GitHub master，這時 GitHub 上的專案就不會出現應該被忽略的檔案了</h4><pre><code>$ git push origin master</code></pre>
<h4 id="6-讓其他協作者-pull-同步專案，修改完成！"><a href="#6-讓其他協作者-pull-同步專案，修改完成！" class="headerlink" title="6. 讓其他協作者 pull 同步專案，修改完成！"></a>6. 讓其他協作者 pull 同步專案，修改完成！</h4><br>

<h3 id="狀況三：我-commit-了可是我又不想-commit-了"><a href="#狀況三：我-commit-了可是我又不想-commit-了" class="headerlink" title="狀況三：我 commit 了可是我又不想 commit 了"></a>狀況三：我 commit 了可是我又不想 commit 了</h3><h4 id="回到上一個-commit-狀態，保留檔案變更，需要再-commit-來新增版本："><a href="#回到上一個-commit-狀態，保留檔案變更，需要再-commit-來新增版本：" class="headerlink" title="回到上一個 commit 狀態，保留檔案變更，需要再 commit 來新增版本："></a>回到上一個 commit 狀態，保留檔案變更，需要再 commit 來新增版本：</h4><ul>
<li>HEAD 代表最新的，^ 代表前一個，因此 HEAD^ 就是上一個 commit 的狀態</li>
<li>預設是 –mixed，可參考 <span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDE4NzMwMw==">Git reset 的三種模式（soft mixed hard）<i class="fa fa-external-link-alt"></i></span>比較</li>
</ul>
<pre><code>$ git reset HEAD^  // 退回到上一個 commit，等同於 git reset HEAD~1
$ git log   // 可查看版本號
$ git reset &lt;38e7e30 &gt;  // 退回到 &lt;38e7e30&gt; 這個 commit</code></pre>
<br>

<h3 id="狀況四：如何撤回已經-push-的-branch"><a href="#狀況四：如何撤回已經-push-的-branch" class="headerlink" title="狀況四：如何撤回已經 push 的 branch"></a>狀況四：如何撤回已經 push 的 branch</h3><h4 id="1-退回本地端的-commit-狀態"><a href="#1-退回本地端的-commit-狀態" class="headerlink" title="1. 退回本地端的 commit 狀態"></a>1. 退回本地端的 commit 狀態</h4><p>需注意這裡用 <code>git reset --hard</code> 指令，除了回到指定 commit 版本，程式碼也會回到指定版本的狀態：</p>
<pre><code>$ git log   // 可查看版本號
$ git reset --hard &lt;6gye93e&gt;  // 退回到 &lt;6gye93e&gt; 這個 commit</code></pre>
<h4 id="2-強制-push-本地端-branch-到遠端"><a href="#2-強制-push-本地端-branch-到遠端" class="headerlink" title="2. 強制 push 本地端 branch 到遠端"></a>2. 強制 push 本地端 branch 到遠端</h4><p>由於本地端分支版本低於遠端分支版本，這裡必須使用 <code>--force</code> 來強制 push 想要拆掉重做的 branch：</p>
<pre><code>$ git push origin &lt;branch&gt; --force</code></pre>
<p>這樣就成功撤銷已經 push 的 branch，回到指定的 commit 狀態了！<br><br></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>其實 Git 版本控制是在 Lidemy 課程最一開始學的，之後繳交作業都是透過 Git 進行，中間也曾遇到種種狀況，像是不小心把同步課程大綱也 push 上去等等。</p>
<p>最近和同學實際進行團體協作，才發現需要注意的事情又更多了！常常一個不注意下錯指令，把應該 push 的分支 push 成 master，還沒同步分支必須解決的衝突問題等等，趁這個機會把一些自己實際遇到的狀況給寫下來。熟悉多人協作以後，感覺自己又對版本控制有更深一層的認識。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 1] 版本控制 - Git 概念 ＆ 基本指令</title>
    <url>/git/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZ2l0MTAx">[GIT101] Git 超新手入門<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。</p>
</blockquote>
<pre><code>學習目標：

 了解 Git 在做什麼，以及為何我們需要 Git
 知道 add、commit、push、pull 等基本 Git 指令</code></pre>
<a id="more"></a>
<hr>
<h2 id="什麼是版本控制？"><a href="#什麼是版本控制？" class="headerlink" title="什麼是版本控制？"></a>什麼是版本控制？</h2><h4 id="簡言之，就是將一個檔案所有歷史紀錄的版本都保存起來，以便日後參考。"><a href="#簡言之，就是將一個檔案所有歷史紀錄的版本都保存起來，以便日後參考。" class="headerlink" title="簡言之，就是將一個檔案所有歷史紀錄的版本都保存起來，以便日後參考。"></a>簡言之，就是將一個檔案所有歷史紀錄的版本都保存起來，以便日後參考。</h4><p>我們其實曾接觸過版本控制，例如備份檔案，或是以不同檔名保存編輯過的檔案：</p>
<p><img src="https://i.imgur.com/2nnCsCD.png" alt="個人的版本控制"></p>
<h2 id="但這種管理方式會碰到哪些問題？"><a href="#但這種管理方式會碰到哪些問題？" class="headerlink" title="但這種管理方式會碰到哪些問題？"></a>但這種管理方式會碰到哪些問題？</h2><ol>
<li>檔案一多、時間久了之後不易管理</li>
<li>多人協作易發生衝突，無法快速分辨檔案差異</li>
</ol>
<h2 id="那麼，該如何做版本控制呢？"><a href="#那麼，該如何做版本控制呢？" class="headerlink" title="那麼，該如何做版本控制呢？"></a>那麼，該如何做版本控制呢？</h2><ol>
<li>需要新版本時：<br>開一個新資料夾，用來完整保存當時檔案狀態。</li>
<li>不想加入版本控制：<br>就不需加入資料夾，例如有些不會更動的檔案（電腦設定檔、log 檔），或者不需做版控的檔案（例如帳密等有安全性考量）。</li>
<li>避免版本號衝突：<br>會以亂數，也就是絕不會重複的流水號作為資料夾名稱。</li>
<li>知道最新版本：<br>開一個檔案（new）來存最新的版本號。</li>
<li>保存歷史紀錄：<br>開一個檔案（order）整理流水號。</li>
</ol>
<h4 id="上述概念，其實就類似-Git-版本控制系統的運作模式。目的是進行備份與共用，讓電腦自動幫我們做一些記錄與管理。"><a href="#上述概念，其實就類似-Git-版本控制系統的運作模式。目的是進行備份與共用，讓電腦自動幫我們做一些記錄與管理。" class="headerlink" title="上述概念，其實就類似 Git 版本控制系統的運作模式。目的是進行備份與共用，讓電腦自動幫我們做一些記錄與管理。"></a>上述概念，其實就類似 Git 版本控制系統的運作模式。目的是進行備份與共用，讓電腦自動幫我們做一些記錄與管理。</h4><blockquote>
<p>補充：GitHub 就是透過 Git 進行版本控制的軟體原始碼代管服務平台。</p>
</blockquote>
<hr>
<h2 id="Git-基本指令操作"><a href="#Git-基本指令操作" class="headerlink" title="Git 基本指令操作"></a>Git 基本指令操作</h2><h3 id="git-init：初始化當前目錄"><a href="#git-init：初始化當前目錄" class="headerlink" title="git init：初始化當前目錄"></a><code>git init</code>：初始化當前目錄</h3><p>在當前位置新增 <code>.git</code> 隱藏資料夾，也就是建立 Git Repository（檔案庫）。目的是初始化這個目錄，讓 Git 對這個目錄做版本控管。</p>
<p><img src="https://i.imgur.com/BVuxZag.png" alt="init 初始化"></p>
<h3 id="git-status：檢查當前版本狀態"><a href="#git-status：檢查當前版本狀態" class="headerlink" title="git status：檢查當前版本狀態"></a><code>git status</code>：檢查當前版本狀態</h3><p>例如：未進入版本控管（Untracked）、新增檔案（New File）、刪除檔案（Deleted）、檔案已修改（Modified）等。是會經常使用的指令。</p>
<h3 id="git-add：加入版本控制"><a href="#git-add：加入版本控制" class="headerlink" title="git add：加入版本控制"></a><code>git add</code>：加入版本控制</h3><p>把檔案從 Untracked（不加入的檔案）移到 stage（加入版本控制的檔案）。</p>
<p>依照括號內提示可知：</p>
<ul>
<li><code>git rm --cached &lt;file&gt;</code>：取消版控</li>
<li><code>git add &lt;file&gt;</code>：加入版控</li>
<li>若檔案數量太多，可使用 <code>git add .</code> 把檔案全部加入版本控制。</li>
</ul>
<p><img src="https://i.imgur.com/vX2e43W.png" alt="git add 指令"></p>
<h3 id="git-commit：新建版本"><a href="#git-commit：新建版本" class="headerlink" title="git commit：新建版本"></a><code>git commit</code>：新建版本</h3><ol>
<li>輸入指令後會進入 vim 介面，就可以編輯提交版本訊息（commit message）</li>
<li>若不想進入 vim，也可輸入 <code>git commit -m &quot;message&quot;</code> 直接建立新版本</li>
</ol>
<p><img src="https://i.imgur.com/NlBaU85.png" alt="git commit 指令"></p>
<h3 id="小技巧：git-commit-am-quot-message-quot"><a href="#小技巧：git-commit-am-quot-message-quot" class="headerlink" title="小技巧：git commit -am　&quot;message&quot;"></a>小技巧：<code>git commit -am　&quot;message&quot;</code></h3><p>輸入 <code>git commit -am &quot;message&quot;</code> 可一次完成 <code>add</code> 和 <code>commit</code> 兩個指令動作。</p>
<h4 id="但需注意："><a href="#但需注意：" class="headerlink" title="但需注意："></a>但需注意：</h4><ol>
<li><code>-a</code> 指令只對「已存在」的檔案有效；不適用於新加入的檔案（Untracked File）</li>
<li>若有新增的檔案，仍須先 <code>add</code> 再 <code>commit</code> ，才能把新檔加入版控</li>
</ol>
<h3 id="git-log：查看版本紀錄"><a href="#git-log：查看版本紀錄" class="headerlink" title="git log：查看版本紀錄"></a><code>git log</code>：查看版本紀錄</h3><p>從新到舊列出，內容分別是版本號碼、提交者、提交時間。</p>
<p><img src="https://i.imgur.com/gZ9G2c1.png" alt="git log 指令"></p>
<ul>
<li><code>git log --oneline</code>：輸出更簡短的 log，只用版本號前七碼代值</li>
</ul>
<p><img src="https://i.imgur.com/V0HyJbP.png" alt="git log --oneline 指令"></p>
<h3 id="git-checkout：切換到某個版本"><a href="#git-checkout：切換到某個版本" class="headerlink" title="git checkout：切換到某個版本"></a><code>git checkout</code>：切換到某個版本</h3><p>切換到某個版本，可查看過去的版本內容。</p>
<ul>
<li><code>git checkout &lt;版本號碼&gt;</code> ：切換到指定版本</li>
<li><code>git checkout master</code> ：切換到最新版本</li>
</ul>
<p><img src="https://i.imgur.com/hqROiIw.png" alt="git checkout 指令"></p>
<h3 id="gitignore：忽略不要版本控制的檔案"><a href="#gitignore：忽略不要版本控制的檔案" class="headerlink" title=".gitignore：忽略不要版本控制的檔案"></a><code>.gitignore</code>：忽略不要版本控制的檔案</h3><p><code>.gitignore</code> 這個檔案本身也需加入版本控制。通常會加入忽略清單的檔案有：系統檔案、記錄檔、暫存檔等，可參考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyLy5naXRpZ25vcmU=">Facebook 開源專案 React 裡的 .gitignore<i class="fa fa-external-link-alt"></i></span> 為例子。</p>
<h4 id="那麼，該如何建立忽略清單呢？"><a href="#那麼，該如何建立忽略清單呢？" class="headerlink" title="那麼，該如何建立忽略清單呢？"></a>那麼，該如何建立忽略清單呢？</h4><ol>
<li>輸入 <code>touch .gitignore</code> 建立檔案</li>
<li>輸入 <code>vim .gitignore</code> 進入 <code>vim</code> 介面</li>
</ol>
<p><img src="https://i.imgur.com/dwIzY2m.png" alt="進入vim介面"></p>
<ol start="3">
<li>以不加入版控的 test 為例，輸入完 test 後儲存離開</li>
</ol>
<p><img src="https://i.imgur.com/WtYtJkL.png" alt="建立忽略清單"></p>
<ol start="4">
<li>以 <code>git status</code> 查看，可知 test 這個檔案已被 git 忽略</li>
</ol>
<p><img src="https://i.imgur.com/XUsgqPr.png" alt="完成忽略清單"></p>
<ol start="5">
<li>如此即可使用 <code>git add .</code> 把所有檔案加入版本控制，包括新舊檔案；<br>再用 <code>git commit -m &quot;message&quot;</code> 建立新版本</li>
</ol>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>複習上述指令，以下為開始使用 git 的流程：</p>
<ol>
<li><code>git init</code>：初始化當前位置，讓 Git 對這個目錄進行版控</li>
<li>建立 <code>.gitignore</code> 忽略不需版本控制的檔案</li>
<li><code>git add .</code>：把所有檔案加入版本控制（把東西放到一個暫存資料夾 <code>temp</code>  ）</li>
<li><code>git commit -am &quot;message&quot;</code>：新建一個版本（把 <code>temp</code> 資料夾改名為<code>&quot;版本號&quot;</code>）<ul>
<li>若有新檔案，需重複<code>步驟 3.</code> 把所有檔案加進版本控制，才能執行 <code>commit</code></li>
<li>在 commit 之前，可用 <code>git diff</code> 查看與上一版的差異</li>
</ul>
</li>
<li><code>git checkout &lt;版本號&gt;</code> ： 可以切換各個版本（去到某個資料夾底下）<br><code>git checkout master</code> ： 回到最新版本</li>
</ol>
<blockquote>
<p>操作 Git 時突然每行句首都出現 <code>&gt;</code> 這個符號，無法繼續輸入指令怎麼辦？</p>
<p>解決方法：ctrl + d 即可退出。這種情況可能是因為只輸入了一邊雙引號或單引號，導致沒有輸入完成（輸入沒有閉合）。</p>
</blockquote>
<hr>
<h3 id="補充-1：檔案在-Git-底下的四種狀態"><a href="#補充-1：檔案在-Git-底下的四種狀態" class="headerlink" title="補充 1：檔案在 Git 底下的四種狀態"></a>補充 1：檔案在 Git 底下的四種狀態</h3><ul>
<li>File status lifecycle（圖片來自 <span class="exturl" data-url="aHR0cHM6Ly9rdWVpYmxvZy5oZXJva3VhcHAuY29tL3Bvc3QvZ2l0JUU1JUFEJUI4JUU3JUJGJTkyJUU0JUI5JThCJUU0JUJBJThDJTIwLSUyMGNvbW1pdCVFOCVBQyU5QiVFOCVBNyVBMyVFMyU4MCU4MXJlc2V0JUU1JUJFJUE5JUU1JThFJTlGJUU3JTg5JTg4JUU2JTlDJUFDJUUzJTgwJTgxJUU1JUJCJUJBJUU3JUFCJThCJUU1JTg4JTg2JUU2JTk0JUFGLw==">link<i class="fa fa-external-link-alt"></i></span>）<br><img src="https://i.imgur.com/jz9qufH.png" alt="File status lifecycle"></li>
</ul>
<ol>
<li>untracked（未追蹤的）：代表檔案尚未被加入版控</li>
<li>staged（暫存區）：等待被 commit 的檔案，才能執行 <code>git commit</code> 指令送入版本庫</li>
<li>unmodified（未修改的）：代表檔案第一次被加入，或檔案內容與 <code>HEAD</code> 內容一致的狀態</li>
<li>modified（已修改的）：代表檔案已經被編輯過，或檔案內容與 <code>HEAD</code> 內容不一致的狀態</li>
</ol>
<h3 id="補充-2：設定帳號和姓名"><a href="#補充-2：設定帳號和姓名" class="headerlink" title="補充 2：設定帳號和姓名"></a>補充 2：設定帳號和姓名</h3><p>第一次輸入 <code>git commit</code> 指令時出現錯誤，跳出需要設定帳號和姓名的畫面，這時需輸入以下指令：</p>
<pre><code>git config --global user.name &quot;your name&quot;　　//  &quot;換成自己的帳號和信箱&quot;
git config --global user.email &quot;your email&quot;</code></pre>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9kamFuZ29naXJsc3RhaXBlaS5oZXJva3VhcHAuY29tL3R1dG9yaWFscy92ZXJzaW9uLWNvbnRyb2wtd2l0aC1naXQvP29zPXdpbmRvd3M=">用 Git 進行版本控制<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtYWtlcmluY29sbGVnZTIwMTgvJUU1JUI3JUE1JUU3JUE4JThCJUU1JUI4JUFCJUU1JUJGJTg1JUU2JTg3JTgyJUU3JTlBJTg0JUU3JTg5JTg4JUU2JTlDJUFDJUU2JThFJUE3JUU1JTg4JUI2JUU2JThBJTgwJUU4JUExJTkzLSVFNCVCQiU4MCVFOSVCQSVCQyVFNiU5OCVBRmdpdGh1Yi0zNzY0MjFmZDg3MWQ=">【工程師必懂的版本控制技術】什麼是GitHub?<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jeXRoaWx5YS5naXRodWIuaW8vMjAxOC8wNC8wNS9naXQv">Git 筆記| Summer。桑莫。夏天<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly95YWtpbWhzdS5jb20vcHJvamVjdC9wcm9qZWN0X3cxX0dpdF8xLmh0bWw=">[第一週] 版本控制 - 原理 ＆ 基本 Git 指令 by Yakim<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9rdWVpYmxvZy5oZXJva3VhcHAuY29tL3Bvc3QvZ2l0JUU1JUFEJUI4JUU3JUJGJTkyJUU0JUI5JThCJUU0JUJBJThDJTIwLSUyMGNvbW1pdCVFOCVBQyU5QiVFOCVBNyVBMyVFMyU4MCU4MXJlc2V0JUU1JUJFJUE5JUU1JThFJTlGJUU3JTg5JTg4JUU2JTlDJUFDJUUzJTgwJTgxJUU1JUJCJUJBJUU3JUFCJThCJUU1JTg4JTg2JUU2JTk0JUFGLw==">[KueiKuei ‘s Blog] git學習之二 - commit講解、reset復原版本、建立分支<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 13] 前端工具之三 - gulp、webpack</title>
    <url>/gulp-webpack/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUyMDE=">[FE201] 前端中階：那些前端會用到的工具們<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用新工具之前，大致會依照下列步驟：</p>
<ol>
<li>安裝工具</li>
<li>閱讀官方文件</li>
<li>更改設定檔<a id="more"></a>
</li>
</ol>
<hr>
<h2 id="gulp：整合流程"><a href="#gulp：整合流程" class="headerlink" title="gulp：整合流程"></a>gulp：整合流程</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ndWxwanMuY29tLw==">gulp<i class="fa fa-external-link-alt"></i></span> 是一個前端自動化構建工具，開發者可使用它來建構自動化工作流程。</p>
<h3 id="為什麼需要-glup？"><a href="#為什麼需要-glup？" class="headerlink" title="為什麼需要 glup？"></a>為什麼需要 glup？</h3><p>為了將工作流程自動化，也就是整合前端開發環境。藉由簡化工作量，可讓開發者將重點放在功能的開發上。</p>
<p>例如下列功能：</p>
<ul>
<li>讓網頁自動重新整理</li>
<li>編譯 SASS 、程式碼檢測</li>
<li>壓縮 CSS, JS, 圖檔</li>
<li>自訂任務流程..</li>
</ul>
<h3 id="如何安裝"><a href="#如何安裝" class="headerlink" title="如何安裝"></a>如何安裝</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">Node.js<i class="fa fa-external-link-alt"></i></span> 是一個讓 Javascript 運行在服務端的開發平台。</p>
</blockquote>
<p>由於 gulp 是基於 Node.js 進行開發，使用前必須先安裝 node.js、npm。接著即可按照<span class="exturl" data-url="aHR0cHM6Ly9ndWxwanMuY29tL2RvY3MvZW4vZ2V0dGluZy1zdGFydGVkL3F1aWNrLXN0YXJ0Lw==">官方文件 Quick Start<i class="fa fa-external-link-alt"></i></span> 安裝 gulp：</p>
<ol>
<li><code>npm install --global gulp-cli</code>：安裝 gulp-cli</li>
<li>開啟需使用 gulp 的專案資料夾</li>
<li><code>npm init</code>：進行初始化</li>
<li><code>npm install --save-dev gulp</code>：安裝 gulp package</li>
<li><code>gulp --version</code>：可使用指令檢查是否安裝成功</li>
</ol>
<h3 id="gulp-提供的-API"><a href="#gulp-提供的-API" class="headerlink" title="gulp 提供的 API"></a>gulp 提供的 API</h3><ul>
<li>gulp.task　執行工作</li>
<li>gulp.src　執行資料來源</li>
<li>gulp.dest　執行結果位置</li>
<li>gulp.watch　監視執行過程中，資料是否變更</li>
</ul>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlcnR3LmNvbS8lRTclQTglOEIlRTUlQkMlOEYlRTglQUElOUUlRTglQTglODAvNDE4NTUzLw==">什麼是gulp,怎麼使用gulp | 程式前沿<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BodWdoX1Byb2dyYW1fbGVhcm5pbmdfZGlhcnlfSnMvJUU1JTg5JThEJUU3JUFCJUFGJUU0JUI4JUFEJUU5JTlBJThFLWd1bHAtNzkxMTMyYmVhOWYx">前端中階：gulp. 介紹| by Hugh’s Program learning | Medium<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="uglify-與-minify"><a href="#uglify-與-minify" class="headerlink" title="uglify 與 minify"></a>uglify 與 minify</h2><h3 id="uglify"><a href="#uglify" class="headerlink" title="uglify"></a>uglify</h3><ul>
<li><code>gulp-uglify</code>：混淆並壓縮 JavaScript 檔案</li>
<li>壓縮：減少代碼量，減少網絡下載時間以及瀏覽器的解析時間</li>
<li>混淆：藉此提升代碼閱讀難度，有一定程度的保護代碼作用</li>
</ul>
<p>配置範例：</p>
<pre><code class="javascript=">let gulp = require(&#39;gulp&#39;),               // 載入 gulp
let gulpUglify = require(&#39;gulp-uglify&#39;);  // 載入 gulp-uglify

gulp.task(&#39;script&#39;, function () &#123;
    gulp.src(&#39;javascript/original/*.js&#39;)        // 指定要處理的原始 JavaScript 檔案目錄
        .pipe(gulpUglify())                     // 將 JavaScript 做最小化
        .pipe(gulp.dest(&#39;javascript/minify&#39;));  // 指定最小化後的 JavaScript 檔案目錄
&#125;);</code></pre>
<h3 id="minify"><a href="#minify" class="headerlink" title="minify"></a>minify</h3><ul>
<li><code>gulp-minify-css</code>：壓縮 CSS 檔案</li>
<li>壓縮：藉由去掉空格、換行符號等，縮短變數跟 code 長度，以節省瀏覽器 Parse（解析）時間</li>
<li>但更新的版本已經不太適用，改為使用 <code> gulp-clean-css</code></li>
</ul>
<p>配置範例：</p>
<pre><code class="javascript=">let gulp = require(&#39;gulp&#39;);
let cleanCSS = require(&#39;gulp-clean-css&#39;);

gulp.task(&#39;minify-css&#39;, () =&gt; &#123;
  return gulp.src(&#39;styles/*.css&#39;)
    .pipe(cleanCSS(&#123;compatibility: &#39;ie8&#39;&#125;))
    .pipe(gulp.dest(&#39;dist&#39;));
&#125;);</code></pre>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL2tlanl1bi5naXRodWIuaW8vZ3VscC1sZWFybmluZy1ub3Rlcy9wbGd1aW5zL0phdmFTY3JpcHQvUGx1Z2lucy1KYXZhU2NyaXB0LWd1bHAtdWdsaWZ5Lmh0bWw=">【gulp-uglify】最小化 JavaScript | gulp 學習筆記<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDE5MTk5Mg==">前端也需要編譯？Transpile、Compile、Minify、Uglify 基本介紹<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlcnR3LmNvbS8lRTclQTglOEIlRTUlQkMlOEYlRTglQUElOUUlRTglQTglODAvNjc0NjI1Lw==">亦敵亦友的uglify<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIyNTY2Ng==">[試著把切版專案升級到 gulp4.0 吧] Day21 CSS 的處理：談壓縮 CSS 與 gulp-clean-css<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="Webpack：打包程式碼"><a href="#Webpack：打包程式碼" class="headerlink" title="Webpack：打包程式碼"></a>Webpack：打包程式碼</h2><h3 id="什麼是-Webpack"><a href="#什麼是-Webpack" class="headerlink" title="什麼是 Webpack"></a>什麼是 Webpack</h3><p>Webpack　是一套模組整合工具。可將零散的 JavaScript 模組打包，然後在瀏覽器上運行，解決舊瀏覽器不支援部分新語法的問題，也利於後續管理與維護。</p>
<p>此外，Webpack 也提供了前端開發缺乏的模組化開發方式，可將各種靜態資源視為模組，例如 JS、CSS、SASS、圖片檔等，透過不同的 loader 將資源轉換並載入，再利用 Webpack 進行打包成 JS 檔，生成最佳化過的程式碼。</p>
<h3 id="為什麼要使用-Webpack？"><a href="#為什麼要使用-Webpack？" class="headerlink" title="為什麼要使用 Webpack？"></a>為什麼要使用 Webpack？</h3><p>若不使用 Webpack，可能會遇到下列問題：</p>
<ol>
<li>瀏覽器支援度：由於部分瀏覽器不支援 ES6 模組，例如 IE，若要使用 import、export 等語法，則需要其他工具來進行轉換。</li>
<li>不易引用套件：若想要引用他人撰寫的 library 套件，需考慮相容性問題，以及可能造成命名衝突。</li>
</ol>
<h3 id="如何安裝-1"><a href="#如何安裝-1" class="headerlink" title="如何安裝"></a>如何安裝</h3><p>跟著官方教學步驟 <span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9ndWlkZXMvZ2V0dGluZy1zdGFydGVkLw==">Getting Started<i class="fa fa-external-link-alt"></i></span> 安裝 webpack：</p>
<pre><code>mkdir webpack-demo
cd webpack-demo
npm init -y
npm install webpack webpack-cli --save-dev</code></pre>
<p><img src="https://i.imgur.com/MP3ufbd.png"></p>
<h3 id="相關語法"><a href="#相關語法" class="headerlink" title="相關語法"></a>相關語法</h3><blockquote>
<p><code>dev</code>：代表開發時才會使用，打包後就不會出現在裡面（記錄在 package.json -&gt; devDependencies）</p>
</blockquote>
<ul>
<li>下載 jquery</li>
</ul>
<pre><code>npm install jquery webpack-cli --save-dev</code></pre>
<ul>
<li>css-Loader：用來解析 CSS 檔</li>
</ul>
<pre><code>npm install --save-dev css-loader
npm install --save-dev style-loader</code></pre>
<ul>
<li>babel-loader</li>
</ul>
<pre><code>npm install -D babel-loader @babel/core @babel/preset-env</code></pre>
<ul>
<li>sass-loader</li>
</ul>
<pre><code>npm install sass-loader sass webpack --save-dev</code></pre>
<h3 id="執行步驟"><a href="#執行步驟" class="headerlink" title="執行步驟"></a>執行步驟</h3><ul>
<li>需要進行編譯的檔案，通常不會直接放在根目錄，而是會先放在 src（source code），使用工具轉換後再放到其他地方。</li>
<li>webpack 預設執行檔案路徑如下：</li>
</ul>
<pre><code>webpack-demo/src/index.js</code></pre>
<p>以 index.js 引入 utils.js 為例：</p>
<h4 id="utils-js"><a href="#utils-js" class="headerlink" title="utils.js"></a>utils.js</h4><pre><code class="javascript=">const Utils = &#123;
  first: function(str) &#123;
    return str[0]
  &#125;
&#125;

module.exports = Utils</code></pre>
<h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><pre><code class="javascript=">const utils = require(&#39;./utils&#39;)

console.log(utils.first(&#39;abc&#39;))</code></pre>
<p>在 CLI 執行 <code>npm src/index.js</code> 後印出 <code>a</code>，代表成功引入檔案。</p>
<p><img src="https://i.imgur.com/QmPof6p.png"></p>
<p>接著以 <code>npx webpack</code> 執行打包，完成會自動把檔案 main.js 放在資料夾 dist。</p>
<p>若執行檔案 <code>npm dist/main.js</code> 仍會得到相同結果：</p>
<p><img src="https://i.imgur.com/aE3nKoD.png"></p>
<p>接著在 index.html 引入：</p>
<pre><code class="javascript=">&lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>即可透過 webpack 打包 module，讓我們能夠在瀏覽器上執行使用 require 語法。</p>
<h3 id="webpack-config-js：預設執行檔"><a href="#webpack-config-js：預設執行檔" class="headerlink" title="webpack.config.js：預設執行檔"></a><code>webpack.config.js</code>：預設執行檔</h3><p>在安裝好 loader 後，需設定執行檔，透過指定 rules 來執行檔案：</p>
<h4 id="基本設定"><a href="#基本設定" class="headerlink" title="基本設定"></a>基本設定</h4><pre><code class="javascript=">// webpack.config.js
const path = require(&#39;path&#39;)

module.exports = &#123;
   mode: &#39;&#39;,
  entry: [&#39;./src/index&#39;], // 在 index 檔案後的 .js 副檔名是可選的
  output: &#123;
    path: path.join(__dirname, &#39;dist&#39;),
    filename: &#39;bundle.js&#39;
  &#125;
&#125;</code></pre>
<h4 id="屬性介紹"><a href="#屬性介紹" class="headerlink" title="屬性介紹"></a>屬性介紹</h4><ul>
<li>mode：使用的模式。預設為 production，代表正式生產環境版本；開發使用 development 則不會進行壓縮</li>
<li>entry：是 bundle 的進入點，entry 是一個陣列。根據需求，webpack 允許可以有多個進入點，來產生多個 bundle 檔案。</li>
<li>output：宣告 webpack 輸出的形式<ul>
<li>path：存放 bundle 檔案的位置</li>
<li>filename：bundle 檔案名稱</li>
</ul>
</li>
</ul>
<h4 id="接著以打包-style-css-和-index-js-所需進行的設定為例："><a href="#接著以打包-style-css-和-index-js-所需進行的設定為例：" class="headerlink" title="接著以打包 style.css 和 index.js 所需進行的設定為例："></a>接著以打包 style.css 和 index.js 所需進行的設定為例：</h4><pre><code class="javascript=">const path = require(&#39;path&#39;);

module.exports = &#123;
  mode: &#39;&#39;,
  entry: &#39;./src/index.js&#39;,
  output: &#123;
    filename: &#39;main.js&#39;,    // 輸出檔案名稱
    path: path.resolve(__dirname, &#39;dist&#39;),　    // 輸出位置
  &#125;,
  // 載入 loader
  module: &#123;
    rules: [
      &#123;
        test: /\.css$/i,      // .css 結尾的檔案均使用 css-loader 解析
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;],
      &#125;,&#123;
        test: /\.m?js$/,      // .mjs 結尾的檔案均使用 babel-loader 解析
        exclude: /(node_modules|bower_components)/,
        use: &#123;
          loader: &#39;babel-loader&#39;,
          options: &#123;
            presets: [&#39;@babel/preset-env&#39;]
          &#125;
        &#125;
      &#125;
    ],
  &#125;,
&#125;;</code></pre>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmh1bGkudHcvMjAyMC8wMS8yMS93ZWJwYWNrLW5ld2JpZS10dXRvcmlhbC8=">webpack 新手教學之淺談模組化與 snowpack<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9uZWlnaGJvcmhvb2Q5OTkuZ2l0aHViLmlvL3dlYnBhY2stdHV0b3JpYWwtZ2l0Ym9vay9QYXJ0MS8=">Webpack 初學者教學課程Part1 · Webpack Tutorial 繁體中文<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2ktYW0tbWlrZS8lRTQlQkIlODAlRTklQkElQkMlRTYlOTglQUZ3ZWJwYWNrLSVFNCVCRCVBMCVFOSU5QyU4MCVFOCVBNiU4MXdlYnBhY2slRTUlOTclOEUtMmQ4Zjk2NTgyNDFk">Webpack教學 (一) ：什麼是Webpack? 能吃嗎？<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h3 id="總結：gulp-vs-webpack"><a href="#總結：gulp-vs-webpack" class="headerlink" title="總結：gulp vs webpack"></a>總結：gulp vs webpack</h3><h4 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h4><ul>
<li>是一套任務管理工具（task manager）</li>
<li>目的：提供自動化與流程管理，整合前端開發環境，藉由簡化工作量，可讓開發者將重點放在功能的開發上</li>
<li>功能：提供自訂任務流程，例如 babel、scss、壓縮、重新整理、校正時間等</li>
</ul>
<h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><ul>
<li>是一套模組整合工具（module bundler）</li>
<li>目的：利用模組化的概念，將各種資源打包成能在瀏覽器上執行的程式碼</li>
</ul>
<p>由此可知，兩者目標其實並不相同，但是均能夠達到部分功能，因此容易被混淆，例如：</p>
<ol>
<li>使用 Babel 將 ES6 編譯成 ES5 語法</li>
<li>將 SASS 檔編譯成 CSS 檔</li>
<li>壓縮 CSS, JS, 圖檔等</li>
</ol>
<p>簡言之，gulp 是用來管理任務，建構自動化流程的工具；而 Webpack 則是將資源打包，提供模組化開發方式。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRyZWFkMDEuY29tL2NvbnRlbnQvMTU1MDIyMTIxNi5odG1s">Gulp和webpack的區別，是一種工具嗎？<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>Front-End</tag>
        <tag>webpack</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 11] 資訊安全 - 雜湊與加密 &amp; 常見攻擊：SQL Injection、XSS</title>
    <url>/hash-security/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvYmUxMDEtcGhwLW15c3Fs">[BE101] 用 PHP 與 MySQL 學習後端基礎<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<p>相關筆記：</p>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMC9UaGlzLWlzLUNvZGVkaWFyeS9ibG9iL21hc3Rlci93ZWVrOV8lRTUlQkUlOEMlRTclQUIlQUYlRTUlOUYlQkElRTclQTQlOEVfUEhQJUUzJTgwJTgxTXlTUUwubWQ=">[week 9] 後端基礎 - PHP 語法、資料庫 MySQL<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMC9UaGlzLWlzLUNvZGVkaWFyeS9ibG9iL3dlZWsxMS93ZWVrOV8lRTUlODglQTklRTclOTQlQThQSFAlRTUlQUYlQTYlRTQlQkQlOUMlRTclOTUlOTklRTglQTglODAlRTYlOUQlQkYtJUU1JTg4JTlEJUU5JTlBJThFJUU1JUFGJUE2JUU0JUJEJTlDJUU3JUFGJTg3Lm1k">[week 9] 利用 PHP 實作留言板 - 初階實作篇<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<pre><code>學習目標：

P1 你知道什麼是雜湊（Hash function）
P1 你知道什麼是加密（Encryption）
P1 你知道雜湊與加密的差別
P1 你知道什麼是 SQL Injection 以及如何防範
P1 你知道什麼是 XSS 以及如何防範
P1 你知道為什麼儘管前端做了驗證，後端還是要再做一次驗證
P2 你知道什麼是 CSRF 以及如何防範</code></pre>
</li>
</ul>
<hr>
<h2 id="資訊安全"><a href="#資訊安全" class="headerlink" title="資訊安全"></a>資訊安全</h2><p>我們先前<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMC9UaGlzLWlzLUNvZGVkaWFyeS9ibG9iL21hc3Rlci93ZWVrOV8lRTUlODglQTklRTclOTQlQThQSFAlRTUlQUYlQTYlRTQlQkQlOUMlRTclOTUlOTklRTglQTglODAlRTYlOUQlQkYtJUU1JTg4JTlEJUU5JTlBJThFJUU1JUFGJUE2JUU0JUJEJTlDJUU3JUFGJTg3Lm1k">利用 PHP 實作的初階留言板<i class="fa fa-external-link-alt"></i></span>，其實暗藏許多安全性漏洞，接下來的重點，就是說明這些漏洞如何產生，以及該如何解決這些問題。</p>
<h2 id="用雜湊保護密碼"><a href="#用雜湊保護密碼" class="headerlink" title="用雜湊保護密碼"></a>用雜湊保護密碼</h2><p>當我們以「明文」方式將密碼存在資料庫時，可能面臨下列資安風險：</p>
<ul>
<li>網站管理者隨時能夠查看使用者帳密</li>
<li>如果有駭客成功入侵資料庫，即可竊取所有使用者資料</li>
</ul>
<p>因此我們需要透過「雜湊」來保護密碼。這也是為什麼，當我們忘記密碼時，網站會要我們重設密碼，而不是得到原先的密碼，因為雜湊不可逆，無法回推得到原碼。</p>
<h2 id="加密？雜湊？"><a href="#加密？雜湊？" class="headerlink" title="加密？雜湊？"></a>加密？雜湊？</h2><p>兩者最大差別在於：「加密可逆，雜湊不可逆」。</p>
<p><img src="https://i.imgur.com/ymLoNYw.png"></p>
<h3 id="加密（Encrypt）"><a href="#加密（Encrypt）" class="headerlink" title="加密（Encrypt）"></a>加密（Encrypt）</h3><ul>
<li>一對一，可逆</li>
<li>加密與解密必須要有金鑰（key）才能進行</li>
<li>對稱式加密<ul>
<li>常見演算法：AES、DES、3DES</li>
<li>加密解密都使用同一個 key，速度快，通常用於加密大量資料</li>
<li>資料傳輸前，雙方必須先講好密碼，不易日後管理，因此有了非對稱式加密</li>
</ul>
</li>
<li>非對稱式加密<ul>
<li>常見演算法：RSA、DSA、ECC</li>
<li>加密和解密使用不同的金鑰，速度慢，通常用於少量數據加密</li>
<li>一對金鑰由公鑰（可交給任何請求方）和私鑰（由一方保管）組成，可互相解密加密</li>
<li>可使用數位簽章（Digital Signature）確認是否為本人傳遞訊息，形成雙重保障</li>
</ul>
</li>
</ul>
<h3 id="雜湊（Hash）"><a href="#雜湊（Hash）" class="headerlink" title="雜湊（Hash）"></a>雜湊（Hash）</h3><ul>
<li>多對一，不可逆，因此可有效保護密碼</li>
<li>將<code>不定長度、無窮可能</code>的輸入，透過雜湊演算法，轉換成<code>固定長度</code>的雜湊值</li>
<li>雖然機率極低，但不同輸入可能產生相同的雜湊值，這種情形稱為碰撞（collision）</li>
<li>對伺服器來說，安全性越高的雜湊函數也代表速度越慢</li>
<li>用途：<ul>
<li>檔案校驗碼（Checksum）：檢查檔案是否正確</li>
<li>不需要被還原的資料：避免明文儲存密碼</li>
</ul>
</li>
<li>常見雜湊演算法<ul>
<li>MD5：已被證實不夠安全</li>
<li>SHA-1：已被證實不夠安全</li>
<li>SHA-256</li>
<li>RIPEMD-160</li>
</ul>
</li>
<li>常見攻擊方法<ul>
<li>暴力破解（brute-force）：嘗試所有數列組合，非常耗時</li>
<li>字典法（Dictionary Attacke）：嘗試常見的密碼組合，為主流方法</li>
<li>彩虹表（rainbow table）：類似暴力破解，使用預先計算的雜湊演算法，以查表方式破解</li>
</ul>
</li>
<li>解決方式：將密碼加鹽（salt）形成新的雜湊值，即可提高安全性<ul>
<li>例如：1234-(加鹽)→1234XXX</li>
</ul>
</li>
</ul>
<h3 id="PHP-內建雜湊函式：password-hash"><a href="#PHP-內建雜湊函式：password-hash" class="headerlink" title="PHP 內建雜湊函式：password_hash()"></a>PHP 內建雜湊函式：<code>password_hash()</code></h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24ucGFzc3dvcmQtaGFzaC5waHA=">PHP 提供內建函式 <i class="fa fa-external-link-alt"></i></span><code>password_hash()</code> 能夠實現加密， 指令如下：</p>
<pre><code class="php"> &lt;?php
$hash = password_hash(&quot;要加密的字串&quot;, PASSWORD_DEFAULT);
?&gt;</code></pre>
<p>驗證指令：<code>password_verify(&quot;要驗證的字串&quot;, &quot;加密過的字串&quot;)</code>，會回傳一個 boolean</p>
<pre><code class="php=">// 使用範例
&lt;?php 
$password = &#39;1234&#39;;    // 原始密碼
$hash_password = password_hash($password, PASSWORD_DEFAULT);

if (password_verify($password , $hash_password))&#123;
  echo &quot;密碼正確&quot;;  // true
&#125; else &#123;
  echo &quot;密碼錯誤&quot;;  // false
&#125;
?&gt; </code></pre>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly90aW55dXJsLmNvbS95NjVwZ280dw==">[資訊安全] 密碼存明碼，怎麼不直接去裸奔算了？淺談 Hash , 用雜湊保護密碼<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3N0YXJidWdzL3doYXQtYXJlLWVuY29kaW5nLWVuY3J5cHQtYW5kLWhhc2hpbmctNGIwM2Q0MGU3YjBj">一次搞懂密碼學中的三兄弟 — Encode、Encrypt 跟 Hash<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm0xNTdxLnR3L3Bvc3RzLzIwMTcvMTIvMjUvZGlmZmVyZW5jZXMtYmV0d2Vlbi1lbmNyeXB0aW9uLWFuZC1oYXNoaW5nLw==">加密和雜湊有什麼不一樣？ | Just for noting<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hZG9uOTg4LmxvZ2Rvd24uY29tL3Bvc3RzLzI1MTM2MjMtbW9kZXJuLXBocC1wYXNzd29yZC1oYXNoLWhhc2gtZW5jcnlwdGlvbi11c2luZy1yYW5kb20tc2FsdC11c2Vz">現代PHP password_hash 雜湊加密採用隨機SALT 使用方式<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9waHAvcGhwLXBhc3N3b3JkX2hhc2guaHRtbA==">PHP password_hash() 函数| 菜鸟教程<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h2 id="常見資安攻擊"><a href="#常見資安攻擊" class="headerlink" title="常見資安攻擊"></a>常見資安攻擊</h2><p>以下介紹幾種常見的資安攻擊，其原理與防範方法。</p>
<h2 id="SQL-injection"><a href="#SQL-injection" class="headerlink" title="SQL injection"></a>SQL injection</h2><p>是一種注入式攻擊。發生於應用程式與資料庫層的安全漏洞。</p>
<h3 id="攻擊原理"><a href="#攻擊原理" class="headerlink" title="攻擊原理"></a>攻擊原理</h3><p>在輸入資料時，夾帶不正當的 SQL 指令，若網頁忽略字元檢查，資料庫將會視為正常的 SQL 指令並執行惡意程式碼，進而破壞或入侵。</p>
<h4 id="以輸入帳號密碼進行驗證為例："><a href="#以輸入帳號密碼進行驗證為例：" class="headerlink" title="以輸入帳號密碼進行驗證為例："></a>以輸入帳號密碼進行驗證為例：</h4><ul>
<li><p>正常的 SQL 語法</p>
<ul>
<li>帳號：123</li>
<li>密碼：456<pre><code class="php=">SELECT * FROM users WHERE username=&#39;123&#39; AND password=&#39;456&#39;;</code></pre>
</li>
</ul>
</li>
<li><p>SQL injection</p>
<ul>
<li>帳號：<code>&#39; or 1=1#</code></li>
<li>密碼：可輸入任意值（甚至不需輸入）<pre><code class="php=">SELECT * FROM users WHERE username=&#39;&#39; or 1=1# AND password=&#39;&#39;;</code></pre>
</li>
</ul>
</li>
<li><p><code>&#39;</code>：將 username 的 input 關閉</p>
</li>
<li><p><code>or</code>：條件式的「或是」</p>
</li>
<li><p><code>#</code>：代表註解，後面的條件均會被忽略</p>
</li>
<li><p>由於 <code>WHERE</code> 條件式中的 <code>1=1</code> 恆正，如此即可略過權限檢查，沒有密碼也能成功登入帳號</p>
</li>
</ul>
<h4 id="以之前實作的初階留言版為例："><a href="#以之前實作的初階留言版為例：" class="headerlink" title="以之前實作的初階留言版為例："></a>以之前實作的初階留言版為例：</h4><ol>
<li>登入後在新增留言輸入：<code>&#39;), (&#39;admin&#39;, &#39;Hacking!&#39;)#</code></li>
<li>SQL 指令就變成：<pre><code class="php=">INSERT INTO comments(nickname, content)
VALUES(&#39;aaa&#39;, &#39;&#39;), (&#39;admin&#39;, &#39;Hacking!&#39;)#</code></pre>
</li>
<li>執行後會新增兩筆留言，nickname 分別是 aaa 和 admin</li>
</ol>
<p><img src="https://i.imgur.com/zLfxN7g.png"></p>
<h3 id="防範方法：Prepare-Statement-預處理"><a href="#防範方法：Prepare-Statement-預處理" class="headerlink" title="防範方法：Prepare Statement 預處理"></a>防範方法：Prepare Statement 預處理</h3><p>透過 Prepare Statement 進行跳脫，以防止 SQL 注入。</p>
<p>步驟如下：</p>
<ol>
<li>將 SQL 語法儲存在變數 <code>$sql</code></li>
<li>使用 <code>prepare()</code> 預處理 <code>$sql</code>：此時只傳送佔位符號 <code>?</code>，可避免利用拼接 SQL 字串語句的攻擊</li>
<li>使用 <code>bind_param()</code> 帶入參數。常用參數類型：<ul>
<li><code>s</code>：string（字串）</li>
<li><code>i</code>：integer（整數）</li>
</ul>
</li>
<li>呼叫 <code>execute()</code> 執行 SQL 語法：此時才會將參數傳送給資料庫</li>
<li>若執行成功，則使用 <code>get_result()</code> 取出執行結果</li>
</ol>
<p>程式碼範例：</p>
<pre><code class="php=">&lt;?php
  // SQL 語法
  $sql = &quot;INSERT INTO comments(nickname, content) VALUES(?, ?)&quot;;
  // prepare() 預處理 
  $stmt = $conn-&gt;prepare($sql);
  // bind_param() 帶入參數
  $stmt-&gt;bind_param(&#39;ss&#39;, $nickname, $content);
  // execute() 執行 SQL 語法
  $result = $stmt-&gt;execute();
  // 確認是否執行成功
  if (!$result) &#123;
    die($conn-&gt;error);
  // 取出執行結果
  $result = $stmt-&gt;get_result();
&#125;</code></pre>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDE4OTIwMQ==">[Postx1] 攻擊行為－SQL 資料隱碼攻擊 SQL injection<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlcnR3LmNvbS8lRTclQTglOEIlRTUlQkMlOEYlRTglQUElOUUlRTglQTglODAvMjQwODA4Lw==">Php中用PDO查詢Mysql來避免SQL隱碼攻擊風險的方法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRyZWFkMDEuY29tL3AvMTQwMzMyNC5odG1s">PreparedStatement 如何防止SQL注入<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h2 id="XSS-攻擊"><a href="#XSS-攻擊" class="headerlink" title="XSS 攻擊"></a>XSS 攻擊</h2><p>全名是 Cross Site Scripting（跨網站指令碼攻擊），為了不與 CSS 混淆，故簡稱 XSS。</p>
<p>是一種注入式攻擊。通常是透過 JavaScript 或 HTML，因此又被稱作 JavaScript Injection 攻擊。</p>
<h3 id="攻擊原理-1"><a href="#攻擊原理-1" class="headerlink" title="攻擊原理"></a>攻擊原理</h3><p>攻擊者利用網頁開發時留下的安全漏洞，在網頁插入惡意程式碼，讓使用者載入並執行惡意程式，攻擊者可藉此取得更高的權限，或是竊取使用者的 Cookie 等資料。</p>
<p>XSS 常見的攻擊種類大致上可分為兩種：</p>
<ul>
<li>Reflected XSS（反射型）</li>
</ul>
<p><img src="https://i.imgur.com/zNQGEPN.png"></p>
<p>以網頁輸入欄位為例。若在輸入欄位內刻意植入 Javascript 語法，例如下列程式碼，即可竊取使用者的 cookie 資料：</p>
<pre><code class="=">&lt;script&gt;alert(document.cookie)；&lt;/script&gt;</code></pre>
<ul>
<li>Stored XSS（儲存型）</li>
</ul>
<p><img src="https://i.imgur.com/A5qvwBe.png"></p>
<p>以留言板為例。攻擊者將惡意程式碼透過「新增留言」寫入資料庫，當使用者瀏覽到該頁面時，就會觸發程式碼，達到攻擊目的。</p>
<h3 id="防範方法：過濾特殊字元"><a href="#防範方法：過濾特殊字元" class="headerlink" title="防範方法：過濾特殊字元"></a>防範方法：過濾特殊字元</h3><p>責任主要還是歸咎於網頁開發時留下的安全漏洞，但 Server 端與 Client 端可以藉由下列方法，來避免遭受攻擊：</p>
<h4 id="Client-端"><a href="#Client-端" class="headerlink" title="Client 端"></a>Client 端</h4><ol>
<li>定期更新瀏覽器至最新版本</li>
<li>避免點擊來路不明的網址</li>
</ol>
<h4 id="Server-端"><a href="#Server-端" class="headerlink" title="Server 端"></a>Server 端</h4><ol>
<li>過濾特殊字元：過濾所有 Client 端提供的內容，並轉譯成純文字。例如：使用 PHP 內建函式 <code>htmlentities（）</code>或 <code>htmlspecialchars（）</code></li>
</ol>
<pre><code class="php=">&lt;?php
// utils.php
  function escape($str) &#123;
    return htmlspecialchars($str, ENT_QUOTES, &#39;UTF-8&#39;);
  &#125;
?&gt;</code></pre>
<ol start="2">
<li>限制輸入內容長度或型態。雖然可藉由引入外部 JavaScript 來繞過，但還是能提高 XSS 攻擊難度</li>
</ol>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbXMuYWFhc2VjLmNvbS50dy9pbmRleC5waHAvMjAxOC8wOS8yMS9jb2RlLWluamVjdGlvbi1hdHRhY2stY3Jvc3Mtc2l0ZS1zY3JpcHRpbmctYXR0YWNrLw==">Code Injection Attack – Cross-Site Scripting Attack – 三甲科技<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRyZWFkMDEuY29tL2NvbnRlbnQvMTU0NDU3NTE0OS5odG1s">前端安全系列（一）：如何防止XSS攻擊？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDE4ODY0Ng==">[Day24] 攻擊行為－反射式跨網站指令碼 Reflected XSS<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>全名是  Cross Site Request Forgery（跨站請求偽造）。也被稱為 one-click attack 或 session riding。</p>
<p>和 XSS 同樣是跨站式的請求攻擊，兩者卻有明顯區別，不同之處在於：</p>
<ul>
<li>XSS：透過在網頁輸入惡意程式碼的方式來進行攻擊<ul>
<li>使用者對目標網站的信任</li>
</ul>
</li>
<li>CSRF：攻擊者利用網站使用者的身分發送請求，去執行一些未經授權的操作<ul>
<li>目標網站對該使用者的信任</li>
</ul>
</li>
</ul>
<h3 id="攻擊原理-2"><a href="#攻擊原理-2" class="headerlink" title="攻擊原理"></a>攻擊原理</h3><p>要完成一個 CRSF 攻擊，必須條件是「使用者仍保持登入狀態」。</p>
<p>假設 A 為目標網站，B 為惡意網站，步驟大致如下：</p>
<ol>
<li>使用者登入網站 A</li>
<li>網站 A 返回 session id 等資訊（使用 cookie 儲存）</li>
<li>使用者訪問網站 B，攻擊者利用隱藏圖片或表單，讓使用者在不知情的情況發送 request 到網站 A</li>
<li>由於瀏覽器的機制，發送 request 給某個網域時，會附帶關聯的 cookie</li>
<li>網站 A 誤以為是合法請求，攻擊者即可假冒使用者身分進行操作</li>
</ol>
<p>簡言之，CSRF 就是「在不同 domain 下，偽造使用者本人發出的 request」。</p>
<h3 id="防範方法"><a href="#防範方法" class="headerlink" title="防範方法"></a>防範方法</h3><h4 id="Client-端-1"><a href="#Client-端-1" class="headerlink" title="Client 端"></a>Client 端</h4><p>由於 CSRF 攻擊的必要條件，是使用者在被攻擊的網頁處於「已登入狀態」。使用者在每次使用完網站就登出，即可避免 CSRF 攻擊。</p>
<h4 id="Server-端-1"><a href="#Server-端-1" class="headerlink" title="Server 端"></a>Server 端</h4><ol>
<li>加上圖形驗證碼（或簡訊驗證碼等）</li>
</ol>
<p>在網站加上驗證碼，可多一道檢查程序，常用於金流相關操作。</p>
<ul>
<li>缺點：每次都要進行驗證，可能造成使用者體驗不佳</li>
</ul>
<ol start="2">
<li>加上 CSRF token</li>
</ol>
<ul>
<li>產生：Server</li>
<li>儲存：Server</li>
</ul>
<p>在 <code>form</code> 裡面加上一個 <code>hidden</code> 的欄位，叫做 <code>csrftoken</code>，填入的值為 Server 隨機產生的亂碼，並且存在 Server 的 session 中。</p>
<p>按下 submit 後，Server 會比對表單中的 csrftoken 與存在 Server 端的是否相同。</p>
<pre><code class="php=">// 範例程式碼
&lt;form action=&quot;https://myblog.com/delete&quot; method=&quot;POST&quot;&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;3&quot;/&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;&lt;亂碼&gt;&quot;/&gt;
  &lt;input type=&quot;submit&quot; value=&quot;刪除文章&quot;/&gt;
&lt;/form&gt;</code></pre>
<ul>
<li>缺點：若攻擊者先發出 request，還是能取得 csrftoken 來攻擊目標網站</li>
</ul>
<ol start="3">
<li>Double Submit Cookie</li>
</ol>
<ul>
<li>產生：Server</li>
<li>儲存：Client</li>
</ul>
<p>與前一種解法相似，好處是不需要存任何東西在 Server 端。</p>
<p>而是在 cookie 與 form 設置相同的 csrftoken，利用「cookie 只會從相同 domain 帶上來」機制，使攻擊者無法從不同 domain 戴上此 cookie。</p>
<pre><code class="php=">// 範例程式碼
Set-Cookie: csrftoken=&lt;亂碼&gt;

&lt;form action=&quot;https://myblog.com/delete&quot; method=&quot;POST&quot;&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;3&quot;/&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;&lt;亂碼&gt;&quot;/&gt;
  &lt;input type=&quot;submit&quot; value=&quot;刪除文章&quot;/&gt;
&lt;/form&gt;</code></pre>
<ul>
<li>缺點：攻擊者若掌握使用者底下任何一個 subdomain，就能夠幫使用者寫 cookie，藉此進行攻擊</li>
</ul>
<ol start="4">
<li>Client 端生成的 Double Submit Cookie</li>
</ol>
<ul>
<li>產生：Client</li>
<li>儲存：Client</li>
</ul>
<p>和前面提的 Double Submit Cookie 核心概念相同。不同之處在於「改由 Client 端」生成 csrf token。</p>
<p>生成之後放到 form 裡面以及寫到 cookie，其他流程就和之前相同。<br>此 cookie 只是確保攻擊者無法取得，不含任何資訊，因此由 Client 或 Server 生成都是一樣的。</p>
<ul>
<li>例如：library axios 就有提供此功能。只要設定好 header 與 cookie 名稱，設定好之後的每一個 request，即可自動在 header 統一加上 cookie 值</li>
</ul>
<pre><code class="php=">// 範例程式碼
// `xsrfCookieName` is the name of the cookie to use as a value for xsrf token
xsrfCookieName: &#39;XSRF-TOKEN&#39;, // default

// `xsrfHeaderName` is the name of the http header that carries the xsrf token value
xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, // default</code></pre>
<h4 id="瀏覽器端的防禦：SameSite-cookie"><a href="#瀏覽器端的防禦：SameSite-cookie" class="headerlink" title="瀏覽器端的防禦：SameSite cookie"></a>瀏覽器端的防禦：SameSite cookie</h4><p>CSRF 之所以能夠成立，是瀏覽器的機制所導致，但我們也能從瀏覽器著手進行防禦，也就是透過 SameSite cookie。其原理是「幫 Cookie 再加上一層驗證」，防止來自不同 domain 的請求。</p>
<p>做法是在 Set-cookie 的 session_id 後加上 SameSite 即可啟用此功能。由於這是較新的功能，目前瀏覽器中只有 Chrome 支援，使用前須注意。</p>
<p>使用範例如下：</p>
<pre><code class="php=">Set-Cookie: session_id=&lt;亂碼&gt;; SameSite</code></pre>
<p>SameSite 有分 Strict（預設）與 Lax 兩種模式：</p>
<ul>
<li>Strict 模式（嚴格）<ul>
<li>使用 <code>&lt;a href=&quot;&quot;&gt;</code>, <code>&lt;form&gt;</code>, <code>new XMLHttpRequest</code> 等標籤</li>
<li>只要瀏覽器驗證不是同一個 domain 發出的 request，就不會帶上此 cookie</li>
<li>由於連結不會帶上 cookie，對於使用者體驗並不佳</li>
</ul>
</li>
<li>Lax 模式（寬鬆）<ul>
<li>上述標籤都還是會帶上 cookie</li>
<li>除了 Get 刑事，其他方法如 POST、DELETE、PUT 等都不會帶上 cookie</li>
<li>意即 Lax 模式無法擋掉 GET 形式的 CSRF</li>
</ul>
</li>
</ul>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRlY2hicmlkZ2UuY2MvMjAxNy8wMi8yNS9jc3JmLWludHJvZHVjdGlvbi8=">讓我們來談談CSRF - TechBridge 技術共筆部落格<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jeXJpbHdhbmcucGl4bmV0Lm5ldC9ibG9nL3Bvc3QvMzE4MTM1NjgtJTVCJUU2JThBJTgwJUU4JUExJTkzJUU1JTg4JTg2JUU0JUJBJUFCJTVELWNyb3NzLXNpdGUtcmVxdWVzdC1mb3JnZXJ5LShwYXJ0LTEp">[技術分享] Cross-site Request Forgery (Part 1)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly95YWtpbWhzdS5jb20vcHJvamVjdC9wcm9qZWN0X3cxMl9JbmZvX1NlY3VyaXR5LUNTUkYuaHRtbA==">[第十二週] 資訊安全 - 常見攻擊：CSRF<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlcnR3LmNvbS8lRTclQTglOEIlRTUlQkMlOEYlRTglQUElOUUlRTglQTglODAvMTA5Nzc1Lw==">程式猿必讀-防範CSRF跨站請求偽造<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>Back-End</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>【學習筆記】hexo-admin：Hexo 後台管理工具</title>
    <url>/hexo-admin/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/T1CHqyf.png"></p>
<p>在上篇<a href="https://heidiliu2020.github.io/2020/11/07/202011-hexo-github/">【學習筆記】如何使用 Hexo + GitHub Pages 架設個人網誌</a>中，我們學會如何打造簡單的個人網誌後，再來要介紹如何透過 hexo-admin 這個套件，以更直觀的方式在後台管理網誌文章。</p>
<a id="more"></a>

<h2 id="為什麼需要-hexo-admin？"><a href="#為什麼需要-hexo-admin？" class="headerlink" title="為什麼需要 hexo-admin？"></a>為什麼需要 hexo-admin？</h2><p>在上篇文章介紹到，要在網誌發布文章，必須透過 CLI 介面以 <code>hexo new</code> 指令新增文章，再利用 <code>hexo g -d</code> 生成並部署。</p>
<p>透過 hexo-admin 這套插件，我們就能透過 GUI 介面進行後台管理，例如編輯原有的 markdown 文件，也可以新增文章或頁面、發布草稿和提供預覽功能等等，在操作上簡化了發布文章的流程。</p>
<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><blockquote>
<p>詳細可參考文件說明：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phcmVkbHkvaGV4by1hZG1pbg==">jaredly/hexo-admin<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ol>
<li>首先進入本地端存放 hexo 專案的資料夾</li>
<li>在終端機輸入安裝指令</li>
</ol>
<pre><code>$ npm install --save hexo-admin</code></pre>
<h2 id="進入-hexo-admin-後台"><a href="#進入-hexo-admin-後台" class="headerlink" title="進入 hexo-admin 後台"></a>進入 hexo-admin 後台</h2><p>安裝完成之後，就可以進入後台管理，步驟如下：</p>
<ol>
<li>架設本地端伺服器</li>
</ol>
<pre><code>$ hexo server -d
// 或簡化成
$ hexo s</code></pre>
<p>看到下方提示就代表運行成功：</p>
<p><img src="https://i.imgur.com/zXT8P5C.png"></p>
<ol start="2">
<li>在瀏覽器輸入 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAwLw==">http://localhost:4000<i class="fa fa-external-link-alt"></i></span> 可以預覽發布前的網誌</li>
<li>進入 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAwL2FkbWlu">http://localhost:4000/admin<i class="fa fa-external-link-alt"></i></span> 可進入後台管理，在 Posts 可看到文章列表：</li>
</ol>
<p><img src="https://i.imgur.com/ZGKnhui.png"></p>
<p>在 Pages 可編輯其他頁面：</p>
<p><img src="https://i.imgur.com/UWJr7PU.png"></p>
<h2 id="新增文章-Publish"><a href="#新增文章-Publish" class="headerlink" title="新增文章 Publish"></a>新增文章 Publish</h2><ol>
<li>點選左上角的 New Post，可輸入該文章的網址名稱，接著打勾或按 Enter：</li>
</ol>
<p><img src="https://i.imgur.com/fMCYDdW.png"></p>
<ol start="2">
<li>就會進入編輯頁面，可在標題列編輯文章標題，標題下方則是文章網址，左邊區塊可編輯 Markdown 文章內容，右方區塊則是預覽文章</li>
</ol>
<p><img src="https://i.imgur.com/190UBSx.png"></p>
<ol start="3">
<li>編輯完成後，可點選 Publish 左側的設定，修改發布文章時間、標籤、分類，確認都沒問題後，即可點選 Publish 發布文章</li>
</ol>
<p><img src="https://i.imgur.com/BBUAMBO.png"></p>
<ol start="4">
<li>回到 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAwLw==">http://localhost:4000<i class="fa fa-external-link-alt"></i></span> 即可看到剛才新增的文章</li>
</ol>
<p><img src="https://i.imgur.com/Jezhv4m.png"></p>
<h3 id="補充：Read-more-功能"><a href="#補充：Read-more-功能" class="headerlink" title="補充：Read more 功能"></a>補充：Read more 功能</h3><p>在上方編輯模式中，可以看到 <code>&lt;!--more--&gt;</code> 這行程式碼，在這行以下的內容就會自動被隱藏，會多一個閱讀全文（Read more）的連結，必須點擊文章才會看到全文。</p>
<h2 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h2><p>確認文章都沒問題之後，就可以準備部署到 GitHub 上，步驟如下：</p>
<ol>
<li>在終端機按 Ctrl+C，可停止本地端伺服器</li>
</ol>
<p><img src="https://i.imgur.com/BXhBwiC.png"></p>
<ol start="2">
<li>輸入下方三個指令進行部署</li>
</ol>
<ul>
<li>hexo clean：清除之前建立的靜態檔案</li>
<li>hexo generate：建立靜態檔案</li>
<li>hexo deploy：部署到 Github Pages</li>
</ul>
<p>也可以簡寫成：</p>
<pre><code>$ hexo cl
$ hexo g
$ hexo d</code></pre>
<p>這樣就成功透過 hexo-admin 管理後台文章！</p>
<h2 id="心得記錄"><a href="#心得記錄" class="headerlink" title="心得記錄"></a>心得記錄</h2><p>其實上次在搬運筆記的時候，就已經有使用 hexo-admin 這套工具，卻沒想到過一段時間後，還是會忘記該如何操作，於是乎乾脆寫成一篇文章，之後也可以回來複習。</p>
<p>金魚腦如我，果然還是不能沒有學習筆記XD</p>
<p>參考文章：<span class="exturl" data-url="aHR0cHM6Ly9lZDUyMS5naXRodWIuaW8vMjAxOS8wOC9oZXhvLWFkbWluLw==">[教學] 我的第一篇 Hexo 文章：使用 hexo-admin 後台管理工具<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>hexo-admin</tag>
      </tags>
  </entry>
  <entry>
    <title>【學習筆記】如何使用 Hexo + GitHub Pages 架設個人網誌</title>
    <url>/hexo-github/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/dOOM0JO.png"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇主要介紹如何使用 Hexo 並搭配 GitHub 來快速架設網誌。從介紹什麼是 Hexo 框架，該如何安裝、建立環境，接著介紹一些常用指令，以及如何部署到 GitHub 上。</p>
<a id="more"></a>
<p>文章可分為下列幾個部分：</p>
<ul>
<li>什麼是 Hexo？</li>
<li>前置作業<ul>
<li>安裝需求</li>
</ul>
</li>
<li>Hexo 環境建置</li>
<li>常用指令</li>
<li>部署到 GitHub<ul>
<li>建立 GitHub 專案</li>
<li>將檔案發布到 GitHub </li>
</ul>
</li>
</ul>
<h2 id="什麼是-Hexo？"><a href="#什麼是-Hexo？" class="headerlink" title="什麼是 Hexo？"></a>什麼是 Hexo？</h2><blockquote>
<p>引用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhv">官網介紹<i class="fa fa-external-link-alt"></i></span>：A fast, simple &amp; powerful blog framework, powered by Node.js.</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLXR3Lw==">Hexo<i class="fa fa-external-link-alt"></i></span> 其實就是一個基於 Node.js 開發的網誌框架，具有下列幾項特點：</p>
<ul>
<li>編譯速度非常快</li>
<li>能夠支援 Markdown 語法解析文章，並透過主題渲染靜態檔案</li>
<li>具有豐富的外掛套件</li>
<li>支援一鍵部署到 GitHub Pages 或 Heroku 等支援靜態網頁的空間</li>
</ul>
<h2 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h2><h3 id="安裝需求"><a href="#安裝需求" class="headerlink" title="安裝需求"></a>安裝需求</h3><p>在開始安裝 Hexo 之前，必須先在電腦安裝下列工具：</p>
<ul>
<li><h4 id="Node-js：提供-npm-來安裝所需的套件。這裡可選擇安裝左側-14-15-0-LTS-版本"><a href="#Node-js：提供-npm-來安裝所需的套件。這裡可選擇安裝左側-14-15-0-LTS-版本" class="headerlink" title="Node.js：提供 npm 來安裝所需的套件。這裡可選擇安裝左側 14.15.0 LTS 版本"></a><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">Node.js<i class="fa fa-external-link-alt"></i></span>：提供 npm 來安裝所需的套件。這裡可選擇安裝左側 14.15.0 LTS 版本</h4></li>
</ul>
<blockquote>
<p>Hexo 官網建議使用 Node.js 10.0 及以上版本，若不確定下載哪個版本，可在終端機輸入 <code>npm versin</code> 查看版本號。</p>
</blockquote>
<p><img src="https://i.imgur.com/JEdBf4y.png"></p>
<ul>
<li><h4 id="Git：用來將檔案發布到-GitHub-Page"><a href="#Git：用來將檔案發布到-GitHub-Page" class="headerlink" title="Git：用來將檔案發布到 GitHub Page"></a><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS8=">Git<i class="fa fa-external-link-alt"></i></span>：用來將檔案發布到 GitHub Page</h4></li>
</ul>
<blockquote>
<p>Git 基礎用法可參考：<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWdpdA==">版本控制 - Git 概念 ＆ 基本指令<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><img src="https://i.imgur.com/drhF9RQ.png"></p>
<blockquote>
<p>[補充] <span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWdpdC1hbmQtZ2l0aHVi">Git 和 GitHub 的差別？<i class="fa fa-external-link-alt"></i></span><br>Git 是用來版本控制的程式；GitHub 則是提供存放 Git Repository 的服務，讓使用者能在視覺化界面進行管理。</p>
</blockquote>
<h2 id="Hexo-環境建置"><a href="#Hexo-環境建置" class="headerlink" title="Hexo 環境建置"></a>Hexo 環境建置</h2><p>完成前置作業後，接著就要來建立 Hexo 環境，步驟如下：</p>
<blockquote>
<p>若對 CLI 不熟悉，可參考：<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWNsaQ==">Command Line 入門 &amp; 基本指令<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="Step1-安裝-Hexo"><a href="#Step1-安裝-Hexo" class="headerlink" title="Step1. 安裝 Hexo"></a>Step1. 安裝 Hexo</h3><p><img src="https://i.imgur.com/3162t1b.png"></p>
<p>開啟 CLI 介面（例如 cmd、git-bash 等終端機），並輸入下列指令安裝 Hexo：</p>
<pre><code>$ npm install hexo-cli -g</code></pre>
<p><img src="https://i.imgur.com/20qI9yU.png"></p>
<p>安裝完後，可輸入 <code>hexo version</code> 或 <code>hexo -v</code> 查看 Hexo 版本，確認是否有安裝成功：</p>
<p><img src="https://i.imgur.com/PRFQNVz.png"></p>
<h3 id="Step2-初始化-Hexo"><a href="#Step2-初始化-Hexo" class="headerlink" title="Step2. 初始化 Hexo"></a>Step2. 初始化 Hexo</h3><p>接著要初始化 Hexo，這裡有兩種做法：</p>
<ol>
<li>直接輸入下面指令，會自動於所在目錄建立一個新資料夾以操作 Hexo。記得將括號內修改成自己的資料夾名稱，若不指定資料夾名稱，則會直接初始化當前目錄：</li>
</ol>
<pre><code>$ hexo init &lt;資料夾名稱&gt;</code></pre>
<p><img src="https://i.imgur.com/tPOIIKP.png"></p>
<ol start="2">
<li>也可以先建立好資料夾，並在該資料夾輸入上述指令，同樣能進行初始化。可使用 cd 指令來切換路徑：</li>
</ol>
<pre><code>$ cd &lt;資料夾名稱 or 資料夾路徑&gt;</code></pre>
<p><img src="https://i.imgur.com/t1vVcEC.png"></p>
<h3 id="Step3-在資料夾安裝所需檔案"><a href="#Step3-在資料夾安裝所需檔案" class="headerlink" title="Step3. 在資料夾安裝所需檔案"></a>Step3. 在資料夾安裝所需檔案</h3><p>確認 CLI 上的路徑是在資料夾中，接著執行下列指令，安裝所需的 npm 套件：</p>
<pre><code>$ npm install</code></pre>
<blockquote>
<p>也可以直接在資料夾目錄輸入 cmd，按下 enter 後就會在這個路徑開啟終端機。</p>
</blockquote>
<p>安裝完成後，進入資料夾會看到下方這些檔案和資料夾：</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes</code></pre>
<h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><ul>
<li>有關網站配置的檔案，可修改各種配置設定。例如：網站標題、網站的網址、使用主題名稱等等</li>
<li>詳細內容可以參考<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLXR3L2RvY3MvY29uZmlndXJhdGlvbg==">官方文件<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>記錄所有載入的應用程式資料，也就是專案中需要的所有模組。</p>
<h4 id="scaffolds-模板"><a href="#scaffolds-模板" class="headerlink" title="scaffolds 模板"></a>scaffolds 模板</h4><ul>
<li>當我們建立新文章時，Hexo 會根據 scaffolds 中的模板建立相對應的檔案</li>
<li>資料夾中有三種預設<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLXR3L2RvY3Mvd3JpdGluZy5odG1s">佈局<i class="fa fa-external-link-alt"></i></span>：post、page 和 draft，分別對應：要發布的文章、頁面、草稿</li>
</ul>
<h4 id="themes-主題"><a href="#themes-主題" class="headerlink" title="themes 主題"></a>themes 主題</h4><ul>
<li>用來存放主題的資料夾</li>
<li>Hexo 會根據主題來解析 scouce 資料夾中的檔案並產生靜態頁面。預設主題為 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLXRoZW1lLWxhbmRzY2FwZQ==">landscape<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h4 id="source-資源"><a href="#source-資源" class="headerlink" title="source 資源"></a>source 資源</h4><ul>
<li>用來存放原始檔案的地方，例如 Markdown 檔、圖片、各種頁面（分頁、關於等）</li>
<li>通常資料夾命名開頭會加上底線 <code>_</code>，例如 <code>_imgs</code></li>
<li>以 <code>_</code> 開頭的檔案、資料夾或隱藏檔案會被忽略，除了 <code>_posts</code> 資料夾以外</li>
<li>Markdown 檔和 HTML 檔會被解析，並放到 public 資料夾，而其他檔案則會被拷貝過去</li>
</ul>
<h4 id="source-amp-public-amp-deploy-git-的差別"><a href="#source-amp-public-amp-deploy-git-的差別" class="headerlink" title="source &amp; public &amp; .deploy_git 的差別"></a>source &amp; public &amp; .deploy_git 的差別</h4><ul>
<li>執行 <code>$ hexo generate</code> 之後，會將 scorce 文件夾中的 Markdown 檔和 HTML 檔進行解析，再結合主題進行渲染，生成我們看到的靜態網站</li>
<li>執行 <code>$ hexo deploy</code> 之後，則會將 public 文件夾中的內容部署到 GitHub，並生成 .deploy_git 資料夾，因此內容與 public 幾乎相同</li>
<li>這三者的關係可想成：</li>
</ul>
<pre><code>source -&gt; public -&gt; .deploy_git</code></pre>
<hr>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>接著介紹一些 Hexo 常會用到的相關指令語法，更多詳細指令可參考<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLXR3L2RvY3MvY29tbWFuZHM=">官方文件<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="new-新增文章"><a href="#new-新增文章" class="headerlink" title="new 新增文章"></a>new 新增文章</h3><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre>
<ul>
<li>如果沒有設定 layout，則會使用 _config.yml 中的 default_layout 來設定</li>
<li>如果標題有包含空格，需使用引號括住：<code>&quot;title&quot;</code></li>
<li>接著可直接到 <code>/source/_posts/title.md</code> 中編輯文章內容</li>
</ul>
<blockquote>
<p>若是對 Markdown 相關語法不熟悉，可參考這篇筆記：<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLW1hcmtkb3du">Markdown 格式介紹<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="clean-清除靜態檔案與快取"><a href="#clean-清除靜態檔案與快取" class="headerlink" title="clean 清除靜態檔案與快取"></a>clean 清除靜態檔案與快取</h3><pre><code>$ hexo clean</code></pre>
<p>在每次儲存修正後的檔案之前，會建議先輸入此指令，清除快取檔案 （db.json）和已產生的靜態檔案（public）。</p>
<h3 id="generate-產生靜態檔案"><a href="#generate-產生靜態檔案" class="headerlink" title="generate 產生靜態檔案"></a>generate 產生靜態檔案</h3><pre><code>$ hexo generate</code></pre>
<p>可簡寫成 <code>hexo g</code>，生成靜態檔案。</p>
<h3 id="server-啟動伺服器"><a href="#server-啟動伺服器" class="headerlink" title="server 啟動伺服器"></a>server 啟動伺服器</h3><ul>
<li>在本地端啟動 Hexo 伺服器，預設路徑為：<code>http://localhost:4000/</code></li>
<li>可在自己電腦上預覽設定結果，按 Ctrl + C 即可關閉<blockquote>
<p>localhost：代表只能從本地瀏覽此網站，無法從外部瀏覽</p>
</blockquote>
</li>
</ul>
<pre><code>$ hexo server</code></pre>
<p><img src="https://i.imgur.com/JUHZ8Lw.png"></p>
<h2 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h2><h3 id="建立-GitHub-專案"><a href="#建立-GitHub-專案" class="headerlink" title="建立 GitHub 專案"></a>建立 GitHub 專案</h3><p>在架設網誌之前，還必須準備一個存放網站的空間，例如架設主機，或是選擇現有的平台，例如 GitHub Pages 或 Heroku 等，本篇以 GitHub 作為範例。</p>
<p>接著可依照下列步驟在 GitHub 新增專案：</p>
<h4 id="Step1-註冊-GitHub-帳號並登入"><a href="#Step1-註冊-GitHub-帳號並登入" class="headerlink" title="Step1. 註冊 GitHub 帳號並登入"></a>Step1. 註冊 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==">GitHub<i class="fa fa-external-link-alt"></i></span> 帳號並登入</h4><h4 id="Step2-點選-New-新增一個-Repository（專案）"><a href="#Step2-點選-New-新增一個-Repository（專案）" class="headerlink" title="Step2. 點選 New 新增一個 Repository（專案）"></a>Step2. 點選 New 新增一個 Repository（專案）</h4><p><img src="https://i.imgur.com/nDvzP4k.png"></p>
<h4 id="Step3-將專案名稱命名為-username-github-io，username-記得改成自己的帳號名稱"><a href="#Step3-將專案名稱命名為-username-github-io，username-記得改成自己的帳號名稱" class="headerlink" title="Step3. 將專案名稱命名為 username.github.io，username 記得改成自己的帳號名稱"></a>Step3. 將專案名稱命名為 <code>username.github.io</code>，username 記得改成自己的帳號名稱</h4><p><img src="https://i.imgur.com/0i5Fg2R.png"></p>
<p>這樣就成功建立了一個網域：<code>username.github.io</code></p>
<h3 id="將檔案發布到-GitHub"><a href="#將檔案發布到-GitHub" class="headerlink" title="將檔案發布到 GitHub"></a>將檔案發布到 GitHub</h3><h4 id="Step1-安裝-Git-相關套件"><a href="#Step1-安裝-Git-相關套件" class="headerlink" title="Step1. 安裝 Git 相關套件"></a>Step1. 安裝 Git 相關套件</h4><p>回到 hexo 資料夾，在終端機輸入下列指令安裝部署所需套件：</p>
<pre><code>$ npm install hexo-deployer-git --save</code></pre>
<h4 id="Step2-修改-config-yml-檔案的-Deployment-設定"><a href="#Step2-修改-config-yml-檔案的-Deployment-設定" class="headerlink" title="Step2. 修改 _config.yml 檔案的 Deployment 設定"></a>Step2. 修改 _config.yml 檔案的 Deployment 設定</h4><p>接著是修改 _config.yml 設定檔中，有關 deploy 的設定。</p>
<blockquote>
<p>需注意這裡指的 _config.yml 檔案是根目錄的，而不是 themes 主題中的。</p>
</blockquote>
<pre><code>deploy:
  type: git
  repo: https://github.com/username/username.github.io.git
  branch: master</code></pre>
<ul>
<li>type：選擇部屬模式，這裡填 git</li>
<li>repo：GitHub repository 的連結，記得將 username 修改成自己的帳號名稱</li>
<li>branch：選擇分支，預設為 master</li>
</ul>
<p><img src="https://i.imgur.com/bVw4OIH.png"></p>
<h4 id="Step3-輸入部署指令"><a href="#Step3-輸入部署指令" class="headerlink" title="Step3. 輸入部署指令"></a>Step3. 輸入部署指令</h4><p>使用下列指令即可部署檔案到網站上，第一次輸入可能會要求登入 GitHub 帳號：</p>
<pre><code>$ hexo deploy</code></pre>
<p>通常在完成每次修改後，會依序輸入 clean -&gt; generate -&gt; deploy 三行指令，避免更新不完全：</p>
<pre><code>$ hexo cl    // 清除之前建立的靜態檔案
$ hexo g     // 建立靜態頁面
$ hexo d     // 部署至 GitHub</code></pre>
<p>或是合併第二、三行指令：<code>hexo g -d</code> 即可在產生靜態頁面後立刻部署。</p>
<p>這樣就完成部署網誌到 GitHub 了！可在個人頁面 <code>https://username.github.io</code> 確認是否有發布成功，預設畫面如下：</p>
<p><img src="https://i.imgur.com/X0cAUy6.png"></p>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>當初之所以會對 Hexo 產生興趣，是因為在課程第十四週時，學到該如何購買個人主機和網域來部署，主要是部署動態網頁為主，例如 <span class="exturl" data-url="aHR0cDovL2hlaWRpbGl1LnR3L3RvZG9saXN0Lw==">todolist<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cDovL2hlaWRpbGl1LnR3L2JvYXJkLw==">board<i class="fa fa-external-link-alt"></i></span>。</p>
<p>本來也想要嘗試放看看 Markdown 檔案，卻沒想到瀏覽器並不支援，會導致部分內容變成亂碼等等。上網查該如何解決，就找到許多和 Hexo + GitHub 架設網誌有關的文章，能夠快速架設並且支援解析 Markdown 檔案，想著之後一定也要來挑戰看看！</p>
<p>實際在使用 Hexo 框架時，真的比想像中還要方便許多！除了能夠快速套用主題或外掛，也能自訂修改想要的樣式，能夠玩出許多變化。目前<a href="https://heidiliu2020.github.io/">網站 Demo</a> 還很陽春，之後會繼續摸索有哪些功能，預計下一篇會整裡有關更換主題等設定，同時也慢慢豐富自己的網誌。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oc2lhbmdmZW5nLmdpdGh1Yi5pby9oZXhvLzIwMTkwNDExLzkzMjgyNjE2MC8=">架設 Hexo+GitHub<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAyMTkyMzEzNw==">基於Hexo的matery主題搭建博客並深度優化<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【學習筆記】如何更換 Hexo 主題 &amp; 自訂樣式</title>
    <url>/hexo-theme/</url>
    <content><![CDATA[<p>以下介紹如何套用 Hexo 主題，以及自訂樣式：</p>
<p><img src="https://i.imgur.com/6LNDOBF.png"></p>
<a id="more"></a>

<h2 id="更換主題"><a href="#更換主題" class="headerlink" title="更換主題"></a>更換主題</h2><p>首先介紹 Hexo 專案架構：</p>
<pre><code>.  // 根目錄
├─ .deploy_git
├─ node_modules
├─ public　    // 使用 hexo g 指令生成的內容
├─ scaffolds   // 模板
├─ source　    // 存放原始檔案
　　├─ _discarded　// 已刪除文章
　　├─ _drafts　 // 未發布文章
　　├─ _posts　　// 已發布文章（會被 push）
　　├─ about　　 // 關於我
　　└─ categories   // 分類
├─ themes　      // 存放主題
　　└─ landscape　// 預設主題
　　　　├─ layout, scripts, source
　　　　└─ _config.yml　// 修改主題設定
└─ _config.yml　// 修改部落格的通用設定，例如：網站標題、網址、使用主題等</code></pre>
<h3 id="下載主題"><a href="#下載主題" class="headerlink" title="下載主題"></a>下載主題</h3><p>以更換成 next 主題為例，可參考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">hexo-theme-next<i class="fa fa-external-link-alt"></i></span> 官方說明，將主題 clone 到本地端：</p>
<pre><code>$ cd hexo
$ git clone https://github.com/theme-next/hexo-theme-next themes/next</code></pre>
<h3 id="修改-config-yml-的-theme-設定"><a href="#修改-config-yml-的-theme-設定" class="headerlink" title="修改 /_config.yml 的 theme 設定"></a>修改 /_config.yml 的 theme 設定</h3><p>更多主題可以到官網的 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=">Hexo Themes<i class="fa fa-external-link-alt"></i></span> 選擇，將主題 clone 下來後，修改根目錄的 _config.yml 檔案即可套用：</p>
<pre><code class="yaml="># Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
theme: next</code></pre>
<hr>
<h2 id="自訂樣式"><a href="#自訂樣式" class="headerlink" title="自訂樣式"></a>自訂樣式</h2><p>在更早之前的版本，是透過 _custom.styl 來自訂樣式，目前則改成 source/_data 這個路徑。</p>
<p>可參考這篇：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0L2lzc3Vlcy85NzM=">NexT V7.2.0:How to change blog background？如何更改博客背景？<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="修改-next-config-yml-的-Custom-file-path-設定"><a href="#修改-next-config-yml-的-Custom-file-path-設定" class="headerlink" title="修改 next/_config.yml 的 Custom_file_path 設定"></a>修改 next/_config.yml 的 Custom_file_path 設定</h3><p>在 <code>/themes/next/_config.yml</code> 檔案，把 custom_file_path 的 style 註解拿掉：</p>
<pre><code class="yaml="># Define custom file paths.
# Create your custom files in site directory `source/_data` and uncomment needed files below.
custom_file_path:
  #head: source/_data/head.swig
  #header: source/_data/header.swig
  #sidebar: source/_data/sidebar.swig
  #postMeta: source/_data/post-meta.swig
  #postBodyEnd: source/_data/post-body-end.swig
  #footer: source/_data/footer.swig
  #bodyEnd: source/_data/body-end.swig
  #variable: source/_data/variables.styl
  #mixin: source/_data/mixins.styl
  style: source/_data/styles.styl</code></pre>
<h3 id="在-source-建立-data-資料夾"><a href="#在-source-建立-data-資料夾" class="headerlink" title="在 /source 建立 _data 資料夾"></a>在 /source 建立 _data 資料夾</h3><p>需注意這裡的 source 路徑並不是 next 主題資料夾，而是在 Hexo 專案根目錄的 source/_data，如果沒有 _data 資料夾需自行建立，並在裡面新增 styles.styl 檔案：</p>
<p><img src="https://i.imgur.com/eueuD6k.png"></p>
<h3 id="撰寫自訂樣式"><a href="#撰寫自訂樣式" class="headerlink" title="撰寫自訂樣式"></a>撰寫自訂樣式</h3><p>接著就可以在 styles.styl 檔案中撰寫樣式，例如設定背景圖片：</p>
<pre><code class="css=">body &#123;
  background: url(/images/bg.jpg);   // 圖片路徑
  background-repeat: no-repeat;　// 不重複
  background-attachment:fixed;　 //　固定背景
  background-size: cover; // 將背景圖片放大至容器大小
  background-position:50% 50%;  // 背景位置置中
&#125;</code></pre>
<p>記得把圖片放到對應位置 <code>/source/images/bg.jpg</code> 才能讀取到：</p>
<p><img src="https://i.imgur.com/9F4gZn4.png"></p>
<p>結果如下：</p>
<p><img src="https://i.imgur.com/6n4wOCV.png"></p>
<h2 id="取消歸檔的「嗯-目前共有-x-篇文章。-繼續努力。」"><a href="#取消歸檔的「嗯-目前共有-x-篇文章。-繼續努力。」" class="headerlink" title="取消歸檔的「嗯..! 目前共有 x 篇文章。 繼續努力。」"></a>取消歸檔的「嗯..! 目前共有 x 篇文章。 繼續努力。」</h2><p>原先看到可以把 /next/_config.yml 中的 cheers 設定為 false，但目前版本似乎沒有這個設定，後來是看到<span class="exturl" data-url="aHR0cHM6Ly9waW5nc2hpdWFuLmdpdGxhYi5pby9oZXhvX2dpdGxhYl9hZHNlbnNlX25jdHUuaHRtbA==">這篇文章<i class="fa fa-external-link-alt"></i></span>有提到可以直接修改 next/layout/archive.swig 檔案，把有出現 cheers 的區塊通通註解掉：</p>
<pre><code class="yaml=">  &lt;div class=&quot;post-block&quot;&gt;
    &lt;div class=&quot;posts-collapse&quot;&gt;
#  以下通通註解掉   
      &#123;###<div class="collection-title">
        &#123;%- set posts_length = site.posts.length %&#125;
        &#123;%- if posts_length > 210 %&#125;
          &#123;%- set cheers = 'excellent' %&#125;
        &#123;% elif posts_length > 130 %&#125;
          &#123;%- set cheers = 'great' %&#125;
        &#123;% elif posts_length > 80 %&#125;
          &#123;%- set cheers = 'good' %&#125;
        &#123;% elif posts_length > 50 %&#125;
          &#123;%- set cheers = 'nice' %&#125;
        &#123;% elif posts_length > 30 %&#125;
          &#123;%- set cheers = 'ok' %&#125;
        &#123;% else %&#125;
          &#123;%- set cheers = 'um' %&#125;
        &#123;%- endif %&#125;
        <span class="collection-header">&#123;&#123; __('cheers.' + cheers) &#125;&#125;! &#123;&#123; _p('counter.archive_posts', site.posts.length) &#125;&#125; &#123;&#123; __('keep_on') &#125;&#125;&lt;/span&gt;
      &lt;/div&gt;###&#125;
#  以上通通註解掉 

      &#123;&#123; post_template.render(page.posts) &#125;&#125;

    &lt;/div&gt;
  &lt;/div&gt;</code></pre>
<p>結果如下：</p>
<p><img src="https://i.imgur.com/DRbxd52.png"></p>
<hr>
<h2 id="文章搜尋功能"><a href="#文章搜尋功能" class="headerlink" title="文章搜尋功能"></a>文章搜尋功能</h2><h3 id="修改-next-config-yml-的-local-search-設定"><a href="#修改-next-config-yml-的-local-search-設定" class="headerlink" title="修改 next _config.yml 的 local_search 設定"></a>修改 next _config.yml 的 local_search 設定</h3><p>修改<code> /themes/next/_config.yml</code> 檔案中的 local_search，把 enable 改為 ture：</p>
<pre><code class="yaml="># Local Search
# Dependencies: https://github.com/theme-next/hexo-generator-searchdb
local_search:
  enable: true
  # If auto, trigger search by changing input.
  # If manual, trigger search by pressing enter key or search button.
  trigger: auto
  # Show top n results per article, show all results by setting to -1
  top_n_per_article: 1
  # Unescape html strings to the readable one.
  unescape: false
  # Preload the search data when the page loads.
  preload: false</code></pre>
<h3 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h3><pre><code>$ npm install hexo-generator-searchdb --save</code></pre>
<h3 id="新增內容到根目錄的-config-yml"><a href="#新增內容到根目錄的-config-yml" class="headerlink" title="新增內容到根目錄的 _config.yml"></a>新增內容到根目錄的 _config.yml</h3><p>在 <code>_config.yml</code> 檔案最下方加入這段內容：</p>
<pre><code class="yaml="># 文章搜尋功能
search:
  path: search.xml
  field: post
  content: true
  format: html</code></pre>
<p>結果如下：</p>
<p><img src="https://i.imgur.com/uPH9x7S.png"></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>在之前寫的<a href="https://heidiliu2020.github.io/2020/11/07/hexo-github/">【學習筆記】如何使用 Hexo + GitHub Pages 架設個人網誌</a> 這篇，提到該如何更換 theme 主題，到現在終於生出來XD 主要還是因為自己想要更換背景，卻忘記當初是怎麼自定義樣式的，結果又繞了點遠路，果然整理過後的知識才是自己的，寫起來就不怕忘記啦！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>[week 6] HTML - 認識基礎標籤</title>
    <url>/html/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUxMDEtaHRtbC1jc3M=">[FE101] 前端基礎：HTML 與 CSS<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<pre><code>學習目標：

 P1 你知道 HTML 是在做什麼的
 P1 你知道如何使用有語意的（semantic）標籤
 P1 你知道基本 SEO 的概念</code></pre>
<a id="more"></a>
<h2 id="網頁是如何製作的？"><a href="#網頁是如何製作的？" class="headerlink" title="網頁是如何製作的？"></a>網頁是如何製作的？</h2><ul>
<li>所有網站都使用 HTML 和 CSS 編寫，且根據不同需求，可能還會加入其他技術。</li>
<li>網頁其實就是有結構的「文字檔」，藉由瀏覽器解析渲染，呈現我們看到的畫面。</li>
</ul>
<h2 id="什麼是-HTML？"><a href="#什麼是-HTML？" class="headerlink" title="什麼是 HTML？"></a>什麼是 HTML？</h2><ul>
<li>全名為 HyperText Markup Language，中文翻作「超文本標記語言」。</li>
<li>由名字可知 HTML 是一種標記語言，而非程式語言。</li>
<li>HTML 使用「元素」來描述頁面結構，通常由兩個標記（tag）所組成：<ul>
<li>開始標記：可承載屬性，說明該元素的內容。例如：<code>&lt;p&gt;</code></li>
<li>結束標記：多一道斜線。例如：<code>&lt;/p&gt;</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="基本架構-必要的標籤"><a href="#基本架構-必要的標籤" class="headerlink" title="基本架構 - 必要的標籤"></a>基本架構 - 必要的標籤</h2><blockquote>
<p>小技巧：在編輯器上輸入 <code>!</code> 再按 tab 鍵，可快速生成基本架構。</p>
</blockquote>
<pre><code class="htmlmixed=">&lt;!-- 開頭需定義撰寫格式，告訴瀏覽器使用最新版本 HTML5 --&gt;
&lt;!DOCTYPE html&gt;

&lt;!-- 網頁的最根部元素 --&gt;
&lt;html lang=&quot;en&quot;&gt;

  &lt;!-- 包含網頁的基本資訊 --&gt;
  &lt;head&gt;

  &lt;/head&gt;

  &lt;!-- 網頁顯示的內容 --&gt;
  &lt;body&gt;

  &lt;/body&gt;

&lt;/html&gt;</code></pre>
<h2 id="lt-head-gt-內常見的標籤"><a href="#lt-head-gt-內常見的標籤" class="headerlink" title="&lt;head&gt; 內常見的標籤"></a><code>&lt;head&gt;</code> 內常見的標籤</h2><p>head 中的文檔並不會呈現在瀏覽器上，通常會包含一些資訊，例如：標題（<code>&lt;title&gt;</code>）、meatadata（提供網頁資訊給瀏覽器或搜尋引擎）、引入 CSS 或 JavaScript 文件並應用於 HTML 檔。</p>
<pre><code class="htmlmixed=">&lt;head&gt;
    &lt;!-- 聲明該頁面的編碼方式 --&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt; 

  　&lt;!-- 在 RWD 網頁，用來設定在不同裝置下的顯示方式：
        width=device-width：符合裝置寬度最佳解析度
        initial-scale=1.0：設定手機螢幕畫面的初始縮放比例為 100% 
    --&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;

    &lt;!-- 在瀏覽器 tab 標籤上的標題 --&gt;
    &lt;title&gt;網頁標題&lt;/title&gt;
    &lt;!-- 在瀏覽器 tab 標籤上的小圖示 --&gt;
    &lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot;&gt;
    &lt;!-- 引入 main.css --&gt;
    &lt;link href=&quot;main.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;!-- 引入 common.js --&gt;
    &lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;</code></pre>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly93d3cud2liaWJpLmNvbS9pbmZvLnBocD90aWQ9NDE1">HTML meta 標籤- Wibibi<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<h2 id="lt-body-gt-內常見的標籤"><a href="#lt-body-gt-內常見的標籤" class="headerlink" title="&lt;body&gt; 內常見的標籤"></a><code>&lt;body&gt;</code> 內常見的標籤</h2><ul>
<li><code>&lt;div&gt;</code>：為區塊元素（block）</li>
</ul>
<h3 id="文字相關標籤"><a href="#文字相關標籤" class="headerlink" title="文字相關標籤"></a>文字相關標籤</h3><ul>
<li><code>&lt;h1&gt;</code> ～ <code>&lt;h6&gt;</code>：標題有六階<ul>
<li>重要程度由高至低</li>
<li>一個網頁通常只能有一個 h1</li>
</ul>
</li>
<li><code>&lt;p&gt;</code>：段落</li>
<li><code>&lt;span&gt;</code>：為行內元素</li>
<li><code>&lt;sup&gt;</code> 和 <code>&lt;sub&gt;</code>：用來將內容上標、下標。為行內元素。</li>
</ul>
<pre><code class="htmlmixed=">&lt;h3&gt;上標（superscript）：常用來表示日期字尾、次方數&lt;/h3&gt;
&lt;p&gt;Today is July 23&lt;sup&gt;rd&lt;/sup&gt;.&lt;/p&gt;

&lt;h3&gt;下標（subscript）：常用在註解或化學式上&lt;/h3&gt;
&lt;p&gt;H&lt;sub&gt;2&lt;/sub&gt;O&lt;/p&gt;</code></pre>
<p><img src="https://i.imgur.com/SzbbSNA.png" alt="sup sub"></p>
<h3 id="空白壓縮"><a href="#空白壓縮" class="headerlink" title="空白壓縮"></a>空白壓縮</h3><p>當瀏覽器遇到兩個以上的空白字元時，只會顯示一個空白字元；同樣的，遇到斷行也會視為單一空白字元處理。</p>
<p>因此我們可以利用下列標籤幫助排版：</p>
<ul>
<li><code>&lt;pre&gt;</code>：保留完整格式，可用於顯示整段程式碼</li>
<li><code>&lt;br /&gt;</code> 或 <code>&lt;br&gt;</code>：換行</li>
<li><code>&lt;hr /&gt;</code> 或 <code>&lt;hr /&gt;</code>：水平線，大小寫均可，斜線可加可不加</li>
</ul>
<p>舉個例子：</p>
<pre><code class="htmlmixed=">我是標題
&lt;hr&gt;
我是段落一
&lt;HR&gt;
我是段落二</code></pre>
<p><img src="https://i.imgur.com/EFy5QbP.png"></p>
<h3 id="清單列表"><a href="#清單列表" class="headerlink" title="清單列表"></a>清單列表</h3><ul>
<li><code>&lt;ul&gt;</code>：項目清單（unordered list）</li>
<li><code>&lt;ol&gt;</code>：編號清單（ordered list）</li>
<li><code>&lt;li&gt;</code>：清單中的每個項目（list item）</li>
<li>去除清單預設樣式 CSS：<code>list-style: none</code></li>
</ul>
<pre><code class="htmlmixed=">&lt;ol&gt;
  &lt;li&gt;項目一&lt;/li&gt;
  &lt;li&gt;項目二&lt;/li&gt;
  &lt;li&gt;項目三&lt;/li&gt;
&lt;/ol&gt;</code></pre>
<h3 id="lt-a-gt-：加入連結"><a href="#lt-a-gt-：加入連結" class="headerlink" title="&lt;a&gt;：加入連結"></a><code>&lt;a&gt;</code>：加入連結</h3><ul>
<li><code>href</code> 屬性：指定要連結的目標網頁，可分為：<ul>
<li>絕對 URL：完整網址</li>
<li>相對 URL：連到同一網站的其他頁面可使用，例如：contact.html</li>
<li>上述兩種方式，也可使用 id 屬性：指定連結到網頁的目標元素</li>
</ul>
</li>
</ul>
<pre><code class="htmlmixed=">&lt;h1 id=&quot;top&quot;&gt;網頁前端&lt;/h1&gt;
&lt;a href=&quot;#html&quot;&gt;前往 HTML&lt;/a&gt;
&lt;a href=&quot;#css&quot;&gt;前往 CSS&lt;/a&gt;

&lt;h2 id=&quot;html&quot;&gt;HTML 介紹&lt;/h2&gt;
&lt;p&gt;Lorem數字 + tab 鍵：可產生假字&lt;/p&gt;

&lt;h2 id=&quot;css&quot;&gt;CSS 介紹&lt;/h2&gt;
&lt;p&gt;Lorem1000 + tab 鍵：產生 1000 個假字&lt;/p&gt;

&lt;a href=&quot;#top&quot;&gt;回到 TOP&lt;/a&gt;</code></pre>
<ul>
<li><code>target</code> 屬性：<ul>
<li><code>_self</code>：為預設值，會在原頁面開啟連結</li>
<li><code>_blank</code>：在新視窗開啟連結</li>
</ul>
</li>
</ul>
<pre><code class="htmlmixed=">&lt;a href=&quot;https://www.google.com.tw/&quot;&gt;連到 Google 首頁&lt;/a&gt;
&lt;a href=&quot;https://www.google.com.tw/&quot; target=&quot;_blank&quot;&gt;另開新視窗&lt;/a&gt;</code></pre>
<h3 id="lt-img-gt-：嵌入圖片"><a href="#lt-img-gt-：嵌入圖片" class="headerlink" title="&lt;img&gt;：嵌入圖片"></a><code>&lt;img&gt;</code>：嵌入圖片</h3><ul>
<li><code>src</code> 屬性：指定圖片來源</li>
<li><code>alt</code> 屬性：當圖片無法顯示時的替代文字，可用來描述影像內容</li>
<li><code>title</code> 屬性：滑鼠停留在圖片上的提示文字</li>
</ul>
<pre><code class="htmlmixed=">&lt;img src=&quot;https://www.google.com.tw/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png&quot; alt=&quot;This is logo&quot; title=&quot;google logo&quot; &gt;</code></pre>
<ul>
<li><p><code>&lt;Iframe&gt;</code>：內嵌網頁</p>
</li>
<li></li>
</ul>
<pre><code class="htmlmixed=">&lt;figure&gt;
  &lt;img src=&quot;https://images.unsplash.com/photo-1528138326811-ec5dd3b594be?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=750&amp;q=80&quot; alt=&quot;photo&quot; title=&quot;tasty break&quot;&gt;
  &lt;figcaption&gt;
    Photo by Vita Marija Murenaite on &lt;a href=&quot;https://unsplash.com/photos/HyO7jwH4C6g&quot;&gt;Unsplash&lt;/a&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;</code></pre>
<p><img src="https://i.imgur.com/zRRRzrC.png" alt="figure"></p>
<h3 id="lt-table-gt-：表格"><a href="#lt-table-gt-：表格" class="headerlink" title="&lt;table&gt;：表格"></a><code>&lt;table&gt;</code>：表格</h3><p>表格是以一列一列的方式撰寫，每一列由 <code>&lt;tr&gt;</code> 元素來製作。</p>
<ul>
<li><code>&lt;tr&gt;</code>：表格列（table row），表示每一列的起始</li>
<li><code>&lt;td&gt;</code>：表格資料（table data）</li>
<li><code>&lt;th&gt;</code>：表格標題（table head），用法和 <code>&lt;td&gt;</code> 元素相同，會以<strong>粗體</strong>顯示<ul>
<li>使用 scope 屬性：可標明是行（row）或列（col）的標題</li>
<li>使用 rowspan、colspan 屬性：可跨行或跨列</li>
</ul>
</li>
<li>製作長表格時，可分割成 <code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tfoot&gt;</code></li>
<li>舉個例子：</li>
</ul>
<p><img src="https://i.imgur.com/2mddzqX.png" alt="table"></p>
<pre><code class="htmlmixed=">&lt;!-- 上述表格程式碼如下 --&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;A&lt;/th&gt;
    &lt;th&gt;B&lt;/th&gt;
    &lt;th&gt;C&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;內容&lt;/th&gt;
    &lt;td&gt;漢堡&lt;/td&gt;
    &lt;td&gt;薯條&lt;/td&gt;
    &lt;td&gt;炸雞&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;價格&lt;/th&gt;
    &lt;td&gt;99&lt;/td&gt;
    &lt;td&gt;25&lt;/td&gt;
    &lt;td&gt;70&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</code></pre>
<h3 id="lt-form-gt-：表單"><a href="#lt-form-gt-：表單" class="headerlink" title="&lt;form&gt;：表單"></a><code>&lt;form&gt;</code>：表單</h3><p>其實 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS50dy8=">Google 首頁<i class="fa fa-external-link-alt"></i></span>中央的搜尋框，就是最為人熟知的表單。除此之外，表單還提供其他線上功能，例如：註冊網站會員、網路購物、問卷調查等。</p>
<p>表單控制項：<br>from、input、textarea</p>
<p><code>text</code>：純文字<br><code>password</code>：顯示會以符號代替文字<br>可以使用 maxlength and minlength 來控制輸入字數<br><code>email</code>：會自動做簡單驗證<br><code>search</code>：搜尋框<br><code>tel</code>：電話<br><code>url</code>：網址</p>
<p>（待補）</p>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly95YWtpbWhzdS5jb20vcHJvamVjdC9wcm9qZWN0X3c2X0hUTUxfZm9ybS5odG1s">[第六週] HTML - 表單 form 介紹 - Yakim shu<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<h3 id="語意化元素（Semantic-Elements）"><a href="#語意化元素（Semantic-Elements）" class="headerlink" title="語意化元素（Semantic Elements）"></a>語意化元素（Semantic Elements）</h3><p>使用 HTML5 的語意化元素取代 <code>&lt;div&gt;</code> 有以下優點：</p>
<ol>
<li>可使網頁結構和區塊位置更精確</li>
<li>幫助優化 SEO（搜尋引擎最佳化）</li>
</ol>
<p><img src="https://i.imgur.com/o04CF37.png"></p>
<blockquote>
<p>圖片來源：<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BjaGFuZ3J1LnN0dWRpby8lRTUlQkYlQUIlRTklODAlOUYlRTQlQkElODYlRTglQTclQTNodG1sJUU4JUFBJTlFJUU2JTg0JThGJUU1JThDJTk2JUU2JUE4JTk5JUU3JUIxJUE0LTMzZGQ4MjQ3ZDc3OQ==">快速了解HTML語意化標籤| by Kira Yang | Medium<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li><code>&lt;header&gt;</code> 頁首：常包含 Logo 圖案、導航列、搜尋欄位</li>
<li><code>&lt;nav&gt;</code> 導航列：主選單、頁尾選單</li>
<li><code>&lt;main&gt;</code> 主要內容</li>
<li><code>&lt;footer&gt;</code> 頁尾，通常包含版權訊息、法律訊息連結</li>
<li><code>&lt;article&gt;</code> 主要文章</li>
<li><code>&lt;section&gt;</code> 段落</li>
<li><code>&lt;aside&gt;</code> 側欄：與主要內文無關的區塊，也就是額外資訊（廣告、推薦文章等）</li>
</ul>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy91c2Vycy8yMDExMjU1MC9pcm9ubWFuLzIwNzI=">金魚都能懂 網頁設計入門 : 網頁入門第一步 (第二天)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVubG9uZy5jb20udHcvcHJvZHVjdHMvOTc4OTg2Mjc2NTAxMg==">HTML&amp;CSS：網站設計建置優化之道<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtaWFoc3V3b3JrLyVFNyVBQyVBQyVFNSU4NSVBRCVFOSU4MCVCMS1hcGktJUU1JTlGJUJBJUU3JUE0JThFLWh0bWwtdGFnLSVFNSU5RiVCQSVFNiU5QyVBQyVFNiVBOCU5OSVFNyVCMSVBNCVFOCVBQSU4RCVFOCVBRCU5OC1kMmQ5YTFjNjY0NDk=">[第七週] HTML — Tag 基本標籤認識 - Miashu<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly95YWtpbWhzdS5jb20vcHJvamVjdC9wcm9qZWN0X3c2X0hUTUxfdGFnLmh0bWw=">[第六週] HTML - tag 基礎標籤介紹 - Yakim<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h3 id="補充：如何引入-js-檔案"><a href="#補充：如何引入-js-檔案" class="headerlink" title="補充：如何引入 js 檔案"></a>補充：如何引入 js 檔案</h3><ol>
<li>寫在 HTML 文件的 <code>&lt;script&gt;</code> 標籤內</li>
</ol>
<p>也就是內嵌在 <code>&lt;head&gt;</code> 或 <code>&lt;body&gt;</code> 結束標籤之前。兩者差別在於：</p>
<ul>
<li>head 部分：會在被調用的時候才執行。</li>
<li>body 部分：會在頁面載入的時候被執行。</li>
</ul>
<p>由於 html 檔是由上而下依序載入，放在接近檔案底部，可確保 JavaScript 較晚被讀取，再去影響先被生成的 HTML 程式碼。但也可能導致腳本載入受阻，拖慢網站效能。</p>
<ol start="2">
<li>外部引入 JavaScript 文件</li>
</ol>
<p>建立 .js 檔案後，在 HTML 檔案中的 <code>&lt;body&gt;</code> 或 <code>&lt;head&gt;</code> 透過 <code>&lt;script src= &quot;&quot;&gt;</code> 標籤引用。這是最常使用的方法，可橫跨多個 HTML 檔案使用。</p>
<pre><code class="htmlmixed=">&lt;!-- .js 檔案路徑為:scripts/common.js --&gt;

&lt;script src=&quot;scripts/common.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9oaXNraW8uY29tL2NvdXJzZXMvNTEvbGVjdHVyZXMvODU2">JavaScript 寫在哪裡？ - HiSKIO<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9MZWFybi9KYXZhU2NyaXB0L0ZpcnN0X3N0ZXBzL1doYXRfaXNfSmF2YVNjcmlwdA==">JavaScript 是什麼? - 學習該如何開發Web | MDN<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>Front-End</tag>
        <tag>HTML&amp;CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 7] DOM 事件傳遞機制：捕獲與冒泡、事件代理</title>
    <url>/javascript-dom/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUxMDItamF2YXNjcmlwdA==">[FE102] 前端必備：JavaScript<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<pre><code>學習目標：

 P1 你知道捕獲與冒泡是什麼
 P1 你知道什麼是事件代理（delegation）
 P2 你知道怎麼用 JavaScript 更改元素的 style
 P2 你知道 preventDefault 與 stopPropagation 的差異</code></pre>
<a id="more"></a>
<p>當我們運用 JavaScript 在網頁進行操作時，主要可分為下列三大面向：</p>
<ol>
<li>介面（Interface）：如何改變介面</li>
<li>事件（Event）：如何監聽事件並做出反應</li>
<li>資料（Data）：如何和伺服器交換資料</li>
</ol>
<blockquote>
<p>以下主要探討「事件傳遞機制」的部分。</p>
</blockquote>
<h2 id="事件傳遞機制"><a href="#事件傳遞機制" class="headerlink" title="事件傳遞機制"></a>事件傳遞機制</h2><p>在開始解釋前，先以下列程式碼為範例：</p>
<pre><code class="htmlmixed=">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
&lt;title&gt;事件傳遞機制&lt;/title&gt;

&lt;style&gt;
  .outer &#123;
    width: 200px;
    height: 200px;
    background-color: orange;
  &#125;

  .inner &#123;
    width: 100px;
    height: 100px;
    background-color: lightseagreen;
  &#125;
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&quot;outer&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;
      &lt;button class=&quot;btn&quot;&gt;button&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  addEvent(&#39;.outer&#39;);
  addEvent(&#39;.inner&#39;);
  addEvent(&#39;.btn&#39;);

  // 監聽按鈕點擊事件
  function addEvent(className) &#123;
    document.querySelector(className)
      .addEventListener(&#39;click&#39;, function () &#123;
        console.log(className);
      &#125;)
  &#125;;
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>若在區塊都加上監聽 click 事件，會發現點擊內部區塊，同時也會點擊到外層區塊：</p>
<ul>
<li>點擊 outer 會觸發 outer</li>
<li>點擊 inner 會觸發 inner ➡️ outer</li>
<li>點擊 button 會觸發 button ➡️ inner ➡️ outer</li>
</ul>
<p><img src="https://i.imgur.com/6YDCa36.png"></p>
<p>由此可知當點擊內部節點，同時也會點擊到外層節點。</p>
<h2 id="捕獲與冒泡"><a href="#捕獲與冒泡" class="headerlink" title="捕獲與冒泡"></a>捕獲與冒泡</h2><blockquote>
<p>參考文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRlY2hicmlkZ2UuY2MvMjAxNy8wNy8xNS9qYXZhc2NyaXB0LWV2ZW50LXByb3BhZ2F0aW9uLw==">DOM 的事件傳遞機制：捕獲與冒泡<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>根據上述內容，可知 DOM 事件傳遞機制分成 3 階段：</p>
<pre><code>1：Capturing Phase　捕獲階段
2：Target Phase     傳遞到元素本身
3：Bubbling Phase   冒泡階段</code></pre>
<p>當我們觸發事件時，會從最外層的根結點開始往內傳遞到 target，也就是「捕獲階段」。接著會再由內往外回傳回去，稱為「冒泡階段」。</p>
<p>任何事件在傳遞時，都會按照這個順序下去傳遞。這也是為什麼，當觸發底層節點的事件同時，上層所有的節點也會被觸發。</p>
<p><img src="https://i.imgur.com/zj2brCF.png"></p>
<blockquote>
<p>可參考：<span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtZmxvdw==">W3C -  event flow 的示意圖<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="事件傳遞的兩個原則"><a href="#事件傳遞的兩個原則" class="headerlink" title="事件傳遞的兩個原則"></a>事件傳遞的兩個原則</h3><ol>
<li>先捕獲，再冒泡</li>
<li>當事件傳到 target 本身，沒有分捕獲跟冒泡</li>
</ol>
<p>根據傳遞機制，我們不一定要把監聽的節點設在底層節點，只需設定在外層，就能監聽到所有底層節點的事件。</p>
<h3 id="阻止事件傳遞-e-stopPropagation"><a href="#阻止事件傳遞-e-stopPropagation" class="headerlink" title="阻止事件傳遞 e.stopPropagation"></a>阻止事件傳遞 <code>e.stopPropagation</code></h3><p>當使用 <code>event.stopPropagation()</code>，事件傳遞就會停在設置的地方：</p>
<ul>
<li>若在捕獲階段：阻止事件往下傳遞</li>
<li>若在冒泡階段：阻止事件向上傳遞</li>
</ul>
<p><code>event.stopPropagation()</code>這樣就可以阻止事件繼續往上冒泡，在父元素的監聽器就不會收到孫元素的事件傳遞。</p>
<pre><code class="javascript=">document.querySelector(&#39;.btn&#39;).addEventListener(&#39;click&#39;,function(e)&#123;
   e.stopPropagation()
   console.log(&#39;btn 冒泡&#39;);
&#125;)</code></pre>
<h3 id="阻止事件傳遞-stopPropagation"><a href="#阻止事件傳遞-stopPropagation" class="headerlink" title="阻止事件傳遞 stopPropagation()"></a>阻止事件傳遞 <code>stopPropagation()</code></h3><ul>
<li>事件傳遞會停在設置的地方</li>
<li>例如：在 window（最上層）的捕獲階段設置 <code>event.stopPropagation()</code>，會阻止後續事件傳遞，造成所有 click 事件均失效。</li>
</ul>
<pre><code class="javascript">// 監聽 window 捕獲階段的 click 事件，執行函式內指令
window.addEventListener(&#39;click&#39;, function(e) &#123;
  e.stopPropagation()
&#125;, true)</code></pre>
<h3 id="stopImmediatePropagation"><a href="#stopImmediatePropagation" class="headerlink" title="stopImmediatePropagation()"></a><code>stopImmediatePropagation()</code></h3><p>如果要讓同一層的事件也要停止，就用 <code>stopImmediatePropagation()</code>，這樣同一層只會觸發這個 listener。</p>
<h2 id="容易搞錯的事件機制問題"><a href="#容易搞錯的事件機制問題" class="headerlink" title="容易搞錯的事件機制問題"></a>容易搞錯的事件機制問題</h2><h3 id="迴圈與觸發時間非同步"><a href="#迴圈與觸發時間非同步" class="headerlink" title="迴圈與觸發時間非同步"></a>迴圈與觸發時間非同步</h3><p>首先要注意的，是「迴圈與觸發時間非同步」這件事。以下列程式碼為例：</p>
<pre><code class="javascript=">// 在 html 新增兩個 button：
&lt;body&gt;
  &lt;div class=&quot;outer&quot;&gt;
    &lt;button class=&quot;btn&quot;&gt;1&lt;/button&gt;
    &lt;button class=&quot;btn&quot;&gt;2&lt;/button&gt;
  &lt;/div&gt;

// JS 監控按鈕 click 點擊事件：
&lt;script&gt;
  // querySelectorAll 回傳的值是類陣列
  const btns = document.querySelectorAll(&#39;.btn&#39;)
  for (i = 0; i &lt; btns.length; i += 1) &#123;
    btns[i].addEventListener(&#39;click&#39;, () =&gt; &#123;
      alert(i)
    &#125;)
  &#125;
&lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>會發現兩個 button 跳出的結果都是 2，而非按照迴圈順序一一跳出相對應的數字。</p>
<p>這是因為 click 事件和迴圈是不一樣時間軸。click 只有在點擊瞬間才會執行，但迴圈會先跑完。因此順序是：click →跑完迴圈→觸發事件結果，所以會跳出一樣的數字。</p>
<p>我們可以把程式碼修改成：</p>
<pre><code class="javascript=">// 在 html 新增兩個 button：
&lt;body&gt;
  &lt;div class=&quot;outer&quot;&gt;
    // 通常以 `data` 開頭是我們自訂的屬性
    &lt;button class=&quot;btn&quot; data-value=&quot;1&quot;&gt;1&lt;/button&gt;
    &lt;button class=&quot;btn&quot; data-value=&quot;2&quot;&gt;2&lt;/button&gt;
  &lt;/div&gt;

// JS 監控按鈕 click 點擊事件：
&lt;script&gt;
  const btns = document.querySelectorAll(&#39;.btn&#39;)
  for (i = 0; i &lt; btns.length; i += 1) &#123;
    btns[i].addEventListener(&#39;click&#39;, (e) =&gt; &#123;
      alert(e.target.getAttribute(&#39;data-value&#39;))
    &#125;)
  &#125;
&lt;/script&gt;
&lt;/body&gt;</code></pre>
<ul>
<li><code>e.target</code>：觸發到哪個元素，就可該元素的資料</li>
<li><code>getAttribute</code>：可得到 <code>data-value</code> 的值，也就是新增在 <code>button</code> 元素的屬性</li>
</ul>
<h3 id="動態新增問題"><a href="#動態新增問題" class="headerlink" title="動態新增問題"></a>動態新增問題</h3><p>若想再新增按紐，後來新增的元素並無法擁有已預設好的 addEventListener 的功能：</p>
<pre><code class="javascript=">&lt;div class=&quot;outer&quot;&gt;
  &lt;button class=&quot;add-btn&quot;&gt;add&lt;/button&gt;
  &lt;button class=&quot;btn&quot; data-value=&quot;1&quot;&gt;1&lt;/button&gt;
  &lt;button class=&quot;btn&quot; data-value=&quot;2&quot;&gt;2&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;
  // 從數字 3 繼續新增按紐
  let num = 3

  const btns = document.querySelectorAll(&#39;.btn&#39;)
  for (i = 0; i &lt; btns.length; i += 1) &#123;
    btns[i].addEventListener(&#39;click&#39;, (e) =&gt; &#123;
      alert(e.target.getAttribute(&#39;data-value&#39;))
    &#125;)
  &#125;

  // 動態新增按紐
  document.querySelector(&#39;.add-btn&#39;).addEventListener(&#39;click&#39;, function() &#123;
    const newBtn = document.createElement(&#39;button&#39;)
    newBtn.classList.add(&quot;btn&quot;)
    newBtn.setAttribute(&#39;data-value&#39;, num)
    newBtn.innerText = num
    num += 1

    document.querySelector(&#39;.outer&#39;).appendChild(newBtn)
  &#125;)
&lt;/script&gt;</code></pre>
<p>當按下 add 確實會新增 button 按鈕，並同樣賦予按鈕 class 與 attribute，但新增的按鈕卻沒有 <code>addEventListener</code> 的效果。</p>
<p>這是因為「程式只會執行一次」。也就是說，第一段的 <code>.querySelectorAll</code> 其實只包含原有的兩顆按鈕，後來新增的按鈕並不會再被加入。我們可以利用「事件代理」來解決動態新增的問題。</p>
<h3 id="事件代理-event-delegation"><a href="#事件代理-event-delegation" class="headerlink" title="事件代理 event delegation"></a>事件代理 <code>event delegation</code></h3><p>透過事件傳遞機制，我們可以直接對父元素（事件代理）進行事件監聽，就不需對子元素事件一個一個監聽。如此不只能提高效率，也能處理動態新增的問題。</p>
<p>如先前提到：當我們要新增按紐，若把監聽事件設在子元素，那麼新加入的子元素就必須另外處理。若使用 event delegation，直接父元素進行事件監聽，透過冒泡機制，事件會由父元素傳遞到底下的所有子元素。</p>
<p>因此我們可以將先前的程式碼改為：</p>
<pre><code class="javascript=">&lt;!-- 事件代理 --&gt;
&lt;div class=&quot;outer&quot;&gt;
  &lt;button class=&quot;add-btn&quot;&gt;add&lt;/button&gt;
  &lt;button class=&quot;btn&quot; data-value=&quot;1&quot;&gt;1&lt;/button&gt;
  &lt;button class=&quot;btn&quot; data-value=&quot;2&quot;&gt;2&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;
  let num = 3

  // 動態新增按紐
  document.querySelector(&#39;.add-btn&#39;).addEventListener(&#39;click&#39;, function() &#123;
    const newBtn = document.createElement(&#39;button&#39;)
    newBtn.classList.add(&#39;btn&#39;)
    newBtn.setAttribute(&#39;data-value&#39;, num)
    newBtn.innerText = num
    num += 1;
    document.querySelector(&#39;.outer&#39;).appendChild(newBtn)
  &#125;)
  // 不管有沒有進行事件監聽，事件捕獲冒泡機制都會進行
  // 新增監聽在父節點上
  document.querySelector(&#39;.outer&#39;).addEventListener(&#39;click&#39;, function(e) &#123;
    // .classList.contains()：判斷是否包含該 class
    if (e.target.classList.contains(&#39;btn&#39;)) &#123;
      alert(e.target.getAttribute(&#39;data-value&#39;))
    &#125;
  &#125;)
&lt;/script&gt;</code></pre>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JaLUh1YW5nL0Fib3V0LUphdmFzY3JpcHQvaXNzdWVzLzI=">Introduction to Javascript in Front-End #2<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 3] JavaScript：ES6 語法 + npm + Jest</title>
    <url>/javascript-es6/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvanMxMDItamF2YXNjcmlwdC1lczYtbnBt">[JS102] 升級你的 JavaScript 技能：ES6 + npm + Jest<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<pre><code>學習目標：

 理解常用內建函式如何使用
 熟悉程式語法並知道如何解決基礎問題
 了解為什麼我們需要 unit test
 了解什麼是 unit test
 了解如何寫 unit test
 了解如何測試一個 function</code></pre>
<a id="more"></a>
<hr>
<h2 id="何謂-Modules-模組（模塊）？"><a href="#何謂-Modules-模組（模塊）？" class="headerlink" title="何謂 Modules 模組（模塊）？"></a>何謂 Modules 模組（模塊）？</h2><p>在開發過程中，若將各種功能放在一起，程式間可能會互相影響甚至產生 bug，日後也不易進行維護。</p>
<p>因此，我們可以將不同功能視為一個模組（Module），例如：金流、登入、權限、會員等等，再用主程式將所有模組串接起來，透過模組化統一進行管理。</p>
<p><img src="https://i.imgur.com/di0LXxg.png"></p>
<h2 id="Modeule-相關操作"><a href="#Modeule-相關操作" class="headerlink" title="Ｍodeule 相關操作"></a>Ｍodeule 相關操作</h2><h3 id="require-：引入模組"><a href="#require-：引入模組" class="headerlink" title="require()：引入模組"></a><code>require()</code>：引入模組</h3><p>以引入 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9vcy5odG1sI29zX29zX3BsYXRmb3Jt">Node.js 提供的 os<i class="fa fa-external-link-alt"></i></span> 這個模組為例：</p>
<pre><code class="js">var os = require(&#39;os&#39;)      // 引入 &#39;os&#39; 這個模組，變數 os 可隨意命名
console.log(os.platform())
// 印出 win32，代表當前作業系統</code></pre>
<p><img src="https://i.imgur.com/ubLcpXY.png"></p>
<h3 id="module-export：輸出模組"><a href="#module-export：輸出模組" class="headerlink" title="module.export：輸出模組"></a><code>module.export</code>：輸出模組</h3><ul>
<li>語法：<code>module.exports = 任何資料型別（例如：數字、陣列、物件等）</code></li>
</ul>
<ol>
<li>以輸出 <code>double</code> 函式為例：</li>
</ol>
<pre><code class="js">// 建立一個要輸出模組的 myModule.js 檔案

function double(n) &#123;
   return n * 2
&#125;

module.exports = double;</code></pre>
<pre><code class="js">// 以 require 指令輸入模組到要使用的 js 檔案

var myModule = require(&#39;./myModule&#39;)    // 要加路徑，檔案類型 .js 通常會省略
// 不加路徑的話，其實也會自動從 node_modules 資料夾底下去找

console.log(myMoudle)        // 印出 [Function: double]
console.log(myMoudle(6))     // 印出 6</code></pre>
<ol start="2">
<li>也可利用 <code>exports</code> 輸出物件：</li>
</ol>
<pre><code class="js">// 在要輸出模組的 myModule.js 檔案

function double(n) &#123;
   return n * 2
&#125;

let obj = &#123;
  double: double,
  triple: function triple(n) &#123;
      return n * 3
  &#125;
&#125;

module.exports = obj</code></pre>
<pre><code class="js">// 以 require 指令輸入模組到要使用的 js 檔案

var myModule = require(&#39;./myModule&#39;)    

console.log(myModule)
// 印出 &#123; double: [Function: double], triple: [Function: triple] &#125;

console.log(myModule.double(2), myModule.triple(10))
// 印出 4, 30</code></pre>
<ol start="3">
<li>也可用另一個寫法：<code>exports.double = double</code>，把 <code>exports</code> 本身視為空物件，但這種方法比較少見：</li>
</ol>
<pre><code class="js">// 在要輸出模組的 myModule.js 檔案

function double(n) &#123;
   return n * 2
&#125;

exports.double = double
exports.triple = function(n) &#123;
  return n * 3
&#125;</code></pre>
<pre><code class="js">// 此種輸出方式，myModule 一定會是物件

var myModule = require(&#39;./myModule&#39;) 

console.log(myModule)
// 印出 &#123; double: [Function: double], triple: [Function] &#125;
console.log(myModule.double(3))
// 印出 6</code></pre>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtaWFoc3V3b3JrLyVFNyVBQyVBQyVFNCVCOCU4OSVFOSU4MCVCMS1ub2RlLWpzLSVFNSU5RiVCQSVFNyVBNCU4RS1tb2R1bGUtZXhwb3J0cy0lRTUlOTIlOEMtcmVxdWlyZS0yZjlmNjkxNWQ5ZjA=">[第三週] Node.js 基礎 — module.exports 和 require<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h2 id="NPM-線上套件庫"><a href="#NPM-線上套件庫" class="headerlink" title="NPM 線上套件庫"></a>NPM 線上套件庫</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tLw==">NPM<i class="fa fa-external-link-alt"></i></span> 是 Node Package Manager 的簡稱。是用來管理 Node.js 套件的系統（Library），可以下載別人已經寫好的 Javascript 套件來使用。</p>
<blockquote>
<p>也可使用由 Facebook 團隊開發的 <span class="exturl" data-url="aHR0cHM6Ly95YXJucGtnLmNvbS8=">Yarn<i class="fa fa-external-link-alt"></i></span>，同樣能從 npm 安裝套件，優點是速度較快。<br>參考資料：<span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDE5MTc0NQ==">[Day-5] 用Yarn取代npm加速開發<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><h4 id="npm-v：查看-npm-版本。"><a href="#npm-v：查看-npm-版本。" class="headerlink" title="npm -v：查看 npm 版本。"></a><code>npm -v</code>：查看 npm 版本。</h4><p>通常在安裝 node.js 時就會一起安裝。</p>
<p><img src="https://i.imgur.com/zZMyERG.png" alt="npm -v"></p>
<h4 id="npm-init：協助建立-Node-js-專案的描述檔。"><a href="#npm-init：協助建立-Node-js-專案的描述檔。" class="headerlink" title="npm init：協助建立 Node.js 專案的描述檔。"></a><code>npm init</code>：協助建立 Node.js 專案的描述檔。</h4><p>也就是產生 package.json 這個檔案。</p>
<h4 id="npm-install-left-pad：以-npm-安裝-left-pad-這個套件為例。"><a href="#npm-install-left-pad：以-npm-安裝-left-pad-這個套件為例。" class="headerlink" title="npm install left-pad：以 npm 安裝 left-pad 這個套件為例。"></a><code>npm install left-pad</code>：以 npm 安裝 left-pad 這個套件為例。</h4><p><img src="https://i.imgur.com/4zvy68Z.png" alt="npm install"></p>
<p>安裝同時會產生：</p>
<ol>
<li>package-lock.json 檔案：記錄安裝套件的版本和依賴（dependencies）</li>
<li>node_modules 資料夾：裡面放安裝的套件</li>
</ol>
<p><img src="https://i.imgur.com/hOnLOZL.png"></p>
<p>package-lock.json 檔案內容如下，可從 <code>dependencies</code> 得知專案使用的套件：</p>
<p><img src="https://i.imgur.com/YopHSs7.png" alt="描述檔"></p>
<h3 id="版本控制會忽略-node-modules-資料夾"><a href="#版本控制會忽略-node-modules-資料夾" class="headerlink" title="版本控制會忽略 node_modules 資料夾"></a>版本控制會忽略 node_modules 資料夾</h3><p>當安裝許多套件時，檔案會很大。若要將專案上傳到 GitHub 遠端，通常會忽略 node_modules 這個資料夾，也就是不需進行版本控制。</p>
<p>因為已經有 package.json 這個檔案，負責記錄該專案所安裝的套件。若從遠端下載專案時，只要再輸入 <code>npm install</code> 指令，就可安裝該專案所需套件。</p>
<p><img src="https://i.imgur.com/nsRpDni.png"></p>
<hr>
<h2 id="設定-npm-scripts"><a href="#設定-npm-scripts" class="headerlink" title="設定 npm scripts"></a>設定 npm scripts</h2><p><code>package.json</code> 檔案中，我們可在 <code>scripts</code> 區塊加入各種指令。</p>
<h3 id="quot-key-quot-quot-要執行的內容＂"><a href="#quot-key-quot-quot-要執行的內容＂" class="headerlink" title="&quot;key&quot;: &quot;要執行的內容＂"></a><code>&quot;key&quot;: &quot;要執行的內容＂</code></h3><p>以如何運行 <code>index.js</code> 這個專案為例：</p>
<p><code>&quot;start&quot;: &quot;node index.js&quot;</code>：代表以 start 為 key，輸入即可在 node 運行 index.js。</p>
<blockquote>
<p>注意是使用雙引號。</p>
</blockquote>
<p><img src="https://i.imgur.com/fvF1YuH.png" alt="scripts"></p>
<h3 id="npm-run-39-key-39"><a href="#npm-run-39-key-39" class="headerlink" title="npm run &#39;key&#39;"></a><code>npm run &#39;key&#39;</code></h3><p>在終端機輸入 <code>npm run start</code> 即可透過 key 來運行該指令：</p>
<p><img src="https://i.imgur.com/K3XhyO3.png" alt="npm run start"></p>
<hr>
<h2 id="如何測試程式？"><a href="#如何測試程式？" class="headerlink" title="如何測試程式？"></a>如何測試程式？</h2><p>測試程式的作用是「模擬外部如何使用目標程式，驗證目標程式的行為是否符合預期」。</p>
<h3 id="利用-console-log-測試"><a href="#利用-console-log-測試" class="headerlink" title="利用 console.log() 測試"></a>利用 <code>console.log()</code> 測試</h3><p>在前面幾個章節，我們通常會使用 console.log()，來測幾個範例確認是否正確。也需要考慮到邊界條件（edge case）來進行測試。</p>
<pre><code class="js">// 以測試 `repeat` 函式為例：

function repeat(str, times) &#123;
  let result = &#39;&#39;
  for (let i = 0; i &lt; times; i += 1) &#123;
    result += str
  &#125;
  return result
&#125;

console.log(repeat(&#39;a&#39;, 5));          // 印出 aaaaa
console.log(repeat(&#39;z!Z!Z!!&#39;, 2));    // 印出　z!Z!Z!!z!Z!Z!!
console.log(repeat(&#39;&#39;, 3));           // 印出空字串
console.log(repeat(&#39;abc&#39;, 0));        // 印出空字串</code></pre>
<p>接著優化測試資料：直接判斷函式執行結果是否正確。</p>
<pre><code class="js">// 優化測試資料：

console.log(repeat(&#39;a&#39;, 5) === &#39;aaaaa&#39;);
console.log(repeat(&#39;z!Z!Z!!&#39;, 2) === &#39;z!Z!Z!!z!Z!Z!!&#39;); 
console.log(repeat(&#39;&#39;, 3) === &#39;&#39;); 
console.log(repeat(&#39;abc&#39;, 0) === &#39;&#39;);
// 均印出 true</code></pre>
<p>這是最簡單的測試方法，但這麼做的缺點是很難「規模化」。我們可以利用別人寫好的框架來便利測試。</p>
<h3 id="利用現成的框架-Jest-測試"><a href="#利用現成的框架-Jest-測試" class="headerlink" title="利用現成的框架 Jest 測試"></a>利用現成的框架 <span class="exturl" data-url="aHR0cHM6Ly9qZXN0anMuaW8v">Jest<i class="fa fa-external-link-alt"></i></span> 測試</h3><ol>
<li>用 npm 下載 Jest：輸入指令 <code>npm install -save-dev jest</code></li>
</ol>
<p><img src="https://i.imgur.com/P2V2LzG.png"></p>
<ol start="2">
<li>利用模組將「測試」與「要測試的 Function」分開。</li>
</ol>
<ul>
<li>在要測試的檔案 index.js 加上：<code>module.exports = &#39;要輸出的值&#39;</code></li>
</ul>
<pre><code class="js">function repeat(str, times) &#123;
  let result = &#39;&#39;
  for (let i = 0; i &lt; times; i += 1) &#123;
    result += str
  &#125;
  return result
&#125;

module.exports = repeat</code></pre>
<ul>
<li>建立 index.test.js 檔案：<code>touch index.test.js</code>，習慣用 <code>test.js</code> 取名<br>並在檔案中引用 index.js 輸出的值：<code>var repeat = require(&#39;./引入的檔案&#39;)</code></li>
</ul>
<pre><code class="js">// 可輸入 node index.test.js 測試是否引入成功
var repeat = require(&#39;./index&#39;)

console.log(repeat(&#39;a&#39;, 5));
// 印出 aaaaa，引入成功</code></pre>
<ul>
<li>在 index.test.js 加入 Jest 語法：<code>test(&#39;描述文字&#39;, &#39;要做的測試&#39;)</code></li>
</ul>
<pre><code class="js">var repeat = require(&#39;./index&#39;)

test(&#39;a 重複 5 次應該要等於&#39;, function() &#123;
  expect(repeat(&#39;a&#39;, 5)).toBe(&#39;aaaaa&#39;);
&#125;)</code></pre>
<ol start="3">
<li>更新 package.json 檔案的 <code>&quot;scripts&quot;</code>：加入 <code>&quot;test&quot;: &quot;jest&quot;</code></li>
</ol>
<p><img src="https://i.imgur.com/85bIvDU.png" alt="&quot;test&quot;: &quot;jest&quot;"></p>
<ol start="4">
<li>如此即可運行 <code>npm run test</code> 進行測試，看到 PASS 可知測試有成功：</li>
</ol>
<p><img src="https://i.imgur.com/KGT6Vht.png" alt="test"></p>
<p>之所以要用 npm 來跑 jest，而不是直接在終端機輸入 jest 指令，是因為 jest 只安裝在該專案底下，要使用時才會拿出來用。</p>
<p>若只想測特定檔案，可以修改 <code>&quot;scripts&quot;</code>：<code>&quot;test&quot;: &quot;jest index.test.js&quot;</code>，後面加上檔名。</p>
<p><img src="https://i.imgur.com/4byHuvz.png"></p>
<p>或是用 <code>npx jest index.jest.js</code>，同樣能夠執行測試：</p>
<p><img src="https://i.imgur.com/VGCuYis.png"></p>
<p>也可以多跑幾個測式：</p>
<pre><code class="js">var repeat = require(&#39;./index&#39;)

test(&#39;a 重複 5 次應該要等於aaaaa&#39;, function() &#123;
  expect(repeat(&#39;a&#39;, 5)).toBe(&#39;aaaaa&#39;);
&#125;);

test(&#39;abc 重複 1 次應該要等於abc&#39;, function () &#123;
  expect(repeat(&#39;abc&#39;, 1)).toBe(&#39;abc&#39;);
&#125;);

test(&#39; &quot;&quot; 重複 10 次應該要等於 &quot;&quot;&#39;, function () &#123;
  expect(repeat(&#39;&#39;, 10)).toBe(&#39;&#39;);
&#125;);</code></pre>
<p><img src="https://i.imgur.com/Ief4HX8.png" alt="測試結果"></p>
<p>也可以把測試項目放在 <code>describe()</code> 函式裡，這種寫法會更有結構一點：</p>
<pre><code class="js">// 架構：

`describe(&#39;測試 XX&#39;, function()&#123;
  test(&#39;名稱&#39;, function() &#123;
    expect(&#39;回傳值&#39;).toBe(&#39;預期結果&#39;);
  &#125;)
&#125;)`</code></pre>
<pre><code class="js">var repeat = require(&#39;./index&#39;)

describe(&#39;測試 repeat&#39;, function() &#123;
  test(&#39;a 重複 5 次應該要等於aaaaa&#39;, function () &#123;
    expect(repeat(&#39;a&#39;, 5)).toBe(&#39;aaaaa&#39;);
  &#125;);

  test(&#39;abc 重複 1 次應該要等於abc&#39;, function () &#123;
    expect(repeat(&#39;abc&#39;, 1)).toBe(&#39;abc&#39;);
  &#125;);

  test(&#39; &quot;&quot; 重複 10 次應該要等於 &quot;&quot;&#39;, function () &#123;
    expect(repeat(&#39;&#39;, 10)).toBe(&#39;&#39;);
  &#125;);
&#125;)</code></pre>
<h3 id="Unit-test-單元測試"><a href="#Unit-test-單元測試" class="headerlink" title="Unit test 單元測試"></a>Unit test 單元測試</h3><p>單元測試指的是測試一個工作單元（a unit of work）的行為。上述範例測試單一函式，就是一種單元測試。可用來確認每個 Unit 是否正確，也能夠進行規模化測試。</p>
<hr>
<h3 id="補充：如何在-Windows-上執行-Jest-也能有紅綠標籤"><a href="#補充：如何在-Windows-上執行-Jest-也能有紅綠標籤" class="headerlink" title="補充：如何在 Windows 上執行 Jest 也能有紅綠標籤"></a>補充：如何在 Windows 上執行 Jest 也能有紅綠標籤</h3><p>方法：把 <code>package.json</code> 裡的 <code>&quot;script&quot;</code> 中的內容改為 <code>&quot;test&quot;: &quot;jest --colors&quot;</code>，FAIL 和 PASS 標籤就會是紅綠標籤。</p>
<p><img src="https://i.imgur.com/LaX4cI3.png" alt="color"></p>
<p>奇怪的是，在 git commit 時都沒有問題，在執行 Jest 時卻出現亂碼。不太確定是不是因為更改 locale 才解決的，總之介面很神奇的變成中文了，可喜可賀。</p>
<p><img src="https://i.imgur.com/4OCokvV.png" alt="UTF-8"></p>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2plc3QvaXNzdWVzLzM4Nzc=">Colorful output in Bash terminal does not work (–colors option) <i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h3 id="先寫測試再寫程式：TDD"><a href="#先寫測試再寫程式：TDD" class="headerlink" title="先寫測試再寫程式：TDD"></a>先寫測試再寫程式：TDD</h3><p>Test-driven Development（測試驅動開發），是一種開發流程，簡言之就是「先寫測試在開發」。相較於傳統的「先開發在寫測試」模式，TDD 有幾項優點：</p>
<ol>
<li>能確保測試程式的撰寫</li>
<li>從使用方觀點切入，有助於在開發初期釐清程式介面如何設計</li>
<li>便於日後 Debug</li>
</ol>
<h3 id="實作-TDD"><a href="#實作-TDD" class="headerlink" title="實作 TDD"></a>實作 TDD</h3><p>可利用 Jest 模組，先建立 <code>test()</code> 架構，再來撰寫主要程式碼。步驟可參考：<span class="exturl" data-url="aHR0cHM6Ly90dy5hbHBoYWNhbXAuY28vYmxvZy90ZGQtdGVzdC1kcml2ZW4tZGV2ZWxvcG1lbnQtZXhhbXBsZQ==">TDD 開發五步驟，帶你實戰 Test-Driven Development 範例<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="步驟一、選定一個目標功能，來新增測試案例"><a href="#步驟一、選定一個目標功能，來新增測試案例" class="headerlink" title="步驟一、選定一個目標功能，來新增測試案例"></a>步驟一、選定一個目標功能，來新增測試案例</h4><p>先寫好測試預期結果，並盡量列出邊界條件。在這個步驟還不會撰寫目標程式內容。這裡用 <code>reverse</code> 函式為例：</p>
<pre><code class="js">// 先寫出預期結果：

var reverse = require(&#39;./index&#39;)

describe(&#39;測試 reverse&#39;, function() &#123;
  test(&#39;123 reverse 要等於 321&#39;, function () &#123;
    expect(reverse(&#39;123&#39;)).toBe(&#39;321&#39;);
  &#125;);

  test(&#39;!!! reverse 要等於 !!!&#39;, function () &#123;
    expect(reverse(&#39;!!!&#39;)).toBe(&#39;!!!&#39;);
  &#125;);

  test(&#39; &quot;&quot; reverse 要等於 &quot;&quot;&#39;, function () &#123;
    expect(reverse(&#39;&#39;)).toBe(&#39;&#39;);
  &#125;);
&#125;)</code></pre>
<h4 id="步驟二、執行測試，得到-Failed（紅燈）"><a href="#步驟二、執行測試，得到-Failed（紅燈）" class="headerlink" title="步驟二、執行測試，得到 Failed（紅燈）"></a>步驟二、執行測試，得到 Failed（紅燈）</h4><p>因為還沒撰寫目標程式，結果就會是 Failed。此步驟目的是確保測試程式可執行，沒有語法錯誤。</p>
<p><img src="https://i.imgur.com/A38CQ2C.png" alt="運行測試"></p>
<h4 id="步驟三、實作「最低限度」的產品程式"><a href="#步驟三、實作「最低限度」的產品程式" class="headerlink" title="步驟三、實作「最低限度」的產品程式"></a>步驟三、實作「最低限度」的產品程式</h4><p>開始寫程式，以能夠通過測試為目標，不求將程式碼優化一步到位。完成到一個階段就可運行 jest 查看是否有錯誤：</p>
<pre><code class="js">//開始寫程式

function reverse(str) &#123;
  let result = &#39;&#39;
  for (let i = str.length - 1; i &gt;= 0; i -= 1) &#123;
    result += str[i]
  &#125;
  return result
&#125;

module.exports = reverse</code></pre>
<h4 id="步驟四：再次執行測試，得到-Passed（綠燈）"><a href="#步驟四：再次執行測試，得到-Passed（綠燈）" class="headerlink" title="步驟四：再次執行測試，得到 Passed（綠燈）"></a>步驟四：再次執行測試，得到 Passed（綠燈）</h4><p>在這個階段，即完成一個可運作且正確的程式版本，包含產品程式和測試程式。</p>
<p><img src="https://i.imgur.com/dJHNZ1j.png" alt="Passed"></p>
<h4 id="步驟五：重構程式"><a href="#步驟五：重構程式" class="headerlink" title="步驟五：重構程式"></a>步驟五：重構程式</h4><p>最後是優化「產品程式」和「測試程式」的程式碼，因為測試程式也是專案需維護的一部份。如此即可提升程式的可讀性、可維護性、擴充性。</p>
<hr>
<h2 id="什麼是-ECMAScript"><a href="#什麼是-ECMAScript" class="headerlink" title="什麼是 ECMAScript"></a>什麼是 ECMAScript</h2><p>是一種標準和規範，Javascript 這門語言就是遵循 ECMAScript 規範實作。於 2015 年發布 ECMAScript 第六版，因此又稱 ES2015 或 ES6，在 ES6 之前的版本就稱作 ES5。</p>
<p>目前大部分的瀏覽器均支援 ES6，但仍有少數舊型不支援。因此我們可以透過 Babel 轉譯器，將 ES6 代碼轉換為 ES5 代碼，如此就不須擔心支援問題。</p>
<h2 id="ES6-新語法"><a href="#ES6-新語法" class="headerlink" title="ES6 新語法"></a>ES6 新語法</h2><h3 id="宣告變數-let-與-const"><a href="#宣告變數-let-與-const" class="headerlink" title="宣告變數 let 與 const"></a>宣告變數 let 與 const</h3><ul>
<li>ES5：使用 var</li>
<li>ES6：使用 let 與 const</li>
</ul>
<p>兩者最大差異在於：</p>
<ol>
<li>重複宣告：const 用於宣告常數，不會被重新賦值</li>
<li>作用域不同：<ul>
<li>var：作用於整個函數範圍中（function scope）</li>
<li>let 與 const：均為區塊作用域（block scope），如此可避免污染到大括號外的變數</li>
</ul>
</li>
</ol>
<h3 id="Template-Literals-模板字串符"><a href="#Template-Literals-模板字串符" class="headerlink" title="Template Literals 模板字串符"></a>Template Literals 模板字串符</h3><p>Template 的意思是樣板。Template Literals 可用於字串拼接。</p>
<h4 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h4><ul>
<li>使用單引號（<code>&#39;&#39;</code>）或雙引號（<code>&quot;&quot;</code>）</li>
<li>缺點：必須用 <code>+</code> 或 <code>,</code> 來串接字串，且無法換行</li>
</ul>
<h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><ul>
<li>使用反引號（``）</li>
<li>優點：可用於多行字串拼接，也可在反引號中放入 <code>$&#123;變數&#125;</code></li>
</ul>
<h3 id="Destructuring-解構賦值"><a href="#Destructuring-解構賦值" class="headerlink" title="Destructuring 解構賦值"></a>Destructuring 解構賦值</h3><ul>
<li>可以把陣列或物件的資料解開，並擷取成獨立的變數</li>
</ul>
<h3 id="Spread-Operator-展開運算子"><a href="#Spread-Operator-展開運算子" class="headerlink" title="Spread Operator 展開運算子"></a>Spread Operator 展開運算子</h3><ul>
<li>使用 <code>...</code> 運算子，展開陣列或物件</li>
</ul>
<h3 id="Rest-Parameters-其餘參數"><a href="#Rest-Parameters-其餘參數" class="headerlink" title="Rest Parameters 其餘參數"></a>Rest Parameters 其餘參數</h3><ul>
<li>使用 … 運算子，集合剩餘的元素變成陣列，就可以在不確定陣列長度的情況下，傳入參數。</li>
</ul>
<h3 id="Default-Parameters-設定參數預設值"><a href="#Default-Parameters-設定參數預設值" class="headerlink" title="Default Parameters 設定參數預設值"></a>Default Parameters 設定參數預設值</h3><ul>
<li>可以幫參數加入預設值</li>
</ul>
<h3 id="箭頭函式"><a href="#箭頭函式" class="headerlink" title="箭頭函式"></a>箭頭函式</h3><ul>
<li>Arrow Function，縮寫為 function</li>
<li>優點：簡化程式碼，幫助閱讀</li>
</ul>
<h3 id="Import-amp-Export-引入與輸出"><a href="#Import-amp-Export-引入與輸出" class="headerlink" title="Import &amp; Export 引入與輸出"></a>Import &amp; Export 引入與輸出</h3><ul>
<li>引入與輸出 module，類似 <code>require</code> 與 <code>module.exports</code> 的用法</li>
</ul>
<h3 id="Babel-簡介"><a href="#Babel-簡介" class="headerlink" title="Babel 簡介"></a>Babel 簡介</h3><ul>
<li>是一種 JavaScript 轉譯器，可將 ES6 新語法轉換為 ES5 舊語法</li>
<li>安裝指令：<code>npm install babel-loader @babel/core @babel/preset-env --save-dev</code></li>
</ul>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BodWxpdHcvdmFyaWFibGUtYW5kLWZyb250ZGVzay1hNTNhMDQ0MGFmM2M=">從博物館寄物櫃理解變數儲存模型<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtaWFoc3V3b3JrLyVFNyVBQyVBQyVFNSU5QiU5QiVFOSU4MCVCMS1qYXZhc2NyaXB0LWVzNi0lRTglODglODctYmFiZWwtNWI1ZTI1NDUwNzY3">[第五週] JavaScript — ES6 與 Babel<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 7] DOM 介面、瀏覽器事件處理</title>
    <url>/javascript-event/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUxMDItamF2YXNjcmlwdA==">[FE102] 前端必備：JavaScript<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<pre><code>學習目標：

 P1 你知道 JavaScript 跑在網頁上跟跑在 Node.js 上差在哪裡
 P1 你知道 DOM 是什麼
 P1 你知道如何用 JavaScript 操控 DOM 物件
 P1 你知道如何幫一個按鈕加上 event listener</code></pre>
<a id="more"></a>
<hr>
<p>當我們運用 JavaScript 在網頁進行操作時，主要可分為下列三大面向：</p>
<ol>
<li>介面（Interface）：如何改變介面</li>
<li>事件（Event）：如何監聽事件並做出反應</li>
<li>資料（Data）：如何和伺服器交換資料</li>
</ol>
<blockquote>
<p>以下主要探討「改變介面」與「事件監聽」的部分。</p>
</blockquote>
<h2 id="JavaScript-與瀏覽器的溝通"><a href="#JavaScript-與瀏覽器的溝通" class="headerlink" title="JavaScript 與瀏覽器的溝通"></a>JavaScript 與瀏覽器的溝通</h2><p>那麼，該把 <code>&lt;script&gt;</code> 標籤放在哪呢？首先要瞭解，我們可以放在 HTML 檔案的任何位置，通常會有兩種回答：</p>
<ol>
<li>放在 <code>&lt;head&gt;</code> … <code>&lt;/head&gt;</code> 之間</li>
<li>放在 <code>&lt;/body&gt;</code> 之前</li>
</ol>
<p>由於瀏覽器是由上而下渲染，相較之下以第二種方法較佳。但更好的做法，是另外新增 js 檔，以外連檔的形式執行 JS，更有助於管理與維護。</p>
<pre><code class="htmlmixed=">&lt;head&gt;
  &lt;title&gt;This is title.&lt;/title&gt;
  &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;</code></pre>
<h3 id="執行環境"><a href="#執行環境" class="headerlink" title="執行環境"></a>執行環境</h3><p>我們可以在 Node.js 或瀏覽器執行 JS。由於兩者是不同的執行環境，在語法支援度也有些微差異。</p>
<blockquote>
<p>例如：</p>
<ol>
<li>require() 引入模組的語法，只能在 Node.js上執行</li>
<li>alert() 叫出提示窗，只能在瀏覽器上執行</li>
</ol>
</blockquote>
<h3 id="DOM-是什麼？"><a href="#DOM-是什麼？" class="headerlink" title="DOM 是什麼？"></a>DOM 是什麼？</h3><p>DOM，全名是 Document Object Model（文件物件模型）。</p>
<p>是由「瀏覽器」提供用來和「程式語言」溝通的橋樑。最常被用在網頁與 JavaScript 的溝通。</p>
<p>DOM 類似於把 HTML 的文件（Document）轉成物件（Object）。JavaScript 即可透過 DOM 提供的 API 來存取並操作 HTML。</p>
<p><img src="https://i.imgur.com/yR0I3JG.png" alt="DOM"></p>
<h3 id="如何選取-DOM-元素"><a href="#如何選取-DOM-元素" class="headerlink" title="如何選取 DOM 元素"></a>如何選取 DOM 元素</h3><p>document 是瀏覽器提供的特殊物件，內部放著許多 function。而我們可以透過「物件」的方式去呼叫想要的元素：</p>
<ul>
<li>根據 Tag 名稱選取：<code>document.getElementsByTagName()</code></li>
<li>根據 Class 名稱選取：<code>document.getElementsByClassName()</code></li>
<li>根據 ID 名稱選取：<code>document.getElementById()</code></li>
<li>選取 CSS 選擇器：<code>document.querySelector()</code></li>
</ul>
<p>以 <code>document.getElementsByTagName(&#39;div&#39;)</code>，選取所有 tag 名稱是 div 元素為範例：</p>
<pre><code class="htmlmixed=">&lt;body&gt;
  &lt;div&gt;
    This is tagName.
    &lt;div class=&quot;box&quot;&gt;This is className.&lt;/div&gt;
    &lt;div id=&quot;name&quot;&gt;This is idName.&lt;/div&gt;
  &lt;/div&gt;

  &lt;script&gt;
    const elements = document.getElementsByTagName(&#39;div&#39;)
    console.log(elements)
  &lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>在瀏覽器運行結果，會得到類陣列如下：</p>
<p><img src="https://i.imgur.com/8i7ohCd.png" alt="Tag"></p>
<p>若改選取 <code>elements[1]</code>，即可選取類陣列中的元素：</p>
<p><img src="https://i.imgur.com/4LdiX9r.png" alt="類陣列"></p>
<p>若根據 Class 和 ID 名稱選取，也是類似用法：</p>
<ul>
<li><code>document.getElementsByClassName(&#39;box&#39;)</code>：括弧內不需加 <code>.</code> 即可表示 class</li>
</ul>
<p><img src="https://i.imgur.com/O5eCQ6y.png" alt="Class"></p>
<ul>
<li><code>document.getElementById(&#39;name&#39;)</code>：注意 ID 只會有一個</li>
</ul>
<p><img src="https://i.imgur.com/fia65T6.png" alt="Id"></p>
<p>相較於前面三種選取方式，又以 querySelector 更方便且直覺。就像寫 CSS 選擇器來選取元素：</p>
<ul>
<li>選取標籤：<code>const element = document.querySelector(&#39;div&#39;)</code></li>
<li>選取 class：<code>const element = document.querySelector(&#39;.box&#39;)</code></li>
<li>選取 id：<code>const element = document.querySelector(&#39;#name&#39;)</code></li>
</ul>
<p>但 <code>querySelector()</code> 只會選取第一個匹配的元素，舉例如下：</p>
<pre><code class="htmlmixed=">&lt;body&gt;

  &lt;a href=&quot;#&quot;&gt;1st&lt;/a&gt;

  &lt;div&gt;
    &lt;a href=&quot;#&quot;&gt;2rd&lt;/a&gt;
  &lt;/div&gt;

  &lt;script&gt;
    const element = document.querySelector(&#39;a&#39;)
    console.log(element)
  &lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>結果只會選取第一個 <code>&lt;a&gt;</code>：</p>
<p><img src="https://i.imgur.com/ZE1Ue7g.png" alt="querySelector"></p>
<p>若想選取到所有匹配到的元素，可使用 <code>querySelectorAll()</code>：</p>
<pre><code class="htmlmixed="> const element = document.querySelectorAll(&#39;a&#39;)</code></pre>
<p>同樣能夠得到類陣列：</p>
<p><img src="https://i.imgur.com/ih6mj9T.png" alt="querySelectorAll"></p>
<h3 id="改變元素的-CSS：-style"><a href="#改變元素的-CSS：-style" class="headerlink" title="改變元素的 CSS：.style"></a>改變元素的 CSS：<code>.style</code></h3><ul>
<li>直接寫上行內樣式</li>
</ul>
<pre><code class="htmlmixed=">const element = document.querySelector(&#39;.box&#39;)

element.style.background = &#39;red&#39;;
element.style.paddingTop = &#39;10px&#39;;         // 駝峰式
element.style[&quot;padding-top&quot;] = &#39;10px&#39;;     // 字串</code></pre>
<ul>
<li>但這種寫法其實不易修改，因此並不推薦。通常會寫好另外的 class，藉由「改變元素的 class」來套用該狀態，也就是下面要介紹的方法。</li>
</ul>
<h3 id="改變元素的-Class：-classList"><a href="#改變元素的-Class：-classList" class="headerlink" title="改變元素的 Class：.classList"></a>改變元素的 Class：<code>.classList</code></h3><ul>
<li><code>.classList.add()</code>：增加</li>
<li><code>.classList.remove()</code>：移除</li>
<li><code>.classList.toggle()</code>：開關（有就刪、沒有就加）</li>
<li><code>.classList.contains()</code>：判斷是否包含該 class</li>
</ul>
<pre><code class="htmlmixed=">&lt;style&gt;
.active &#123; 
  background: red;
&#125;
&lt;/style&gt;
element.classList.add(&#39;active&#39;)
&lt;!-- 將元素套用 active 這個 class 的樣式 --&gt;</code></pre>
<h3 id="改變元素的內容"><a href="#改變元素的內容" class="headerlink" title="改變元素的內容"></a>改變元素的內容</h3><ul>
<li><code>.innerText</code>：只抓取標籤內的文字。最常用來改變文字內容。</li>
</ul>
<pre><code class="htmlmixed=">&lt;div&gt;
  &lt;div class=&quot;box&quot;&gt;This is &lt;span&gt;class&lt;/span&gt;.&lt;/div&gt;
  &lt;div id=&quot;name&quot;&gt;This is id.&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  const element = document.querySelector(&#39;.box&#39;)
  console.log(element.innerText)
&lt;/script&gt;
&lt;!-- 印出：This is class. --&gt;</code></pre>
<ul>
<li><code>.innerHTML</code>：抓取標籤內的所有內容，包含 HTML 標籤。</li>
</ul>
<pre><code class="htmlmixed=">&lt;div&gt;
  &lt;div class=&quot;box&quot;&gt;This is &lt;span&gt;class&lt;/span&gt;.&lt;/div&gt;
  &lt;div id=&quot;name&quot;&gt;This is id.&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  const element = document.querySelector(&#39;.box&#39;)
  console.log(element.innerHTML)
&lt;/script&gt;
&lt;!-- 印出：This is &lt;span&gt;class&lt;/span&gt;. --&gt;</code></pre>
<ul>
<li><code>.outerHTML</code>：抓取整個元素，可用來重新設置元素本身。較少使用。</li>
</ul>
<pre><code class="htmlmixed=">&lt;div class=&quot;block&quot;&gt;
  &lt;div class=&quot;box&quot;&gt;This is &lt;span&gt;class&lt;/span&gt;.&lt;/div&gt;
  &lt;div id=&quot;name&quot;&gt;This is id.&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  const element = document.querySelector(&#39;.box&#39;)
  console.log(element.outerHTML)
&lt;/script&gt;
&lt;!-- 印出：&lt;div class=&quot;box&quot;&gt;This is &lt;span&gt;class&lt;/span&gt;.&lt;/div&gt; --&gt;</code></pre>
<h3 id="刪除與插入元素：removechild-與-appendChild"><a href="#刪除與插入元素：removechild-與-appendChild" class="headerlink" title="刪除與插入元素：removechild 與 appendChild"></a>刪除與插入元素：removechild 與 appendChild</h3><ul>
<li><code>.removechild()</code>：移除子元素</li>
</ul>
<pre><code class="htmlmixed=">&lt;div class=&quot;block&quot;&gt;
  &lt;div class=&quot;box&quot;&gt;This is &lt;span&gt;class&lt;/span&gt;.&lt;/div&gt;
  &lt;a&gt;This is a.&lt;/a&gt;
&lt;/div&gt;

&lt;script&gt;
  const element = document.querySelector(&#39;.block&#39;)
  element.removeChild(document.querySelector(&#39;a&#39;))
&lt;/script&gt;
&lt;!-- 成功刪除在 block 元素底下，標籤為 a 的元素 --&gt;</code></pre>
<ul>
<li><code>.appendChild()</code>：插入元素在最後方</li>
</ul>
<ol>
<li>插入元素之前，要先建立元素或文字：<ul>
<li><code>const newElement = document.createElement(&#39;h2&#39;)</code></li>
<li><code>const newTextElement = document.createTextNode(&#39;Hello World&#39;)</code></li>
</ul>
</li>
<li>增加節點：<ul>
<li><code>element.appendChild(newElement)</code></li>
<li><code>element.appendChild(newTextElement)</code></li>
</ul>
</li>
</ol>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BodWdoX1Byb2dyYW1fbGVhcm5pbmdfZGlhcnlfSnMvJUU1JTg5JThEJUU3JUFCJUFGJUU1JTlGJUJBJUU3JUE0JThFLWphdmFzY3JpcHQlRTclQUYlODctamF2YXNjcmlwdC0lRTglODglODclRTclODAlOEYlRTglQTYlQkQlRTUlOTklQTglRTclOUElODQlRTYlQkElOUQlRTklODAlOUEtZTAwZmYwNWQwZmRj">前端基礎JavaScript篇：JavaScript 與瀏覽器的溝通| by Hugh’s Program learning<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaGFwcHljb2RpbmcudG9kYXkvcG9zdHMvNDM=">JavaScript入門系列：BOM和DOM筆記| 快樂學程式<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9qc3JlZi9kb20tb2JqLWRvY3VtZW50Lmh0bWw=">HTML DOM 元素<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h2 id="JavaScript-網頁事件處理"><a href="#JavaScript-網頁事件處理" class="headerlink" title="JavaScript 網頁事件處理"></a>JavaScript 網頁事件處理</h2><p>JavaScript 是以事件驅動（Event-driven）的程式語言。</p>
<p>也就是說，當 JS 被瀏覽器載入後並不會馬上執行，而是透過使用者操作來觸發事件，才會啟動對應程式。例如：滑鼠點擊、鍵盤輸入等。</p>
<blockquote>
<p>可參考：<span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS9qc3JlZi9kb21fb2JqX2V2ZW50LmFzcA==">HTML DOM Event 對象列表<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="監聽事件-addEventListener"><a href="#監聽事件-addEventListener" class="headerlink" title="監聽事件 addEventListener()"></a>監聽事件 <code>addEventListener()</code></h3><p>在處理事件時，通常會需要指派監聽者（Event listeners）來監聽事件觸發。</p>
<p>也就是監測 DOM 中的某一元素，當使用者觸發某事件時，就會執行後續動作，語法如下：</p>
<pre><code class="javascript=">element.addEventListener(&#39;event&#39;, function, useCapture)</code></pre>
<h3 id="參數值說明"><a href="#參數值說明" class="headerlink" title="參數值說明"></a>參數值說明</h3><h4 id="1-event-事件"><a href="#1-event-事件" class="headerlink" title="1. event 事件"></a>1. event 事件</h4><ul>
<li>必須</li>
<li>指定事件類型</li>
<li>常見的事件類別：（詳見 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvRXZlbnRz">MDN<i class="fa fa-external-link-alt"></i></span>）<ul>
<li>滑鼠相關：click、mousedown、mouseenter、mouseleave</li>
<li>鍵盤相關：keydown、keypress、keyup</li>
<li>瀏覽器相關：scroll、resize</li>
</ul>
</li>
</ul>
<h4 id="2-function-功能"><a href="#2-function-功能" class="headerlink" title="2. function 功能"></a>2. function 功能</h4><ul>
<li>必須</li>
<li>指定事件觸發時執行的函式</li>
</ul>
<p>而 function 的部分有下列兩種寫法，以最常見的 click 做舉例：</p>
<ul>
<li>直接將函式作為參數帶入：回呼函式（callback function）</li>
</ul>
<pre><code class="javascript=">const element = document.querySelector(&#39;.box&#39;)
// 先註冊一個事件
element.addEventListener(&#39;click&#39;, onClick())

// 等事件被觸發才執行 callback function
function onClick()&#123;     
   alert(&#39;click!&#39;)
&#125;</code></pre>
<ul>
<li>匿名函式（anonymous）</li>
</ul>
<pre><code class="javascript=">const element = document.querySelector(&#39;.box&#39;)

element.addEventListener(&#39;click&#39;, function()&#123;
   alert(&#39;click!&#39;)
&#125;)</code></pre>
<h4 id="3-useCapture"><a href="#3-useCapture" class="headerlink" title="3. useCapture"></a>3. useCapture</h4><ul>
<li>可選</li>
<li>布林值，指定事件在捕獲或冒泡階段執行<ol>
<li>true：補獲</li>
<li>false：冒泡（預設值）</li>
</ol>
</li>
</ul>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDE5MTk3MA==">重新認識 JavaScript: Day 14 事件機制的原理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9qc3JlZi9tZXQtZWxlbWVudC1hZGRldmVudGxpc3RlbmVyLmh0bWw=">HTML DOM addEventListener()方法<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<h3 id="事件資訊-event-e"><a href="#事件資訊-event-e" class="headerlink" title="事件資訊 event(e)"></a>事件資訊 <code>event(e)</code></h3><p>一個事件的發生會包含各種資訊。event 資訊會放在 callback function 的第一個參數。通常取名 <code>event</code> 或簡寫 <code>e</code>，可以當作是一個「物件」，裡面放著關於此事件的參數值。</p>
<p>以 click 事件為例：</p>
<pre><code class="javascript=">const element = document.querySelector(&#39;.box&#39;)

element.addEventListener(&#39;click&#39;, function(e) &#123;
  console.log(e)
&#125;)</code></pre>
<p>點擊元素後會出現下列資訊：</p>
<p><img src="https://i.imgur.com/JJEo1ZR.png" alt="event"></p>
<p>我們可以用「物件」的方式來取得需要的元素，以常用的事件資訊為例。</p>
<h3 id="常用的事件資訊"><a href="#常用的事件資訊" class="headerlink" title="常用的事件資訊"></a>常用的事件資訊</h3><h4 id="click-事件：點擊-DOM-元素時觸發"><a href="#click-事件：點擊-DOM-元素時觸發" class="headerlink" title="click 事件：點擊 DOM 元素時觸發"></a>click 事件：點擊 DOM 元素時觸發</h4><ul>
<li>e.target：點擊到的元素</li>
<li>e.screenX：滑鼠離視窗左邊的距離</li>
<li>e.screenY：滑鼠離視窗上邊的距離</li>
</ul>
<h4 id="keydown-事件：按下鍵盤時觸發"><a href="#keydown-事件：按下鍵盤時觸發" class="headerlink" title="keydown 事件：按下鍵盤時觸發"></a>keydown 事件：按下鍵盤時觸發</h4><ul>
<li>e.key：按鍵號碼</li>
</ul>
<h4 id="submit-事件：提交表單前觸發，通常用來驗證表單內容"><a href="#submit-事件：提交表單前觸發，通常用來驗證表單內容" class="headerlink" title="submit 事件：提交表單前觸發，通常用來驗證表單內容"></a>submit 事件：提交表單前觸發，通常用來驗證表單內容</h4><p>首先建立一個簡易表單：</p>
<pre><code class="htmlmixed=">  &lt;form class=&quot;login-form&quot;&gt;
    &lt;div class=&quot;account&quot;&gt;
      Account: &lt;input name=&quot;account&quot; type=&quot;text&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;password&quot;&gt;
      Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;password2&quot;&gt;
      Password again: &lt;input name=&quot;password2&quot; type=&quot;password&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;submit&quot;&gt;
      &lt;input name=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt;
    &lt;/div&gt;
  &lt;/form&gt;</code></pre>
<p><img src="https://i.imgur.com/wWjVaIv.png" alt="form"></p>
<p>點選表單中的 submit 按鈕後，會以預設方法 <code>GET</code> 送出資料，也就是把參數帶入原網址送出。而 submit 事件是在表單送出前觸發，通常用來驗證表單內容。</p>
<p>以點選 submit 後彈出視窗為例：</p>
<pre><code class="javascript=">  const element = document.querySelector(&#39;.login-form&#39;)
  element.addEventListener(&#39;submit&#39;, function () &#123;
    alert(&quot;成功&quot;)
&#125;)</code></pre>
<p><img src="https://i.imgur.com/grkuUrS.png"></p>
<h3 id="阻止預設行為-e-preventDefault"><a href="#阻止預設行為-e-preventDefault" class="headerlink" title="阻止預設行為 e.preventDefault()"></a>阻止預設行為 <code>e.preventDefault()</code></h3><p>用來阻止瀏覽器上特定元素的預設行為。以下為常見使用方式：</p>
<ul>
<li><code>&lt;form&gt;</code> 的 submit 事件：阻止送出表單</li>
<li><code>&lt;a&gt;</code> 的 click 事件：阻止轉址</li>
<li><code>&lt;input&gt;</code> 的 keypress 事件：阻止輸入按鍵</li>
</ul>
<p>以上述例子來說，當 Password 跟 Password again 輸入的值不同時，就可使用 <code>e.preventDefault()</code> 來阻止表單送出：</p>
<pre><code class="javascript=">&lt;script&gt;
  const element = document.querySelector(&#39;.login-form&#39;);

  element.addEventListener(&#39;submit&#39;, function(e) &#123;
    const pw1 = document.querySelector(&#39;input[name=&quot;password1&quot;]&#39;);
    const pw2 = document.querySelector(&#39;input[name=&quot;password2&quot;]&#39;);
    // 若密碼不同，就不送出表單
    if (pw1.value !== pw2.value) &#123;
      alert(&#39;密碼不同！&#39;)
      e.preventDefault();
    &#125; 
  &#125;);
&lt;/script&gt;</code></pre>
<p><img src="https://i.imgur.com/vjBsv0i.png"></p>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly95YWtpbWhzdS5jb20vcHJvamVjdC9wcm9qZWN0X3c3X0RPTS5odG1s">[第七週] DOM - 操作 DOM 介面、事件監聽 - Yakim<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtaWFoc3V3b3JrLyVFNyVBQyVBQyVFNSU4NSVBQiVFOSU4MCVCMS1kb20tJUU3JTgwJThGJUU4JUE2JUJEJUU1JTk5JUE4JUU0JUJBJThCJUU0JUJCJUI2JUU4JTk5JTk1JUU3JTkwJTg2LWZiOGY2MTc4MTc4YQ==">[第八週]DOM — 瀏覽器事件處理 - Miahsu<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 16] JavaScript 進階 - What is this？</title>
    <url>/javascript-this/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvanMyMDEtamF2YXNjcmlwdA==">[JS201] 進階 JavaScript：那些你一直搞不懂的地方<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<pre><code>學習目標：

 P1 你知道大部分情況下 this 的值是什麼
 P2 你知道物件導向的基本概念（類別、實體、繼承、封裝）</code></pre>
<a id="more"></a>

<hr>
<h2 id="從物件導向到-this"><a href="#從物件導向到-this" class="headerlink" title="從物件導向到 this"></a>從物件導向到 this</h2><p>在上一篇<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWpzMjAxLW9vcC1wcm90b3R5cGU=">JavaScript 進階 - 物件導向 &amp; Prototype<i class="fa fa-external-link-alt"></i></span> 筆記中，其實我們就有提到 this 相關概念。this 的主要用途就在於物件導向，用來指哪個 instance 在呼叫這個 function，透過 this 我們能夠進一步操作。</p>
<p>那如果是在和物件導向無關的情況下，呼叫 this 會代表什麼？</p>
<h3 id="Global-context-下的-this"><a href="#Global-context-下的-this" class="headerlink" title="Global context 下的 this"></a>Global context 下的 this</h3><p>如果在全域環境下呼叫 this，根據不同執行環境（瀏覽器或 node.js），預設值可能會是 global 或 window：</p>
<h4 id="在-node-js-運行"><a href="#在-node-js-運行" class="headerlink" title="在 node.js 運行"></a>在 node.js 運行</h4><pre><code class="javascript=">function test() &#123;
  console.log(this);            // Object [global] &#123; ...&#125;
  console.log(this === global)  // true
&#125;
test();</code></pre>
<p><img src="https://i.imgur.com/9yFrDnZ.png"></p>
<h4 id="在瀏覽器運行"><a href="#在瀏覽器運行" class="headerlink" title="在瀏覽器運行"></a>在瀏覽器運行</h4><pre><code class="javascript=">function test() &#123;
  console.log(this);            // Window &#123; ...&#125;
  console.log(this === window)  // true
&#125;
test();</code></pre>
<p><img src="https://i.imgur.com/wVCdilg.png"></p>
<h3 id="use-strict-嚴格模式"><a href="#use-strict-嚴格模式" class="headerlink" title="use strict 嚴格模式"></a>use strict 嚴格模式</h3><p>在不需要的地方呼叫 this，卻還是會有預設值 global 或 window。這時候，只要設定 <code>&#39;use strict&#39;</code>（嚴格模式）就能避免，this 的預設值會是 undefined：</p>
<pre><code class="javascript=">&#39;use strict&#39;;
function test() &#123;
  console.log(this);
&#125;
test();  // undefined</code></pre>
<h3 id="DOM-元素中的-this"><a href="#DOM-元素中的-this" class="headerlink" title="DOM 元素中的 this"></a>DOM 元素中的 this</h3><p>此外，對 DOM 元素進行事件監聽時，this 就代表當下操作的元素，其實非常直覺。例如監聽按鈕的點擊事件，那 this 就會是那個按鈕：</p>
<pre><code class="javascript=">document.querySelector(&#39;.btn&#39;).addEventListener(&#39;click&#39;, function() &#123;
  console.log(this)   // this: 觸發這個 funciont 的物件
&#125;)</code></pre>
<p>因此我們可以說，除了在物件導向跟 DOM 之外，this 是沒有意義的。</p>
<h3 id="Function-context-下的-this"><a href="#Function-context-下的-this" class="headerlink" title="Function context 下的 this"></a>Function context 下的 this</h3><p>在 function 裡面時，this 的值是什麼取決於該 function 是怎麼被呼叫的。</p>
<p>也就是說，function 沒有被呼叫的時候，預設值就會是 window, global 或 undefined。一旦某個 function 被呼叫時，裡面的 this 就可以理解成，是指向誰在 call 這個 function：</p>
<pre><code class="javascript=">var obj = &#123;
  foo: function()&#123;
    console.log(this)
  &#125;
&#125;
var bar = obj.foo

obj.foo() // foo(): obj 在 call，obj 就是 this 
bar()   // bar(): 沒人 call，window 就是 this</code></pre>
<p>其中，<code>bar()</code> 這種呼叫函式的方法，其實是 <code>.call()</code> 的語法糖，要更詳細了解呼叫 function 背後在做的事，就要深入理解 <code>.call()</code>、<code>.apply()</code>、<code>bind()</code> 的行為。</p>
<h2 id="另外兩種呼叫-function-的方法：call-與-apply"><a href="#另外兩種呼叫-function-的方法：call-與-apply" class="headerlink" title="另外兩種呼叫 function 的方法：call 與 apply"></a>另外兩種呼叫 function 的方法：call 與 apply</h2><h3 id="call"><a href="#call" class="headerlink" title=".call()"></a><code>.call()</code></h3><p>第一個值傳入什麼 this 就是什麼。</p>
<pre><code class="javascript=">&#39;use strict&#39;;
function test() &#123;
  console.log(this);
&#125;
test.call(123);     // 123
test.call(&#123;&#125;);      // &#123;&#125;
test.call([1]);     // [ 1 ]
test.call(&#39;abc&#39;);   // &#39;abc&#39;</code></pre>
<h3 id="apply"><a href="#apply" class="headerlink" title=".apply()"></a><code>.apply()</code></h3><p>和 <code>.call()</code> 一樣，第一個值傳入什麼 this 就是什麼，差異在於第二個參數會接一個 array。</p>
<p>可由下方範例來比較三種方式呼叫 function 的差異：</p>
<pre><code class="javascript=">&#39;use strict&#39;;  // 嚴格模式
function test(a, b, c) &#123;
  console.log(this);
  console.log(a, b, c);
&#125;

test(1, 2, 3)
// undefined
// 1 2 3
test.call(123, 1, 2, 3);
// 123
// 1 2 3
test.apply(123, [1, 2, 3]);
// 123
// 1 2 3</code></pre>
<p>透過 <code>.call</code> 和 <code>.apply</code> 的第一個參數，我們可以設定 function 中 this 的值。兩者差別在於，一個可以傳入無限的參數，另外一個只能傳入兩個參數；一個要用 array 帶入參數，另一個則否。</p>
<p>此外，我們也可以把一般呼叫 function 的方式都轉成 call 的形式：</p>
<pre><code class="javascript=">const obj = &#123;
  value: 1,
  hello: function() &#123;
    console.log(this.value)
  &#125;
&#125;

obj.hello()  // 1
obj.hello.call(obj)  // 1</code></pre>
<p>再舉一個例子，透過 call 來呼叫 function，我們就能夠指定 this 的值：</p>
<pre><code class="javascript=">function hello() &#123;
  console.log(this)
&#125;

var a = &#123;
  value: 1, hello
&#125;

var b = &#123;
  value: 2, hello
&#125;

hello()  // global
a.hello()  // a &#123; value: 1, hello&#125;
b.hello.call(a)   // a &#123; value: 1, hello&#125;</code></pre>
<hr>
<h2 id="如何判斷-this-的值"><a href="#如何判斷-this-的值" class="headerlink" title="如何判斷 this 的值"></a>如何判斷 this 的值</h2><p>因為 this 是針對物件導向設計的，從以下範例，可知道 this 就是 obj 物件本身：</p>
<pre><code class="javascript=">&#39;use strict&#39;;
var obj = &#123;
  a: 10,
  test: function(a, b, c) &#123;
    console.log(this);  // obj
  &#125;
&#125;
obj.test();
// &#123; a: 10, test: [Function: test] &#125; === obj</code></pre>
<p>重點就是，this 的值和程式碼在哪無關，而是和怎麼呼叫有關係：</p>
<pre><code class="javascript=">&#39;use strict&#39;;
var obj = &#123;
  a: 10,
  test: function (a, b, c) &#123;
    console.log(this);    // obj
  &#125;
&#125;
obj.test();  // &#123; a: 10, test: [Function: test] &#125;
var func = obj.test;  // 使 func 等同於 obj.test()
func()       // undefined</code></pre>
<p>結果卻會得到不同結果，這是因為 obj 呼叫 function，所以 this 會指向 obj；另一方面，this 所在的 instance 中，沒有被 func 呼叫，所以會得到 undefined。</p>
<p>我們可以透過 <code>.call()</code> 來看看 this 指的是什麼：</p>
<pre><code class="javascript=">&#39;use strict&#39;;
var obj = &#123;
  a: 10,
  inner: &#123;
    test: function(a, b, c) &#123;
      console.log(this);
    &#125;
  &#125;
&#125;
obj.inner.test();
// &#123; test: [Function: test] &#125;

// 改用 .call() 呼叫
obj.inner.test.call(obj);
// &#123; a: 10, inner: &#123; test: [Function: test] &#125; &#125;
obj.inner.test.call(obj.inner);
// &#123; test: [Function: test] &#125;</code></pre>
<h3 id="bind-：強制綁定-this"><a href="#bind-：強制綁定-this" class="headerlink" title=".bind()：強制綁定 this"></a>.bind()：強制綁定 this</h3><p>除了 <code>.call()</code> 和 <code>.apply()</code>，我們還可以利用 <code>.bind()</code> 來強制綁定 this 的值，但需注意的是，一旦綁定之後就不能再用別的方法進行更改。</p>
<p>將前面提到的例子修改成 .bind()，這裡需注意 .bind() 會是直接回傳一個 function：</p>
<pre><code class="javascript=">&#39;use strict&#39;;
var obj = &#123;
  a: 10,
  test: function () &#123;
    console.log(this);
  &#125;
&#125;

// 第一種寫法：直接呼叫
obj.test.bind(obj)();
// &#123; a: 10, test: [Function: test] &#125;

// 第二種寫法：先宣告，再呼叫
const bindTest = obj.test.bind(obj);
bindTest();  
// &#123; a: 10, test: [Function: test] &#125;
const bindTestA = obj.test.bind(obj.test);
bindTestA();
// [Function: test]
const bindTestB = obj.test.bind(&quot;test B&quot;);
bindTestB();
// test B
const bindTestC = obj.test.bind(&quot;test C&quot;);
bindTestC.call(&#39;CCC&#39;);
// test C</code></pre>
<p>利用 <code>.bind()</code> 就可以綁定 this 的值，也就是鎖定想要呼叫的區域，即便後面再 <code>.call()</code> 指定 this 的值也無法改變。</p>
<h3 id="牛刀小試"><a href="#牛刀小試" class="headerlink" title="牛刀小試"></a>牛刀小試</h3><p>以下範例預設在嚴格模式進行：</p>
<pre><code class="javascript=">&#39;use strict&#39;;

function log() &#123;
  console.log(this);
&#125;
var a = &#123; a: 1, log: log &#125;;
var b = &#123; a: 2, log: log &#125;;

log();     
a.log();    
b.log.apply(a);</code></pre>
<p>思考步驟：</p>
<pre><code class="javascript=">1. log();
// undefined
// 在嚴格模式下，如果在非物件導向的情況呼叫 this，其值會是 undeined 

2. a.log();  
// &#123; a: 1, log: [Function: log] &#125;
// 等於 a.log.call(a)，所以 this 就是 a 本身

3. b.log.apply(a);
// &#123; a: 1, log: [Function: log] &#125;
// .apply() 會把 this 的值蓋過，所以 this 也會是 a 本身</code></pre>
<h3 id="arrow-function-的-this"><a href="#arrow-function-的-this" class="headerlink" title="arrow function 的 this"></a>arrow function 的 this</h3><p>arrow function 本身其實沒有 this，在 arrow function 裡面的 this，其實就和 arrow function 外部的 this 是同一個東西。</p>
<p>先以一般宣告 function 為例：</p>
<pre><code class="javascript=">class Test &#123;
  run() &#123;
    console.log(&#39;run this&#39;, this);
    setTimeout(function() &#123;
      console.log(this);
    &#125;, 100) 
  &#125;
&#125;
const t = new Test();
t.run();</code></pre>
<p>在瀏覽器上的運行結果，會發現第二個 this 等於全域的 Window：</p>
<p><img src="https://i.imgur.com/27kKU6Q.png"></p>
<p>也就是說，在 100 毫秒後才呼叫，其實作用就等同於在全域呼叫這個 function：</p>
<pre><code class="javascript=">function() &#123;
  console.log(this);
&#125;</code></pre>
<p>但如果改成箭頭函式，結果就會不同了：</p>
<pre><code class="javascript=">class Test &#123;
  run() &#123;
    console.log(&#39;run this&#39;, this);
    setTimeout( () =&gt; &#123;
      console.log(this);
    &#125;, 100) 
  &#125;
&#125;
const t= new Test();
t.run();</code></pre>
<p>在瀏覽器上的運行結果，此時兩個 this 會變相同：</p>
<p><img src="https://i.imgur.com/thp7RZD.png"></p>
<p>這就是箭頭函式的特性，和箭頭函式中的 this 怎麼呼叫沒關係。而是類似 Scope（作用域）的機制，看程式碼定義在哪裡，就會利用定義的 block 來呈現這個 this 的值。</p>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>瞭解到物件導向的相關概念後，接著要理解 this 是什麼就沒那麼困難了。或許是因為在實際學 JacaScript 以前，就預設 this 是很難是高手在用的東西，透過慢慢理解物件導向與 this 的關聯，以及如何判斷 this 的值，似乎也感覺到自己的進化，對於未知的恐懼總是需要克服的。</p>
<p>關於 this 的重點，就是記得 this 的值和程式碼在哪無關，而是和怎麼呼叫有關係。</p>
<p>總結前面提到的觀念，其實 this 大致可分成四種綁定方式：</p>
<ul>
<li>默認綁定</li>
</ul>
<p>在和物件導向無關的情況下，this 會被指定為全域物件。又依照執行環境不同，其值會是 global 或 window，而在嚴格模式下會是 undefined：</p>
<pre><code class="javascript=">function test() &#123;
  console.log(this);     // Window 
&#125;
test();</code></pre>
<ul>
<li>隱式綁定</li>
</ul>
<p>若在 function 中， this 有被某物件指定為屬性並呼叫，this 就是呼叫 function 的物件。以下方範例來說 this 就是 obj：</p>
<pre><code class="javascript=">function func() &#123;
  console.log(this.a);
&#125;

var obj = &#123;
  a: 4,
  test: func
&#125;;

obj.test();  // 4</code></pre>
<ul>
<li>顯示綁定</li>
</ul>
<p>若是透過 <code>.call()</code>、<code>.apply()</code> 或 <code>.bind()</code> 方式指定 this，this 就會是傳入的參數：</p>
<pre><code class="javascript=">var obj = &#123;
  a: 10,
  test: function () &#123;
    console.log(this);
  &#125;
&#125;

obj.test.call(obj)
obj.test.apply(obj)

// 第一種寫法：直接呼叫 function
obj.test.bind(obj)();
// 第二種寫法：先宣告，再呼叫
const bindTest = obj.test.bind(obj);
bindTest();  

// 均印出: &#123; a: 10, test: [Function: test] &#125;</code></pre>
<ul>
<li>new 綁定</li>
</ul>
<p>透過建構函式 new 出一個 instance，this 就會是 instance 物件本身：</p>
<pre><code class="javascript=">class Dog &#123;
  constructor(name) &#123;
    this.name = name;
    console.log(this);       // Dog &#123;name: &quot;dog A&quot;&#125;
    console.log(this.name);  // dog A
  &#125;
&#125;

var a = new Dog(&#39;dog A&#39;);</code></pre>
<ul>
<li>例外：箭頭函式中的 this 是看程式碼定義在哪，和怎麼呼叫沒關係。</li>
</ul>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRlY2hicmlkZ2UuY2MvMjAxOS8wMi8yMy9qYXZhc2NyaXB0LXRoaXMv">淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9odWdoLXByb2dyYW0tbGVhcm5pbmctZGlhcnktanMubWVkaXVtLmNvbS8lRTUlODklOEQlRTclQUIlQUYlRTQlQjglQUQlRTklOUElOEUtanMlRTQlQkIlQTQlRTQlQkElQkElRTYlOTAlOUUlRTQlQjglOEQlRTYlODclODIlRTclOUElODQlRTUlOUMlQjAlRTYlOTYlQjktdGhpcy1iOWI5YzY5NjBjMDM=">前端中階：JS令人搞不懂的地方-this<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9uaWNvbGFrYWNoYS5jb2RlcmJyaWRnZS5pby8yMDIwLzEwLzAxL29vcC1wcm90b3R5cGUtdGhpcy8=">JavaScript: Object-oriented JavaScript, Prototype Chain &amp; This<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRyZWFkMDEuY29tL2NvbnRlbnQvMTU0NDExNjk3MS5odG1s">關於this綁定的四種方式<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 16] JavaScript 進階 - 關於變數與資料型態</title>
    <url>/javascript-variable/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvanMyMDEtamF2YXNjcmlwdA==">[JS201] 進階 JavaScript：那些你一直搞不懂的地方<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<pre><code>學習目標：

 瞭解 JavaScript 有哪些的資料型態
 原始型態與物件型態在變數宣告賦值上的差異</code></pre>
<a id="more"></a>
<h2 id="JavaScript-資料型態"><a href="#JavaScript-資料型態" class="headerlink" title="JavaScript 資料型態"></a>JavaScript 資料型態</h2><p>在第二週 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvanMxMDEtamF2YXNjcmlwdA==">[JS101] 用 JavaScript 一步步打造程式基礎<i class="fa fa-external-link-alt"></i></span> 學習JavaScript 基礎時，我們就曾提及關於值的型態，以及該如何判斷資料型態。</p>
<p>而資料型態的不同，可能會造成一些操作結果與想像不符，這部分我們後面會進行討論。</p>
<p>關於值的型態，大致可分為原始型態和物件型態兩種：</p>
<h4 id="原始型態（Primitive-types）"><a href="#原始型態（Primitive-types）" class="headerlink" title="原始型態（Primitive types）"></a>原始型態（Primitive types）</h4><ol>
<li>boolean（真偽值）：ture 和 false</li>
<li>number（數字）：例如 1、3.14159、NaN（無效的數字）</li>
<li>string（字串）：例如 <code>&#39;Hello World&#39;</code></li>
<li>symbol（ES6）：例如 Sym</li>
<li>null：沒有值存在（no value）</li>
<li>undefined：值不存在（absence） </li>
</ol>
<h4 id="其他都屬於物件型態（Object-types）"><a href="#其他都屬於物件型態（Object-types）" class="headerlink" title="其他都屬於物件型態（Object types）"></a>其他都屬於物件型態（Object types）</h4><ol>
<li>object（物件）：例如 {name: heidi, number: 99}</li>
<li>array（陣列）：例如 [1, 2, 3]</li>
<li>function（函式）</li>
<li>date…etc</li>
</ol>
<h3 id="Immutable-與-Mutable"><a href="#Immutable-與-Mutable" class="headerlink" title="Immutable 與 Mutable"></a>Immutable 與 Mutable</h3><p>其中原始型態具有 Immutable（不可變動）的特性，相對於物件型態是 Mutable（可變的）。這裡指的不可變動不是「賦值」，而是不能改變原本的記憶體位置。</p>
<p>也就是說，若對其有任何變更（例如：新增、修改、刪除），就會回傳一個新值。以下列程式碼為範例：</p>
<ul>
<li>原始型態：不改變原本的值</li>
</ul>
<pre><code class="javascript=">var str = &#39;hello&#39;
var newStr = str.toUpperCase()
console.log(str, newStr)
// 印出 hello HELLO</code></pre>
<ul>
<li>物件型態：改變原本的值</li>
</ul>
<pre><code class="javascript=">var arr = [1]
arr.push(2)
console.log(arr)
// 印出 [1, 2]</code></pre>
<h2 id="typeof-lt-value-gt-：用來判斷變數型態"><a href="#typeof-lt-value-gt-：用來判斷變數型態" class="headerlink" title="typeof &lt;value&gt;：用來判斷變數型態"></a><code>typeof &lt;value&gt;</code>：用來判斷變數型態</h2><p>　<br>我們可使用 <code>typeof</code> 來判斷變數的資料型態，輸入結果會回傳一個字串，語法範例如下：</p>
<pre><code class="javascript=">console.log(&#39;typeof true&#39;, typeof true)
//輸出 typeof true boolean</code></pre>
<p>結果得到 true 的資料型態是 boolean。</p>
<p>接著我們再看看其他範例結果：</p>
<p><img src="https://i.imgur.com/rT6DR1N.png"></p>
<p>由結果可知，array  和 null 也屬於 object 型態，但前面不是說 null 的屬於原始型態嗎？這其實是 JavaScript 的歷史 bug，詳細內容可查閱下方參考資料：</p>
<blockquote>
<p>null 使用 typeof 運算子，回傳的結果會是字串 “object”，這指出 null 可被認為是象徵「無物件」（no object）的一種特殊物件值。（參考資料：<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVubG9uZy5jb20udHcvcHJvZHVjdHMvOTc4OTg2Mjc2NDQxMQ==">犀牛書<i class="fa fa-external-link-alt"></i></span>）</p>
</blockquote>
<blockquote>
<p>這其實是 JavaScript 最初發現的一個錯誤，然後被 ECMAScript 沿用至今。現在，null 被認為是物件的佔位符，從而解釋了這一矛盾。<br>（參考資料：<span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIwMDg0MQ==">你懂JavaScript 嗎？#4 型別（Types）<i class="fa fa-external-link-alt"></i></span>）</p>
</blockquote>
<p>以下是在 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL3R5cGVvZg==">MDN 網站<i class="fa fa-external-link-alt"></i></span> 列出 typeof 的可能回傳值：</p>
<p><img src="https://4.bp.blogspot.com/-dBndQxibqJ8/V3xngW8lK5I/AAAAAAAAnDU/L5PVWe-8j-gL3vzcA4xMznzsgqq4AcnkACLcB/s1600/1.png"></p>
<h3 id="利用-typeof-確認變數是否有使用到"><a href="#利用-typeof-確認變數是否有使用到" class="headerlink" title="利用 typeof 確認變數是否有使用到"></a>利用 <code>typeof</code> 確認變數是否有使用到</h3><p>我們還可以利用 <code>typeof</code> 來確認某個變數是否有使用到（是否有被宣告），以下列程式碼為例：</p>
<pre><code class="javascript=">var a
console.log(typeof a)
// 宣告 a 但還沒賦值，所以結果是 undefind</code></pre>
<p>若沒有先宣告變數 a，直接使用 <code>typeof</code> 檢查也會得到相同結果：</p>
<pre><code class="javascript=">console.log(typeof a)
// undefind</code></pre>
<p>若應用在判斷句，在有宣告變數 a 的情況：</p>
<pre><code class="javascript=">var a = 10
if (typeof a !== &#39;undefined&#39;) &#123;
  console.log(a)
&#125;
// a = 10，所以印出 10</code></pre>
<p>在不宣告變數 a 的情況下，直接利用 <code>typeof</code> 進行判斷：</p>
<pre><code class="javascript=">if (typeof a !== &#39;undefined&#39;) &#123;
  console.log(a)
&#125;
// 因為 a 是 undefined ，不符合判斷句，不會印出任何東西</code></pre>
<p>若直接判斷變數 a 是否等於 undefined，就會出現未定義 a 的錯誤：</p>
<pre><code class="javascript=">if (a !== &#39;undefined&#39;) &#123;
  console.log(a)
&#125;
// 因為 a 不存在，會印出錯誤訊息：ReferenceError: a is not defined</code></pre>
<p>因此，若使用 typeof() 來判斷 a 是否為 undefined，就能夠避免出現錯誤，導致程式中斷。</p>
<h2 id="Array-isArray-：判斷變數是否為陣列"><a href="#Array-isArray-：判斷變數是否為陣列" class="headerlink" title="Array.isArray()：判斷變數是否為陣列"></a><code>Array.isArray()</code>：判斷變數是否為陣列</h2><p>若想檢查是否為陣列，可使用函式 <code>Array.isArray()</code>，檢查傳入的值是否為一個 Array，範例如下：</p>
<pre><code class="javascript=">var a = [1, 2, 3];
console.log(Array.isArray(a))
// true
console.log(Array.isArray([]))
// true</code></pre>
<p>但使用時須注意，一些較舊的瀏覽器並不支援 <code>Array.isArray()</code> 這個語法，因此更推薦的方法如下。</p>
<h2 id="Object-prototype-toString：用來判斷型態"><a href="#Object-prototype-toString：用來判斷型態" class="headerlink" title="Object.prototype.toString：用來判斷型態"></a><code>Object.prototype.toString</code>：用來判斷型態</h2><p><code>Object.prototype.toString</code> 是另一種判斷型態的方式，結果也會比 <code>typeof</code> 還要準確，尤其物件型態會顯示更詳細的類別。</p>
<p>語法範例如下：</p>
<pre><code class="javascript=">console.log(Object.prototype.toString.call(null))
console.log(Object.prototype.toString.call([]))
console.log(Object.prototype.toString.call(1))
console.log(Object.prototype.toString.call(new Date))

// [object Null]
// [object Array]
// [object Number]
// [object Date]</code></pre>
<h2 id="等號賦值與記憶體位置"><a href="#等號賦值與記憶體位置" class="headerlink" title="等號賦值與記憶體位置"></a>等號賦值與記憶體位置</h2><p>在課程第二週 JS101 的「<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMC90aGlzLWlzLWNvZGVkaWFyeS9ibG9iL21hc3Rlci93ZWVrMl9KYXZhU2NyaXB0JTIwJUU1JTlGJUJBJUU3JUE0JThFLm1kIyVFNSVCRSU5RS1vYmplY3QtJUU3JTlBJTg0JUU3JUFEJTg5JUU4JTk5JTlGJUU3JTlDJTlGJUU2JUFEJUEzJUU3JTlBJTg0JUU3JTkwJTg2JUU4JUE3JUEzJUU4JUFFJThBJUU2JTk1JUI4">從 Object 的等號真正的理解變數<i class="fa fa-external-link-alt"></i></span>」中我們也曾提到相關概念。</p>
<p>若將變數視為一個箱子，在放入數字的情況下，兩者會相等：</p>
<pre><code class="javascript=">var a = 30
console.log(a === 30)
// 印出 true，兩者相等</code></pre>
<p>但如果在變數 obj 裡放入物件，結果卻是不相等：</p>
<pre><code class="javascript=">var obj = &#123;
  a:1
&#125;
console.log(obj === &#123;a:1&#125;)
// 印出 false，兩者不相等</code></pre>
<p>可想像成是「記憶體位置不同」導致的結果。儘管兩個箱子儲存的數值相同，但因記憶體位置不同，指向的元素不同，所以不會相等。</p>
<p>如下方示意圖：</p>
<p><img src="https://i.imgur.com/ZAY1PrG.png"></p>
<h3 id="關於-等號賦值"><a href="#關於-等號賦值" class="headerlink" title="關於 = 等號賦值"></a>關於 <code>=</code> 等號賦值</h3><p>如果換成下列情形，也就是將 obj 賦值給 obj2 時：</p>
<pre><code class="javascript=">var obj = &#123;
    a:1
&#125;
var obj2 = obj

console.log(obj === obj2)        // 印出 true</code></pre>
<p>兩者理所當然會相等，此時若以 <code>obj2.a = 2</code> 更改 obj2 物件中 a 的值，會連同 obj 的值也一起更動：</p>
<pre><code class="javascript=">var obj = &#123;
    a:1
&#125;
var obj2 = obj          // 賦值
obj2.a = 2

console.log(&#39;obj&#39;, obj2)       // obj &#123; a: 2 &#125;
console.log(&#39;obj2&#39;, obj2)      // obj2 &#123; a: 2 &#125;
console.log(obj === obj2)      // 印出 true，兩者相等</code></pre>
<p>之所以 obj 的值也一起被更改，是因為 obj 和 obj2 指向了相同記憶體位置（0x01），也就是指向同一個物件：</p>
<p><img src="https://i.imgur.com/cgfJMmd.png"></p>
<p>但如果以 <code>obj2 = &#123;b:1&#125;</code> 將 obj2 賦值一個新的物件，此時就會指向一個新的記憶體位置。以下方程式碼為例：</p>
<pre><code class="javascript=">var obj = &#123;
  a:1
&#125;
var obj2 = obj
obj2.a = 2
obj2 = &#123;b:1&#125;

console.log(&#39;obj&#39;, obj2)         // obj &#123; a: 2 &#125;
console.log(&#39;obj2&#39;, obj2)        // obj2 &#123; b: 1 &#125;
console.log(obj === obj2)        // 印出 false，兩者不相等</code></pre>
<p>會發現 obj2 和 obj 不相等，這是因為「往裡面放東西」與「改放全新的東西」是兩件完全不同的事情。後者會指向一個新的記憶體，可參考下圖理解：</p>
<p><img src="https://i.imgur.com/JkzALWA.png"></p>
<p>若以陣列為例，會得到相同的結果，以下列程式碼為例：</p>
<pre><code class="javascript=">var arr = []
var arr2 = arr

console.log(arr, arr2)
// 印出 [] []
arr2 = [&#39;arr2&#39;]          // 賦值，指向新的記憶體位置
console.log(arr, arr2)
// 印出 [] [&#39;arr2&#39;]</code></pre>
<p>賦值後的 arr2 會指向新的記憶體位置，因此兩者的值會不相同，可想像成 <code>arr: 0x10</code> 和 <code>arr: 0x20</code>。 </p>
<h3 id="與-的差別"><a href="#與-的差別" class="headerlink" title="== 與 === 的差別"></a><code>==</code> 與 <code>===</code> 的差別</h3><ul>
<li><code>=</code>：代表賦值</li>
<li><code>==</code> 和 <code>===</code>：均用來判斷是否相等，差別在於是否判斷值的型態。原因是 <code>==</code> 判斷過程會進行型態轉換</li>
</ul>
<blockquote>
<p>結論：盡量使用三個等號進行判斷，如此最能夠避免因型態不同而發生錯誤。</p>
</blockquote>
<p>以下列程式碼為例：</p>
<pre><code class="javascript=">console.log(0 == &#39;0&#39;)
// true
console.log(0 === &#39;0&#39;)
// false，因為數字和字串型態不同</code></pre>
<p>再以陣列作為範例：</p>
<pre><code class="javascript=">var arr = [2]
var arr2 = [2]
console.log(arr === arr2)
// false</code></pre>
<p>之所以兩者不會相等，和前面提到的「記憶體位置不同」有關，可想像成：</p>
<pre><code>0x01: [2]
0x02: [2]

arr: 0x01
arr2: 0x02</code></pre>
<p>也因此，不管裡面放相同參數或均為空陣列，兩者都不會相等，一定要加上 <code>arr2 = arr</code> 才會使等號成立。</p>
<p>同理，當我們比較空陣列或空物件時，結果也不會相等，因為比較的是兩者的記憶體位置：</p>
<pre><code class="javascript=">console.log([] === [])
// false
console.log(&#123;&#125; === &#123;&#125;)
// false</code></pre>
<h3 id="特例：NaN"><a href="#特例：NaN" class="headerlink" title="特例：NaN"></a>特例：NaN</h3><ul>
<li>NaN：Not a Number（無效的數字），型態為 Number</li>
</ul>
<p>在什麼樣的情況下會產生 NaN 呢？以「將字串轉換成 Number」為例，因無法轉換所以會得到 NaN：</p>
<pre><code class="javascript=">var a = Number(&#39;hello&#39;)
console.log(a)
// NaN
console.log(typeof a)
// number</code></pre>
<p>這時如果再以等號進行判斷，結果會是：</p>
<pre><code class="javascript=">var a = Number(&#39;hello&#39;)
console.log(a === a)
// false</code></pre>
<blockquote>
<p>什麼～～～～～？！同一個變數結果竟然會不相等？！（震驚ing）</p>
</blockquote>
<p>為何會發生自己不等於自己的情況呢？這是因為 <code>NaN === NaN</code> 判斷結果不相等造成，屬於特殊案例。</p>
<p>至於要如何檢視變數是否為 NaN，可使用函式 <code>isNaN()</code>：</p>
<pre><code class="javascript=">var a = Number(&#39;hello&#39;)
console.log(isNaN(a))
// true</code></pre>
<ul>
<li>參考資料：<span class="exturl" data-url="aHR0cHM6Ly9kb3JleS5naXRodWIuaW8vSmF2YVNjcmlwdC1FcXVhbGl0eS1UYWJsZS8=">JS Comparison Table<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="let-與-const"><a href="#let-與-const" class="headerlink" title="let 與 const"></a>let 與 const</h3><p>接著談到宣告變數的方式，除了習慣使用的 var（variable 變數），在 ES6  還引入了 let 和 const（constant 常數） 兩種宣告方式。這三者之間最大差別，主要，在於作用域不同，在之後的 Scope 章節會再詳細說明。</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ul>
<li>宣告時就要給初始值</li>
<li>宣告後就不能再改變</li>
</ul>
<p>但我們可以去改變物件 obj 裡面的值，如以下範例：</p>
<pre><code class="javascript=">const obj = &#123;
  number: 1
&#125;

obj.number = 2</code></pre>
<p>如果直接賦予 obj 新的值，就會出現錯誤：</p>
<pre><code class="javascript=">const obj = &#123;
  number: 1
&#125;

obj = &#123;number: 2&#125;
// TypeError: Assignment to constant variable.</code></pre>
<p>這和前面提到的記憶體位置觀念相同，const 說的不能改變，其實是不能改變「該記憶體位置」。obj 是存記憶體位置，number 則是存 value。也因此賦值給 obj 就代表改變記憶體位置。</p>
<pre><code class="javascript=">0x10: &#123;
number: 1
&#125;
0x20: &#123;
number: 2
&#125;

obj: 0x20
// 常數 obj 的記憶體位置被改變，所以出現錯誤</code></pre>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmh1bGkudHcvMjAxOC8wNi8yMy9qYXZhc2NyaXB0LWNhbGwtYnktdmFsdWUtb3ItcmVmZXJlbmNlLw==">深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【中場心得】半年過去了，我仍在學習程式的路上（上篇）</title>
    <url>/lidemy-learing-1/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/YLhLtnT.png"><br>（Photo by <span class="exturl" data-url="aHR0cHM6Ly91bnNwbGFzaC5jb20vQGZveHhtZA==">Matt Duncan<i class="fa fa-external-link-alt"></i></span> on <span class="exturl" data-url="aHR0cHM6Ly91bnNwbGFzaC5jb20v">Unsplash<i class="fa fa-external-link-alt"></i></span>）</p>
<a id="more"></a>

<blockquote>
<p>“Never regret. If it’s good, it’s wonderful. If it’s bad, it’s experience. “ — Victoria Holt.</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdGxpdS5tZWRpdW0uY29tLyVFNCVCOCVBRCVFNSVBMCVCNCVFNSVCRiU4MyVFNSVCRSU5Ny0lRTUlOEQlOEElRTUlQjklQjQlRTklODElOEUlRTUlOEUlQkIlRTQlQkElODYtJUU2JTg4JTkxJUU0JUJCJThEJUU1JTlDJUE4JUU1JUFEJUI4JUU3JUJGJTkyJUU3JUE4JThCJUU1JUJDJThGJUU3JTlBJTg0JUU4JUI3JUFGJUU0JUI4JThBLSVFNCVCOCU4QSVFNyVBRiU4Ny02ZWMzMzlkOTAzMjY=">Medium 連結<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>從六月初開始，參加第四期程式導師計畫以來，這段日子過得飛快，轉眼間一個禮拜又過去，自己也迎來了課程中場。其實這篇心得早該在計畫第一百天、或是滿三個月那時候生出來，雖然每天都還是有持續寫進度報告，但覺得是時候來總結學習至今的想法。</p>
<p>然而卻遲遲未動筆，卡在構思階段不知該從而說起，想著想著一天天就這麼過去，所謂的心得文當然也一直停留在腦中。即便如此，仍時常思考自己究竟想記錄些什麼，省思自己是否有所成長，觀察到學習態度上的轉變，或是想要留些什麼給未來的自己。</p>
<p>直到完成第十四週的網站部署，準備邁入十五週的第三個複習週和十六週的前端中階課程。驚覺到，原來我已經走完成課程的一半了啊！相較於最初連 JavaScript 和 Java 都傻傻分不清楚的自己，現在已經能熟捻操作 CLI 介面，瞭解該如何串接 API 和呼叫 function，或是探究工具或指令背後的意義，想想也真是不可思議。</p>
<p>畢竟在未來某天，一定還是會需要回顧這段路程，倒不如趁記憶還清晰的時候記錄下來，於是這篇中場心得就誕生了。</p>
<p>文章大綱如下，會分為上下兩篇，而本篇為前半部分：</p>
<ul>
<li>萬事必有起因</li>
<li>關於那些沒能選擇的過去</li>
<li>如夢似幻的那一年</li>
<li>值得不值得</li>
<li>失而復得的熱情</li>
<li>恐懼的背後什麼都沒有</li>
<li>找到適合自己的方式</li>
<li>慢慢變成理想中的樣子</li>
</ul>
<p>前半段會比較偏向過去的學習經歷，因為每個人都是獨立的個體，可能會不太具有參考價值，只是想要好好回顧一路走來，自己對於學習上心態的轉變。</p>
<p>後半段才會慢慢切入主題，也就是開始程式導師計畫以後的種種心得，覺得要討論的方向不太相同，因此分上下兩篇記錄。</p>
<p>那麼，以下就是一些關於過去學習的思路歷程。</p>
<hr>
<h2 id="萬事必有起因"><a href="#萬事必有起因" class="headerlink" title="萬事必有起因"></a>萬事必有起因</h2><blockquote>
<p>「為什麼會想學寫程式？」</p>
</blockquote>
<p>這想必會成為日後求職面試的必考題吧？</p>
<p>對我來說，「學程式」這件事或許不能完全說是一時興起，而是當初經歷的種種事情，似乎最後都導向「我要成為工程師」這個答案。</p>
<p>但其實有更重要的原因，來自於求學過程中遭遇的種種挫敗，讓自己害怕學新知識這件事，也讓我成為一個很沒有自信的一個人。這樣的我，還有從頭來過的機會嗎？</p>
<p>曾經連續兩次指考物理成績都不及格，也曾被當過微積分，這樣的我真的有辦法寫程式嗎？已經在大學時期失敗過的我，真的還有辦法轉換跑道嗎？老實說，這些問題直到現在都沒有答案。</p>
<p>唯一能夠確信的，就是如果不嘗試「開始」，永遠都不會知曉自己適合不適合。</p>
<h2 id="關於那些沒能選擇的過去"><a href="#關於那些沒能選擇的過去" class="headerlink" title="關於那些沒能選擇的過去"></a>關於那些沒能選擇的過去</h2><p>想回頭談談自己的成長過程，其實也不是多光彩的故事，因為求學過程曾帶給我深深的傷口。即便有令人稱羨的國立大學學歷，因學歷獲得種種機會的同時，卻也不斷被加上無形的壓力，被貼上的標籤彷彿一把雙面刃在折磨著我，直到現在都是。</p>
<p>但那些選擇其實都是自己造成的，自己也必須去承擔選擇的後果，即使事後後悔再多，聽起來都像是滿滿的藉口吧。</p>
<p>在求學過程，總是有意無意或天意，讓我避開最想要的選項，我很害怕自己沒辦法達到最好的結果，害怕自己要是做出選擇了，卻沒有拿出相對應的成績時，那我該怎麼辦才好？</p>
<p>小學時的自己，可以很自豪地說出自己沒有補習，在段考前還可以賴在電腦前組對打鯨魚王，無憂無慮。國中後開始踏入補習班，還記得自己曾經翹掉補習直接逃回家過，即使只有短短幾天，仍忘不了那段重拾自由的快樂。雖然後來還是被導師給帶回去了，回到所謂的「正軌」，或許這也是日後種種事情的跡象吧。</p>
<p>國中升高中那年的基測，我永遠記得 399 這個數字，考了兩次都是一樣的分數，又因為作文成績被刷掉，踏入了第二志願。直到升上高中大學，所謂的「優等生」光環褪去後，便深深對自己的平凡感到無能為力。</p>
<p>高中時雖然加入了吉他社，到高二因為害怕組團而成為幽靈社員。之後卻也沒有比較用功讀書，大考後驚覺自己竟荒廢了學業，甚至還成為了重考生，只為了能夠進入夢想中的那所大學。</p>
<p>明明比較喜歡動物和日文，卻因為分數有到就選校不選系，填了農業相關科系。大二選組別時，因為對自己的設計能力沒有足夠信心，放棄當初更想選的景觀設計組。直在大三實習寫專題後，才發現自己根本就不想走這行。</p>
<p>我的人生好像充滿了藉口，明明不夠努力，卻又不服輸，徒有那無謂的自尊心。好像一旦考試考輸了，就只能全盤否定自己。</p>
<p>好想要逃離這一切，想到一個新的地方重新開始。這時候我，想起了大三開始選修的日文課，或許那是我第一次自己選擇想要學習的東西，畢業前也靠著繼續自學考到了 N2 程度。</p>
<p>「這一次，我要為自己的人生做主！」那時的我是如此天真的認為，只要能逃離現在身處的環境，自己對未來一定會有更不一樣的答案。</p>
<p>然而殘酷的現實是，如果你不知道自己為什麼要出走，該往哪個方向找尋答案，那些問題最後還是會原封不動的回到你身邊</p>
<h2 id="如夢似幻的那一年"><a href="#如夢似幻的那一年" class="headerlink" title="如夢似幻的那一年"></a>如夢似幻的那一年</h2><p>於是畢業後，我選擇前往日本打工度假一年。其實早在大二暑假那年，我就曾經獨自一年到日本愛知縣打工換宿，回想起當時的自己還根本不會說幾個日文單字，連網路卡都沒辦，就懵懵懂懂來到了鄉下小鎮。</p>
<p>當時的自己，喜歡像這樣在異地生活的感覺，終於來到朝思暮想的國度，即使在日生活並不完全美好，還是會有不好的一面，對自己來說卻甘之如飴，每段回憶都值得收藏在心底。能夠一切從零開始，沒有負擔，只需專心投入在當下的事物，似乎也就足夠。又或許，只是單純想稍微逃離原本讓自己喘不過氣的環境吧？</p>
<p>直到畢業後，我帶著大學打工一點一點存下的資金，再度來到了日本。</p>
<p>前半年仍沉浸在一切歸零的新鮮感，卻不知曾幾何時，當初那份熱情也悄悄淡去。說來有點難為情，之所以在畢業前就下定決心要前往日本，一部份是想重新開始，另一個原因，其實是因為在重考那一年，入了某偶像團體的坑，想著一定要完成參加演唱會的願望。然而這個願望卻沒有實現，在我終於赴日以前，喜歡的成員就畢業了。</p>
<p>也才明白「推しは推せるときに推せ（能支持喜歡的人的時候全力支持）」這句話的涵義，古人總說要及時行樂不是沒有道理。對於任何事情都是如此，想到的話就去做，寧可做出選擇再來後悔，也不要後悔當初自己沒有去做，藉由這段經驗讓我深切體會到。</p>
<p>總之，喪失動力來源的自己，雖然還是很喜歡日本，卻也似乎快要忘記自己為何這麼想來日本。也是在這時候，我才意識到「將活著的動力建立在他人身上」其實是件很危險的事情。信仰可以催化自己的人生，卻不能成為生命的氧氣，還是要靠自己找到能夠往前邁進的動力。</p>
<p>在這一年，還發生另一件大事，其實是在赴日半年左右，家裡大長輩住院了，並且情況不太樂觀。得知訊息後的自己，馬上訂了兩三禮拜之後的班機飛回臺灣。</p>
<p>對、至今我仍記得非常清楚，為什麼自己不是趕在一星期內回來呢？就為了省那該死的幾千塊票錢——我沒有見到外婆最後一面，而是在下飛機一得知消息後就直奔殯儀館……。</p>
<p>這件事情帶給了我很沉、很重的打擊。待在台灣的那一個禮拜，幾乎每個晚上我都是哭著入睡，想起記憶中外婆的身影、想到逐漸年邁的家人，思考自己究竟為了什麼要待在日本、思考充滿迷惘的未來。</p>
<hr>
<h2 id="值得不值得"><a href="#值得不值得" class="headerlink" title="值得不值得"></a>值得不值得</h2><p>結束打工度假後，我回到了臺灣。</p>
<p>先是在學校做了幾個月的行政助理，一邊思考自己是否要報考公職。過著朝九晚五的規律生活的同時，我想起長輩總會把「考公職」這件事掛在嘴邊，以前或許是叛逆吧？一聽到這三個字就感到頭痛，為什麼要擅自決定我的將來？</p>
<p>但長輩說的話其實也有他的道理在。老實說，這樣的日子確實很平穩，收入也穩定，一定有更適合這份工作的人在。並不是說這份工作不好，只是，覺得自己似乎還是不適合做行政庶務，難道人生就只能這樣了嗎？想要找到自己能夠投注一輩子心血的事物，就像當初在大學時期，看到周遭熱衷於討論學術觀念的同學們，那對充滿求知慾的眼神一樣。</p>
<p>當初的自己，思考了許多未來可能的道路。例如航空業、餐飲服務業、準備調查員考試、繼續求學，那年甚至因為喜歡上看舞台劇，做著去專門學校的美夢，或著是想為了實現留學夢準備申請別科。</p>
<p>但因為求學時期的種種挫折，當時只覺得自己或許不應該先繼續學習，而是直接踏入職場。總之先去日本賺錢吧？之後如果想繼續求學，也能夠有足夠的資金支付學費，不會造成家裡的負擔。因為這個想法，開始尋找能夠赴日工作的機會。</p>
<p>後來經過面試，因緣際會，我進入一家做電子書相關的日商擔任專案助理，也就是負責當日文窗口，負責翻譯文件等等，一方面累積工作經驗，一方面等待著時機。其實就在段期間，公司老闆曾問過我想不想學習程式，「很想！」這個答案不假思索便脫口而出，但其實我內心是害怕的，一次次的失敗經驗讓我卻步。</p>
<p>後來這件事也就不了了之，或許是因為，先前自己曾表明想趕快到日本工作吧？現在回想起來，要是當初能夠耐住性子，好好重新打磨自己，未來是否會更不一樣呢？然而沒有如果，錯過了就是錯過了，我們能做的就只是把握當下而已。</p>
<p>再經過幾個月，在一次日本徵才會上，我找到一份能夠赴日的工作，是餐飲服務業相關，簡言之就是到日本當儲備幹部，後來經過重重面試後也幸運被選上。然而，等待簽證的時間其實十分漫長，這段期間，我仍舊非常迷惘，即使這是當初自己的選擇，卻總覺得還是有那麼點不甘心，我是否應該還能有更好的選擇？</p>
<p>腦中總會不時想起，當初在日商工作時，老闆在我離職那天對我說的話：「你要好好想清楚，該如何提升自己的價值，你值得更好的選擇。」然而，當時的我並沒有把這句話放在心上。</p>
<p>等到簽證終於下來，很快的經過一番準備作業，敲定好赴日時程的時候——那時正好是今年三月，也就是疫情整個炸開的時候。當時的自己其實沒有太多時間猶豫，到底去或不去？這份工作值得冒這麼大的風險嗎？或許詢問一百個親友會有九十九個說不吧？的確，得到的回答不外乎是：「自己的健康更重要，工作機會再找就有。」、「當作累積經驗很好，但現在不是出國的好時機。」其實這些道理自己心底也都明白，只是當下沒辦法立即做出選擇。</p>
<p>不管如何，在出發的前一天，我辭退了這份工作。後悔嗎？好像也還好，反而一直懸在內心的那塊大石終於能夠放下。值得嗎？至少現在的我，很慶幸自己後來選擇了現在這條路，儘管我還沒有實際踏入這個領域，仍在為了獲得那張入場票而努力著。</p>
<p>也就是從今年三月底左右，我開始嘗試自學寫程式這件事。</p>
<p>最後稍微總結這篇，想談的其實就是下列幾點：</p>
<ul>
<li>如果不嘗試開始，永遠都不會知曉自己適不適合</li>
<li>面對問題，有時候「逃離」也是一種方法，但你仍要不斷思考下次再遇到時該如何面對它</li>
<li>將自己活著的價值建立在他人身上，其實是很危險的事情。</li>
<li>想到什麼就去做，寧可做出選擇再來後悔，也不要後悔當初自己沒有去做</li>
<li>人生沒有如果，能做的事就是把握當下</li>
</ul>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>其實上篇寫得差不多以後，一直很猶豫要不要發出來，總覺得這些經歷對他人而言，應該是不太重要的事情，也一度想把整篇砍掉，乾脆直接敘述有關目前學習程式的感想就好，不需要把過去的經歷挖出來。但這段過程對自己來說似乎是必要的過程，把過去的種種黑暗面給攤出來，也是不想再讓自己陷入過去的迴圈。</p>
<p>比起這些過去，更重要的是現在。但正因為經歷了這些過去，才會有今天的自己，這是誰也無法改變的事實。也因為有這些不光彩的過去，才能讓我終於醒悟，原來從以前到現在，自己都是有選擇的，而自己也必須去承擔那些選擇的後果。</p>
<p>其實我覺得很幸運，生長在一個能夠讓我自由探索未來的家庭。儘管我的人生不斷在繞遠路，仍舊對生命徬徨，卻還是能感受到家人的支持，對此總有說不完的感激。想要回報他們，也更加堅定自己想在這條路走下去的想法。</p>
<p>現在想想，過去經歷的這些其實好像也沒什麼了，至少現在的我找到了想繼續努力的目標，而我也正朝那個方向前進著。</p>
]]></content>
      <categories>
        <category>Lidemy</category>
      </categories>
      <tags>
        <tag>Lidemy</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 13] MTR04 - 實作留言版 plugin</title>
    <url>/mtr04-plugin/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvbXRyMDQ=">[MTR04] 第十三週 - 帶著做留言版 plugin<i class="fa fa-external-link-alt"></i></span> 的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<h2 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h2><p>需安裝好 webpack 以及其他套件，可跟著官方教學步驟 <span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9ndWlkZXMvZ2V0dGluZy1zdGFydGVkLw==">Getting Started<i class="fa fa-external-link-alt"></i></span> 進行安裝：</p>
<pre><code>mkdir webpack-demo
cd webpack-demo
npm init -y
npm install webpack webpack-cli --save-dev</code></pre>
<a id="more"></a>
<h4 id="安裝使用-jquery"><a href="#安裝使用-jquery" class="headerlink" title="安裝使用 jquery"></a>安裝使用 jquery</h4><pre><code>npm install jquery webpack-cli --save-dev</code></pre>
<h4 id="安裝-babel-loader"><a href="#安裝-babel-loader" class="headerlink" title="安裝 babel-loader"></a>安裝 babel-loader</h4><pre><code>npm install -D babel-loader @babel/core @babel/preset-env</code></pre>
<h2 id="目標：建立留言版-plugin"><a href="#目標：建立留言版-plugin" class="headerlink" title="目標：建立留言版 plugin"></a>目標：建立留言版 plugin</h2><p>也就是修改 week12 實作的留言版，將 index.html 中的內容全部以 JavaScript 形式匯入。</p>
<h3 id="步驟一：init-初始化"><a href="#步驟一：init-初始化" class="headerlink" title="步驟一：init() 初始化"></a>步驟一：init() 初始化</h3><pre><code class="javascript=">commentPlugin.init(&#123;
  apiURL: &#39;&#39;,
  siteKey: &#39;&#39;,
  containerSelector: &#39;#comments&#39;
&#125;)</code></pre>
<h3 id="步驟二：動態新增頁面"><a href="#步驟二：動態新增頁面" class="headerlink" title="步驟二：動態新增頁面"></a>步驟二：動態新增頁面</h3><p>將 UI 介面以及 CSS 樣式，同樣使用 JavaScript 來動態新增：</p>
<pre><code class="javascript=">let siteKey = &#39;&#39;;
let apiUrl = &#39;&#39;;
let containerElement = null;
let commentDOM = null;
let lastId = null;    // before
let isEnd = false;    // 確認是否拿完資料

const css = &#39;.add-comment-form &#123; margin-bottom: 10px; &#125; .card &#123; margin-bottom: 10px; &#125; .card-title &#123;  word-wrap:break-word; &#125; .load-more &#123; margin-bottom: 10px; &#125;&#39;
const loadMoreButtonHTML = &#39;&lt;button class=&quot;load-more btn btn-dark&quot;&gt;載入更多&lt;/button&gt;&#39;;

// UI 介面的模板
const formTemplate = `
  &lt;div&gt;
    &lt;form class=&quot;add-comment-form&quot;&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;form-nickname&quot;&gt;暱稱&lt;/label&gt;
        &lt;input name=&quot;nickname&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;form-nickname&quot; &gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;content-textarea&quot;&gt;留言內容&lt;/label&gt;
        &lt;textarea name=&quot;content&quot; class=&quot;form-control&quot; id=&quot;exampleFormControlTextarea1&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt;
      &lt;/div&gt;
      &lt;button type=&quot;submit&quot; class=&quot;btn btn-dark&quot;&gt;送出&lt;/button&gt;
    &lt;/form&gt;
    &lt;div class=&quot;comments&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
`

// 初始化: 動態匯入表單
function init(options) &#123;
  siteKey = options.siteKey;
  apiUrl = options.apiUrl;
  containerElement = $(options.containerSelector);
  containerElement.append(formTemplate);
  // 動態新增 css 樣式
  const styleElement = document.createElement(&#39;style&#39;);
  styleElement.type = &#39;text/css&#39;;
  styleElement.appendChild(document.createTextNode(css));
  document.head.appendChild(styleElement)

  commentDOM = $(&#39;.comments&#39;);
  getComments();

  // 載入更多: 以事件代理的方式處理 click 事件 
  $(&#39;.comments&#39;).on(&#39;click&#39;, &#39;.load-more&#39;, () =&gt; &#123;
    getComments();
  &#125;);

  // 新增留言 -&gt;  將資料存到後端
  $(&#39;.add-comment-form&#39;).submit(e =&gt; &#123;
    e.preventDefault();             // 取消原生行為 -&gt; 不會送出表單
    const newCommentData = &#123;
      &#39;site_key&#39;: siteKey,         // 全域變數的 siteKey
      &#39;nickname&#39;: $(&#39;input[name=nickname]&#39;).val(),
      &#39;content&#39;: $(&#39;textarea[name=content]&#39;).val()
    &#125;
    $.ajax(&#123;
      type: &#39;POST&#39;,
      url: `$&#123;apiUrl&#125;/api_add_comments.php`,
      data: newCommentData
    &#125;).done(function (data) &#123;        // done(): 以函數處理回傳的 data 資料
      if (!data.ok) &#123;
        alert(data.message);
        return;
      &#125;
      $(&#39;input[name=nickname]&#39;).val(&#39;&#39;);
      $(&#39;textarea[name=content]&#39;).val(&#39;&#39;);
      // 新增留言後以 JS 動態方式加到最上方
      appendCommentToDOM(commentDOM, newCommentData, true);
    &#125;);
  &#125;);
&#125;

// 在 DOM 結構準備好後，再進行初始化
$(document).ready(() =&gt; &#123;
  init(&#123;
    siteKey: &#39;heidi&#39;,
    apiUrl: &#39;http://localhost/heidi/week13_local/hw2&#39;,
    containerSelector: &#39;.comment-area&#39;
  &#125;);
&#125;);</code></pre>
<p>如此即可將 <code>&lt;script&gt;</code> 區塊的程式碼全部放到 src\index.js，再利用 webpack 進行下列步驟。</p>
<h3 id="步驟三：進行模組化"><a href="#步驟三：進行模組化" class="headerlink" title="步驟三：進行模組化"></a>步驟三：進行模組化</h3><p>將不同功能模組化來重構程式碼，以便後續管理。</p>
<ol>
<li>在 src 資料夾建立 api.js</li>
</ol>
<pre><code class="javascript=">import $ from &#39;jquery&#39;;

export function getComments(apiUrl, siteKey, before, cb) &#123;
  let showURL = `$&#123;apiUrl&#125;/api_comments.php?site_key=$&#123;siteKey&#125;`;
  if (before) &#123;
    showURL += &#39;&amp;before=&#39; + before;
  &#125;
  $.ajax(&#123;
    url: showURL
  &#125;).done(function (data) &#123;
    cb(data);
  &#125;);
&#125;

export function addComments(apiUrl, siteKey, before, cb) &#123;
  $.ajax(&#123;
    type: &#39;POST&#39;,
    url: `$&#123;apiUrl&#125;/api_add_comments.php`,
    data
  &#125;).done(function (data) &#123;
    cb(data)
  &#125;);
&#125;</code></pre>
<ol start="2">
<li>建立 template.js</li>
</ol>
<pre><code class="javascript=">export const cssTemplate = &#39;.add-comment-form &#123;margin - bottom: 10px; &#125; .card &#123;margin - bottom: 10px; &#125; .card-title &#123;word - wrap:break-word; &#125; .load-more &#123;margin - bottom: 10px; &#125;&#39;
export const loadMoreButtonHTML = &#39;&lt;button class=&quot;load-more btn btn-dark&quot;&gt;載入更多&lt;/button&gt;&#39;;

// UI 介面的模板
export const formTemplate = `
  &lt;div&gt;
    &lt;form class=&quot;add-comment-form&quot;&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;form-nickname&quot;&gt;暱稱&lt;/label&gt;
        &lt;input name=&quot;nickname&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;form-nickname&quot; &gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;content-textarea&quot;&gt;留言內容&lt;/label&gt;
        &lt;textarea name=&quot;content&quot; class=&quot;form-control&quot; id=&quot;exampleFormControlTextarea1&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt;
      &lt;/div&gt;
      &lt;button type=&quot;submit&quot; class=&quot;btn btn-dark&quot;&gt;送出&lt;/button&gt;
    &lt;/form&gt;
    &lt;div class=&quot;comments&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
`</code></pre>
<ol start="3">
<li>建立 utils.js</li>
</ol>
<pre><code class="javascript=">export function escape(toOutput) &#123;
  return toOutput
    .replace(/&amp;/g, &#39;&amp;amp;&#39;)
    .replace(/&lt;/g, &#39;&amp;lt;&#39;)
    .replace(/&gt;/g, &#39;&amp;gt;&#39;)
    .replace(/&quot;/g, &#39;&amp;quot;&#39;)
    .replace(/&#39;/g, &#39;&amp;#039;&#39;);
&#125;

// 渲染 comment: 處理讀取的資料 &amp; 決定加在最前面或最後面
export function appendCommentToDOM(container, comment, isPrepend) &#123;
  const html = `
    &lt;div class=&quot;card&quot;&gt;
    &lt;div class=&quot;card-body&quot;&gt;
      &lt;h5 class=&quot;card-title&quot;&gt;$&#123;escape(comment.nickname)&#125;&lt;/h5&gt;
      &lt;p class=&quot;card-text&quot;&gt;$&#123;escape(comment.content)&#125;
      &lt;/p&gt;
    &lt;/div&gt;
    &lt;/div&gt;
  `;
  if (isPrepend) &#123;
    container.prepend(html);  // 新增到最上方
  &#125; else &#123;
    container.append(html);   // 新增到最底部
  &#125;
&#125;</code></pre>
<ol start="4">
<li>並在 index.js 引入上述檔案：</li>
</ol>
<pre><code class="javascript=">import &#123; getComments, addComments &#125; from &#39;./api&#39;;
import &#123; appendCommentToDOM &#125; from &#39;./utils&#39;;
import &#123; cssTemplate, loadMoreButtonHTML, formTemplate &#125; from &#39;./template&#39;;
import $ from &#39;jquery&#39;;

let siteKey = &#39;&#39;;
let apiUrl = &#39;&#39;;
let containerElement = null;
let commentDOM = null;
let lastId = null;    // before
let isEnd = false;    // 確認是否拿完資料

// 在 DOM 結構準備好後，再進行初始化
$(document).ready(() =&gt; &#123;
  init(&#123;
    siteKey: &#39;heidi&#39;,
    apiUrl: &#39;http://localhost/heidi/week13_local/hw2&#39;,
    containerSelector: &#39;.comment-area&#39;
  &#125;);
&#125;);

// 初始化: 動態匯入表單
function init(options) &#123;
  siteKey = options.siteKey;
  apiUrl = options.apiUrl;
  containerElement = $(options.containerSelector);
  containerElement.append(formTemplate);
  // 動態新增 css 樣式
  const styleElement = document.createElement(&#39;style&#39;);
  styleElement.type = &#39;text/css&#39;;
  styleElement.appendChild(document.createTextNode(cssTemplate));
  document.head.appendChild(styleElement)

  commentDOM = $(&#39;.comments&#39;);
  getNewComments();

  // 載入更多: 以事件代理的方式處理 click 事件
  $(&#39;.comments&#39;).on(&#39;click&#39;, &#39;.load-more&#39;, () =&gt; &#123;
  getNewComments();
  &#125;);

  // 新增留言 -&gt;  將資料存到後端
  $(&#39;.add-comment-form&#39;).submit(e =&gt; &#123;
  e.preventDefault();             // 取消原生行為 -&gt; 不會送出表單
    const newCommentData = &#123;
     &#39;site_key&#39;: siteKey,         // 全域變數的 siteKey
      &#39;nickname&#39;: $(&#39;input[name=nickname]&#39;).val(),
      &#39;content&#39;: $(&#39;textarea[name=content]&#39;).val()
    &#125;
    addComments(apiUrl, siteKey, newCommentData, data =&gt; &#123;
      if (!data.ok) &#123;
        alert(data.message);
        return;
      &#125;
      $(&#39;input[name=nickname]&#39;).val(&#39;&#39;);
      $(&#39;textarea[name=content]&#39;).val(&#39;&#39;);
      appendCommentToDOM(commentDOM, newCommentData, true);
    &#125;);
  &#125;);
&#125;

function getNewComments() &#123;
const commentDOM = $(&#39;.comments&#39;);
$(&#39;.load-more&#39;).hide();       
  if (isEnd) &#123;
    return; 
  &#125;
  getComments(apiUrl, siteKey, lastId, data =&gt; &#123;
    if (!data.ok) &#123;
      alert(data.message);
      return;
    &#125;
    // 若 request 成功讀取資料
    const comments = data.discussions;
    for (let comment of comments) &#123;
      appendCommentToDOM(commentDOM, comment);
    &#125;

    let length = comments.length;
    // 沒有 lastId: 若初始頁面留言 &lt; 5 直接返回
    if (length &lt; 5) &#123;
      return;
    &#125;
    // 有 lastId: 若拿完資料就隱藏按鈕
    if (length === 0) &#123;
      isEnd = true;
      $(&#39;.load-more&#39;).hide();
    &#125; else &#123;
      lastId = comments[length - 1].id;
      $(&#39;.comments&#39;).append(loadMoreButtonHTML);   // 新增 &quot;載入更多&quot; 按鈕
    &#125;
  &#125;);
&#125;</code></pre>
<h3 id="步驟四：使用-webpack-打包"><a href="#步驟四：使用-webpack-打包" class="headerlink" title="步驟四：使用 webpack 打包"></a>步驟四：使用 webpack 打包</h3><p>將上述檔案進行打包，會在 dist 資料夾建立 main.js，接著回到 index.html 引入該檔案：</p>
<pre><code class="javascript=">&lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt;</code></pre>
<h3 id="步驟五：引入-library"><a href="#步驟五：引入-library" class="headerlink" title="步驟五：引入 library"></a>步驟五：引入 library</h3><blockquote>
<p>可參考官方文件：<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9ndWlkZXMvYXV0aG9yLWxpYnJhcmllcy8=">https://webpack.js.org/guides/author-libraries/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ol>
<li>將 index.js 的 <code>init()</code> 改為 export：</li>
</ol>
<pre><code class="javascript=">export function init(options) &#123;
  ...
&#125;</code></pre>
<ol start="2">
<li>改在 index.html 引入 library：</li>
</ol>
<pre><code class="javascript=">&lt;script&gt;
  $(document).ready(() =&gt; &#123;
    commentPlugin.init(&#123;
      siteKey: &#39;heidi&#39;,
      apiUrl: &#39;http://localhost/heidi/week13_local/hw2&#39;,
      containerSelector: &#39;.comment-area&#39;
    &#125;);
  &#125;);
&lt;/script&gt;</code></pre>
<ol start="2">
<li>並在設定檔 webpack.config.js 的 output 加上<code>library: &#39;commentPlugin&#39;,</code></li>
</ol>
<h3 id="步驟六：執行-webpack-打包"><a href="#步驟六：執行-webpack-打包" class="headerlink" title="步驟六：執行 webpack 打包"></a>步驟六：執行 webpack 打包</h3><p>利用 webpack 將檔案打包成一個 module，即可在 index.html 引入 library。在瀏覽器上開啟頁面，會發現多出全域變數 commentPlugin：</p>
<p><img src="https://i.imgur.com/3Vf60Fy.png"></p>
<hr>
<h2 id="優化程式碼"><a href="#優化程式碼" class="headerlink" title="優化程式碼"></a>優化程式碼</h2><p>接著要優化先前寫的程式碼，例如修改 plugin 的 class 名稱，避免不同使用者（siteKey）發生衝突。</p>
<ul>
<li>修改 template.js 中的 classname </li>
</ul>
<pre><code class="javascript=">// 加上不同的 classname，避免不同使用者共用 plugin 發生衝突
export function getLoadMoreButton(classname) &#123;
  return `&lt;button class=&quot;$&#123;classname&#125; load-more btn btn-dark&quot;&gt;載入更多&lt;/button&gt;`;
&#125;

// UI 介面的模板
export function getForm(formClassName, commentsClassName) &#123;
  return `
  &lt;div&gt;
    &lt;form class=$&#123;formClassName&#125;&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label&gt;暱稱&lt;/label&gt;
        &lt;input name=&quot;nickname&quot; type=&quot;text&quot; class=&quot;form-control&quot;&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label&gt;留言內容&lt;/label&gt;
        &lt;textarea name=&quot;content&quot; class=&quot;form-control&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt;
      &lt;/div&gt;
      &lt;button type=&quot;submit&quot; class=&quot;btn btn-dark&quot;&gt;送出&lt;/button&gt;
    &lt;/form&gt;
    &lt;div class=&quot;$&#123;commentsClassName&#125;&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
  `
&#125;</code></pre>
<ul>
<li>index.js 中，同樣使用變數來取代字串</li>
</ul>
<pre><code class="javascript=">import &#123; getComments, addComments &#125; from &#39;./api&#39;;
import &#123; appendCommentToDOM, appendStyle &#125; from &#39;./utils&#39;;
import &#123; cssTemplate, getLoadMoreButton, getForm &#125; from &#39;./template&#39;;
import $ from &#39;jquery&#39;;

// 初始化: 動態匯入表單
export function init(options) &#123;
  let siteKey = &#39;&#39;;
  let apiUrl = &#39;&#39;;
  let containerElement = null;
  let commentDOM = null;
  let lastId = null;    // before
  let isEnd = false;    // 確認是否拿完資料
  let loadMoreClassName;
  let loadMoreSelector;
  let commentsClassName;
  let commentsSelector;
  let formClassName;
  let formSelector;

  siteKey = options.siteKey;
  apiUrl = options.apiUrl;
  loadMoreClassName = `$&#123;siteKey&#125;-load-more`;
  commentsClassName = `$&#123;siteKey&#125;-comments`;
  formClassName = `$&#123;siteKey&#125;-add-comment-form`;
  loadMoreSelector = &#39;.&#39; + loadMoreClassName;
  commentsSelector = &#39;.&#39; + commentsClassName;
  formSelector = &#39;.&#39; + formClassName;

  containerElement = $(options.containerSelector);
  containerElement.append(getForm(formClassName, commentsClassName));
  appendStyle(cssTemplate)

  commentDOM = $(commentsSelector);
  getNewComments();

  // 載入更多: 以事件代理的方式處理 click 事件
  $(commentsSelector).on(&#39;click&#39;, loadMoreSelector, () =&gt; &#123;
    getNewComments();
  &#125;);

  // 新增留言 -&gt;  將資料存到後端
  $(formSelector).submit(e =&gt; &#123;
    e.preventDefault();             // 取消原生行為 -&gt; 不會送出表單
    const nicknameDOM = $(`$&#123;formSelector&#125; input[name=nickname]`);
    const contentDOM = $(`$&#123;formSelector&#125; textarea[name=content]`);
    const newCommentData = &#123;
      site_key: siteKey,         // 全域變數的 siteKey
      nickname: nicknameDOM.val(),
      content: contentDOM.val()
    &#125;
    console.log(formSelector)
    console.log(nicknameDOM, nicknameDOM.val())
    console.log(contentDOM, contentDOM.val())    
    addComments(apiUrl, siteKey, newCommentData, data =&gt; &#123;
      if (!data.ok) &#123;
        alert(data.message);
        return;
      &#125;
      nicknameDOM.val(&#39;&#39;);
      contentDOM.val(&#39;&#39;);
      appendCommentToDOM(commentDOM, newCommentData, true);
    &#125;);
  &#125;);

  function getNewComments() &#123;
    const commentDOM = $(commentsSelector);
    $(loadMoreSelector).hide();
    if (isEnd) &#123;
      return;
    &#125;
    getComments(apiUrl, siteKey, lastId, data =&gt; &#123;
      if (!data.ok) &#123;
        alert(data.message);
        return;
      &#125;
      const comments = data.discussions;
      for (let comment of comments) &#123;
        appendCommentToDOM(commentDOM, comment);
      &#125;

      let length = comments.length;
      if (length &lt; 5) &#123;
        return;
      &#125;
      if (length === 0) &#123;
        isEnd = true;
        $(loadMoreSelector).hide();
      &#125; else &#123;
        lastId = comments[length - 1].id;
        const loadMoreButtonHTML = getLoadMoreButton(loadMoreClassName);
        $(commentsSelector).append(loadMoreButtonHTML);
      &#125;
    &#125;);
  &#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>Back-End</tag>
        <tag>jQuery</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 11] 利用 PHP 實作陽春部落格</title>
    <url>/php-blog/</url>
    <content><![CDATA[<p>可以將部落格想成「只有一人」能新增文章的留言版。</p>
<a id="more"></a>
<h2 id="Step1-規劃產品路由與功能"><a href="#Step1-規劃產品路由與功能" class="headerlink" title="Step1. 規劃產品路由與功能"></a>Step1. 規劃產品路由與功能</h2><h3 id="頁面"><a href="#頁面" class="headerlink" title="頁面"></a>頁面</h3><ul>
<li>部落格首頁 <code>index.php</code></li>
<li>註冊頁面 <code>register.php</code></li>
<li>登入頁面 <code>login.php</code></li>
<li>導覽列 <code>navbar.php</code>：獨立出 navbar，可避免重複撰寫</li>
<li>管理後台頁面 <code>admin.php</code></li>
<li>新增文章頁面 <code>create_post.php</code></li>
<li>新增文章頁面 <code>update_post.php</code></li>
<li>瀏覽全文頁面 <code>post.php</code></li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>常用函式 <code>utils.php</code>：<code>getUserFromUsername()</code>、<code>escape()</code></li>
</ul>
<h4 id="使用者相關"><a href="#使用者相關" class="headerlink" title="使用者相關"></a>使用者相關</h4><ul>
<li>註冊功能 <code>handle_register.php</code></li>
<li>登入功能 <code>handle_login.php</code></li>
<li>登出功能 <code>logout.php</code></li>
<li>驗證權限功能 <code>check_permission.php</code></li>
</ul>
<h4 id="文章相關"><a href="#文章相關" class="headerlink" title="文章相關"></a>文章相關</h4><ul>
<li>新增文章功能 <code>handle_create_post.php</code></li>
<li>編輯文章功能 <code>handle_update_post.php</code></li>
<li>刪除文章功能 <code>handle_delete_post.php</code></li>
</ul>
<h2 id="Step2-規劃資料結構：建置資料庫"><a href="#Step2-規劃資料結構：建置資料庫" class="headerlink" title="Step2. 規劃資料結構：建置資料庫"></a>Step2. 規劃資料結構：建置資料庫</h2><ul>
<li><p>blog_users：使用者相關資料</p>
<ul>
<li>id</li>
<li>role</li>
<li>username</li>
<li>nickname</li>
<li>password</li>
<li>created_at</li>
</ul>
</li>
<li><p>blog_posts：文章相關資料</p>
<ul>
<li>id</li>
<li>username</li>
<li>title</li>
<li>content</li>
<li>is_deleted</li>
<li>created_at </li>
</ul>
</li>
</ul>
<hr>
<h2 id="Step3-實作部落格"><a href="#Step3-實作部落格" class="headerlink" title="Step3. 實作部落格"></a>Step3. 實作部落格</h2><h3 id="PHP-相關語法"><a href="#PHP-相關語法" class="headerlink" title="PHP 相關語法"></a>PHP 相關語法</h3><ul>
<li><p><code>var_dump()</code>：印出變數的相關訊息</p>
</li>
<li><p><code>strpos()</code>: 查找該字串首次出現的位置</p>
<pre><code class="php=">&lt;?php
// 獲得回傳的網址列
$url = $_SERVER[&#39;REQUEST_URI&#39;];
// strpos(): 查找該字串首次出現的位置
$isAdminPage = (strpos($url, &#39;admin.php&#39;) !== false);
$isLoginPage = (strpos($url, &#39;login.php&#39;) !== false);
?&gt;</code></pre>
</li>
<li><p><code>substr()</code>：取得部分字串，可設定字串長度，共有三個參數：</p>
<ul>
<li><code>$strting</code>：原始的字串</li>
<li><code>$start</code>：開始擷取的位置</li>
<li><code>$length</code>：要擷取的字串長度</li>
</ul>
</li>
<li><p><code>mb_substr()</code>：和 <code>substr()</code> 用法相同，但多了第四個參數：</p>
<ul>
<li><code>$encoding</code>：判斷的編碼，通常使用 <code>&quot;UTF-8&quot;</code><pre><code class="php=">substr($string, $start, $length);
mb_substr($string, $start, $length, $encoding);</code></pre>
</li>
</ul>
</li>
<li><p><code>intval()</code>: 將字串轉換為數字</p>
<pre><code class="php=">$id = intval($_GET[&#39;id&#39;]);</code></pre>
</li>
<li><p><code>$_SERVER[&#39;HTTP_REFERER&#39;]</code>：獲取前一頁面的 URL 地址</p>
<pre><code class="php=">&lt;!-- 透過 POST 來獲得前一頁面的 URL --&gt;
&lt;form action=&quot;handle_update_post.php&quot; method=&quot;POST&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;page&quot; value=&quot;&lt;?php echo $_SERVER[&#39;HTTP_REFERER&#39;] ?&gt;&quot;&gt;
&lt;/form&gt;</code></pre>
</li>
</ul>
<h3 id="include、require、include-once、require-once-的差別"><a href="#include、require、include-once、require-once-的差別" class="headerlink" title="include、require、include_once、require_once 的差別"></a><code>include</code>、<code>require</code>、<code>include_once</code>、<code>require_once</code> 的差別</h3><p><code>include</code> 和 <code>require</code> 達成的效果幾乎相同，均為「引入」外部檔案，差別在於「執行原理」以及「報錯程度」。</p>
<h4 id="include"><a href="#include" class="headerlink" title="include"></a><code>include</code></h4><ul>
<li>執行到 <code>include()</code> 時，每次皆會讀取檔案</li>
<li>常用於流程控制，例如：條件判斷、迴圈</li>
<li>適合引入動態的程式碼，會在用到時加載</li>
<li>執行時，若引入的檔案發生錯誤，會顯示警告（Warning），但不會立刻停止程式</li>
</ul>
<h4 id="require"><a href="#require" class="headerlink" title="require"></a><code>require</code></h4><ul>
<li>執行到 <code>require()</code> 時，只會讀取一次檔案</li>
<li>常放在程式開頭，檔案引入後 PHP 會將網頁重新編譯</li>
<li>適合引入靜態的程式碼，會在一開始就加載</li>
<li>執行時，若引入的檔案發生錯誤，會直接報錯（Fatal error）並終止程式</li>
</ul>
<p>後面若加上 <code>_once</code>，代表「只會引入一次」。PHP 會檢測檔案是否有重複引入，避免重複執行浪費效能，因此較推薦使用。</p>
<h4 id="include-once"><a href="#include-once" class="headerlink" title="include_once"></a><code>include_once</code></h4><ul>
<li>和 <code>include</code> 用法基本相同</li>
<li>若發生錯誤，<code>include_once</code> 不會停止程式的執行，只會丟出警告訊息</li>
<li>避免重複引入</li>
<li>以引入 navbar 為例：</li>
</ul>
<pre><code class="htmlmixed=">&lt;!-- 把 header 獨立出來，就不需每個檔案都重複撰寫 --&gt;
&lt;?php include_once(&#39;navbar.php&#39;)?&gt;</code></pre>
<h4 id="require-once"><a href="#require-once" class="headerlink" title="require_once"></a><code>require_once</code></h4><ul>
<li>和 <code>require</code> 用法基本相同</li>
<li>若發生錯誤，<code>require_once</code> 會立刻中止程式</li>
<li>避免重複引入</li>
</ul>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cDovL2NvZGUtYmVnaW5uZXIubG9nZG93bi5jb20vcG9zdHMvMzg5Njg3LXBocHJlcXVpcmUtdnMtaW5jbHVkZQ==">PHP：require V.S. include « 程式初學者<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3N5dW5ndW8uYmxvZ3Nwb3QuY29tLzIwMTMvMDQvcGhwaW5jbHVkZS1yZXF1aXJlLmh0bWw=">[PHP]include 與require 的差別 - Syun<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 9] 利用 PHP 實作留言板 - 初階實作篇</title>
    <url>/php-board/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvYmUxMDEtcGhwLW15c3Fs">[BE101] 用 PHP 與 MySQL 學習後端基礎<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<p>課程筆記：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMC9UaGlzLWlzLUNvZGVkaWFyeS9ibG9iL21hc3Rlci93ZWVrOV8lRTUlQkUlOEMlRTclQUIlQUYlRTUlOUYlQkElRTclQTQlOEVfUEhQJUUzJTgwJTgxTXlTUUwubWQ=">[week 9] 後端基礎 - PHP 語法、資料庫 MySQL<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<hr>
<h2 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h2><p>在開始實作留言板之前，需先進行前置作業：</p>
<ul>
<li>規劃產品路由與功能</li>
<li>規劃資料結構：建立資料庫</li>
</ul>
<h3 id="Step1-規劃產品路由與功能"><a href="#Step1-規劃產品路由與功能" class="headerlink" title="Step1. 規劃產品路由與功能"></a>Step1. 規劃產品路由與功能</h3><p><img src="https://i.imgur.com/HKuwCYA.png"></p>
<h4 id="頁面"><a href="#頁面" class="headerlink" title="頁面"></a>頁面</h4><ul>
<li>留言板首頁 <code>index.php</code></li>
<li>註冊頁面 <code>register.php</code></li>
<li>登入頁面 <code>login.php</code></li>
</ul>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li>新增留言 <code>handle_add_post.php</code> → comments 資料庫</li>
<li>註冊 <code>handle_register.php</code> → users 資料庫</li>
<li>登入 <code>handle_login.php</code></li>
<li>登出 <code>logout.php</code></li>
</ul>
<h3 id="Step2-規劃資料結構：建置資料庫"><a href="#Step2-規劃資料結構：建置資料庫" class="headerlink" title="Step2. 規劃資料結構：建置資料庫"></a>Step2. 規劃資料結構：建置資料庫</h3><h4 id="建立-comments-資料庫"><a href="#建立-comments-資料庫" class="headerlink" title="建立 comments 資料庫"></a>建立 comments 資料庫</h4><ul>
<li>id</li>
<li>nickname</li>
<li>content</li>
<li>creat_at</li>
</ul>
<p><img src="https://i.imgur.com/4WWjEaA.png"></p>
<h4 id="建立-users-資料庫"><a href="#建立-users-資料庫" class="headerlink" title="建立 users 資料庫"></a>建立 users 資料庫</h4><ul>
<li>id</li>
<li>nickname</li>
<li>username</li>
<li>password</li>
<li>creat_at</li>
</ul>
<p><img src="https://i.imgur.com/w8cOsfs.png"></p>
<hr>
<h2 id="實作留言板"><a href="#實作留言板" class="headerlink" title="實作留言板"></a>實作留言板</h2><p>可分為前後端。通常會先切出前端頁面，再加入功能，從資料庫取出並資料串聯到頁面。</p>
<h3 id="Step3-實作前端頁面"><a href="#Step3-實作前端頁面" class="headerlink" title="Step3. 實作前端頁面"></a>Step3. 實作前端頁面</h3><p>依照設計稿切出所需頁面，可參考<span class="exturl" data-url="aHR0cDovL21lbnRvci1wcm9ncmFtLmNvL210cjA0Z3JvdXAyL0hlaWRpL3dlZWs5L2luZGV4LnBocA==">留言板 DEMO<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="Step4-實作目標功能"><a href="#Step4-實作目標功能" class="headerlink" title="Step4. 實作目標功能"></a>Step4. 實作目標功能</h3><p>接著就進入重頭戲，也就是替靜態網頁加上各種功能。</p>
<h3 id="PHP-常用函式"><a href="#PHP-常用函式" class="headerlink" title="PHP 常用函式"></a>PHP 常用函式</h3><ul>
<li>用 <code>-&gt;</code> 符號：取用物件中的變數<ul>
<li>例如：<code>$conn-&gt;error</code></li>
</ul>
</li>
<li><code>require_once();</code>：取用資料夾中其他 library</li>
</ul>
<pre><code class="php=">require_once(&quot;conn.php&quot;);      // 連線到資料庫
require_once(&quot;utils.php&quot;);     // 導入常用函式</code></pre>
<h4 id="echo、print-r-與-var-dump-的區別"><a href="#echo、print-r-與-var-dump-的區別" class="headerlink" title="echo、print_r 與 var_dump 的區別"></a>echo、print_r 與 var_dump 的區別</h4><ul>
<li><code>echo</code>：印出變數、字串等<ul>
<li>例如: <code>echo &quot;hello World&quot;</code></li>
<li>若使用 echo 輸出引用變數時（如陣列），只會輸出陣列名</li>
</ul>
</li>
<li><code>print_r()</code>;：印出物件、陣列<ul>
<li>例如：<code>print_r($row);</code></li>
</ul>
</li>
<li><code>var_dump</code>：印出變數型態，作用是輸出變數的詳細資訊</li>
</ul>
<h4 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h4><ul>
<li><code>fetch_array()</code>：讀取資料同時，以數字與欄位名稱各存一次在陣列中</li>
<li><code>fetch_assoc()</code>：讀取的資料 Key 值設定為欄位名稱的陣列</li>
<li><code>fetch_row()</code>：讀取的資料 Key 值設定為依序的數字</li>
</ul>
<pre><code class="htmlmixed=">&lt;?php
  // 把 $result 資料的 Key 值設定為欄位名稱的陣列
  while($row = $result-&gt;fetch_assoc()) &#123;
?&gt;
  &lt;div class=&quot;card&quot;&gt;
    &lt;div class=&quot;card__avatar&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;card__body&quot;&gt;
        &lt;div class=&quot;card__info&quot;&gt;
          &lt;span class=&quot;card__author&quot;&gt;&lt;?php echo $row[&#39;nickname&#39;]; ?&gt;&lt;/span&gt;
          &lt;span class=&quot;card__time&quot;&gt;&lt;?php echo $row[&#39;created_at&#39;]; ?&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;p class=&quot;card__content&quot;&gt;&lt;?php echo $row[&#39;content&#39;]; ?&gt;&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;board__hr&quot;&gt;&lt;/div&gt;
&lt;?php &#125; ?&gt;</code></pre>
<p>若以 <code>print_r($row);</code> 印出上述程式碼，可知 <code>$row</code> 為陣列：<br><img src="https://i.imgur.com/EnxNFAl.png"></p>
<h4 id="檢查是否存在"><a href="#檢查是否存在" class="headerlink" title="檢查是否存在"></a>檢查是否存在</h4><ul>
<li><code>isset()</code>：檢查是否有此變數</li>
<li><code>empty()</code>：檢查是否有值</li>
</ul>
<pre><code class="php=">$username = NULL;
// 如果 session 中沒有存 username，就讀取 session
if(!empty($_SESSION[&#39;username&#39;])) &#123;
  $username = $_SESSION[&#39;username&#39;];
&#125;</code></pre>
<ul>
<li><code>query()</code>：判斷資料庫查詢是否成功<ul>
<li>順利執行回傳 true</li>
<li>查詢的帳密有誤、查詢的指定資料庫、資料表欄位有誤等，均回傳 false</li>
</ul>
</li>
<li><code>exit()</code> 和 <code>die()</code>：兩者幾乎相同，均為輸出消息後退出程式</li>
</ul>
<pre><code class="php=">// 以 id 進行 DESC（遞減）排序：&quot;後新增的留言&quot;會排在前面
$result = $conn-&gt;query(&quot;SELECT * FROM comments ORDER BY id DESC&quot;);
// 檢查是否查詢成功
if (!$result) &#123;
  die(&#39;Error:&#39; . $conn-&gt;error);
&#125;</code></pre>
<ul>
<li><code>sprintf()</code>：裡面可放入替代字元</li>
</ul>
<p>例如使用 <code>sprintf()</code> 做 SELECT：</p>
<pre><code class="php=">// handle_login.php
  $sql = sprintf(
    &quot;SELECT * FROM users WHERE username=&#39;%s&#39; AND password=&#39;%s&#39;&quot;,
    $username,
    $password
  );

// 把執行結果存在 $result 這個變數中
$result = $conn-&gt;query($sql);
// 確認是否有拿到結果
if (!$result) &#123;
  die($conn-&gt;error);
&#125;</code></pre>
<p>用 <code>sprintf()</code> 做 INSERT INTO：</p>
<pre><code class="php=">// handle_add_comment.php
$sql = sprintf(
  &quot;INSERT INTO comments(nickname, content) VALUES(&#39;%s&#39;, &#39;%s&#39;)&quot;,
  $nickname,
  $content
  );

// handle_register.php
$sql = sprintf(
  &quot;INSERT INTO users(nickname, username, password) VALUES(&#39;%s&#39;, &#39;%s&#39;, &#39;%s&#39;)&quot;,
  $nickname,
  $username,
  $password
);</code></pre>
<h3 id="conn-php-連線資料庫"><a href="#conn-php-連線資料庫" class="headerlink" title="conn.php 連線資料庫"></a><code>conn.php</code> 連線資料庫</h3><blockquote>
<p>【注意】由於 <code>conn.php</code> 放有帳號密碼等重要資料，因此在 commit 前需加入 <code>git.ignore</code>，不進行版本控制。</p>
</blockquote>
<p>程式碼如下：</p>
<pre><code class="php=">&lt;?php
  $server_name = &#39;localhost&#39;;
  $username = &#39;heidi&#39;;
  $password = &#39;1234&#39;;
  $db_name = &#39;heidiDB&#39;;

  // `mysqli` 的四個參數分別為：伺服器名稱、帳號、密碼、資料庫名稱
  $conn = new mysqli($server_name, $username, $password, $db_name);

  // 確認是否出現連線錯誤
  if (!empty($conn-&gt;connect_error)) &#123;
    die(&#39;資料庫連線錯誤:&#39; . $conn-&gt;connect_error);
  &#125;

  // 設定編碼，避免出現亂碼
  $conn-&gt;query(&#39;SET NAMES UTF8&#39;);
  // 設定成臺灣時區
  $conn-&gt;query(&#39;SET time_zone = &quot;+8:00&quot;&#39;);
?&gt;
</code></pre>
<h3 id="index-php-顯示所有留言"><a href="#index-php-顯示所有留言" class="headerlink" title="index.php 顯示所有留言"></a><code>index.php</code> 顯示所有留言</h3><pre><code class="php=">&lt;?php
  session_start();
  // 連線到資料庫
  require_once(&quot;conn.php&quot;);
  require_once(&quot;utils.php&quot;);

  $username = NULL;
  if(!empty($_SESSION[&#39;username&#39;])) &#123;
    $username = $_SESSION[&#39;username&#39;];
  &#125;

  // 以 id 進行 desc（遞減）排序，也就是&quot;後新增的留言&quot;會排在前面
  $result = $conn-&gt;query(&quot;SELECT * FROM comments ORDER BY id DESC&quot;);
  // 檢查是否有資料
  if (!$result) &#123;
    die(&#39;Error:&#39; . $conn-&gt;error);
  &#125;
?&gt;</code></pre>
<hr>
<h2 id="儲存狀態的方式：Cookie-amp-Session"><a href="#儲存狀態的方式：Cookie-amp-Session" class="headerlink" title="儲存狀態的方式：Cookie &amp; Session"></a>儲存狀態的方式：Cookie &amp; Session</h2><h3 id="使用-Cookie-記住-HTTP-狀態"><a href="#使用-Cookie-記住-HTTP-狀態" class="headerlink" title="使用 Cookie 記住 HTTP 狀態"></a>使用 Cookie 記住 HTTP 狀態</h3><p>首先要了解 Cookie 是什麼：</p>
<ul>
<li>是一種小型純文字檔案，</li>
<li>網站伺服器會將其儲存在 client 端，以記錄使用者的相關資訊。</li>
<li>例如：會員登入狀態、瀏覽紀錄、購物車等。</li>
</ul>
<p>由於 HTTP 是一個無狀態協議，會把每一次收到的請求都視為獨立的行為。但伺服器能透過 response header 的 <code>Set-Cookie</code> 屬性，將使用者狀態記錄在 Cookie。</p>
<p>瀏覽器會在每次發送請求時，自動在 request header 帶上 Cookie 資料；伺服器即可藉由檢視 Cookie 內容，得知瀏覽器使用者的狀態。</p>
<p><img src="https://i.imgur.com/WsBvdz5.png"></p>
<p>但這麼做有個缺點，儲存在 client 端的 Cookie 是能夠被竄改的，因此不適合放機密或重要的資訊。這時有兩種解法：</p>
<h4 id="1-將-Cookie-內容加密"><a href="#1-將-Cookie-內容加密" class="headerlink" title="1. 將 Cookie 內容加密"></a>1. 將 Cookie 內容加密</h4><p>也就是 Cookie-based session，把狀態加密後存在 Cookie。但如果加密方式以及密鑰被破解，往後仍有安全疑慮。</p>
<h4 id="2-透過-Session-ID-辨識身分"><a href="#2-透過-Session-ID-辨識身分" class="headerlink" title="2. 透過 Session ID 辨識身分"></a>2. 透過 Session ID 辨識身分</h4><p>全名是 Session Identifier。如此 Server 只需在 Cookie 儲存一組亂數產生的 Session ID，其餘狀態資訊則存在 Server 端。</p>
<p>因此，Session 其實就是一種讓 Request 變成 stateful 的機制。</p>
<p><img src="https://i.imgur.com/Nbk8TCj.png"></p>
<h3 id="如何使用-Session"><a href="#如何使用-Session" class="headerlink" title="如何使用 Session"></a>如何使用 Session</h3><h4 id="儲存-Session"><a href="#儲存-Session" class="headerlink" title="儲存 Session"></a>儲存 Session</h4><p>當 <code>$_SEESION</code> 儲存成功，會進行下列三件事：</p>
<ol>
<li>產生 sesseion id (token) </li>
<li>把 username 寫入檔案</li>
<li><code>set-cookie</code>: <code>session-id</code></li>
</ol>
<pre><code class="php=">// 使用 Session 時，均需在開頭加上 session_start()
session_start();

$username = htmlspecialchars($_POST[&#39;username&#39;]);

// 把資料存在 Session 對應的 key 裡面
$_SEESION[&#39;username&#39;] = $username;</code></pre>
<h4 id="讀取-Session"><a href="#讀取-Session" class="headerlink" title="讀取 Session"></a>讀取 Session</h4><p>當 <code>$_SESSION</code> 讀取資料時，會進行下列三件事：</p>
<ol>
<li>從 cookie 裡讀取 PHPSESSID (token)</li>
<li>從檔案裡面讀取 session id 的內容</li>
<li>把內容放到 <code>$_SESSION</code></li>
</ol>
<pre><code class="php=">session_start();

// 若 Session 內有存過 username，則 $username 為剛才存的 $_SESSION[&#39;username&#39;] 
if(isset($_SESSION[&#39;username&#39;])) &#123;
  $username = $_SESSION[&#39;username&#39;];
&#125;</code></pre>
<h4 id="清除-Session"><a href="#清除-Session" class="headerlink" title="清除 Session"></a>清除 Session</h4><pre><code class="php=">session_start();

// 直接清除所有 session
session_destroy();</code></pre>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIyNzYwMg==">27. [WEB] Cookie &amp; Session 是什麼？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BodWxpdHcvc2Vzc2lvbi1hbmQtY29va2llLTE1ZTQ3ZWQ4MzhiYw==">白話 Session 與 Cookie：從經營雜貨店開始<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 9] 後端基礎 - PHP 語法、資料庫 MySQL</title>
    <url>/php-mysql/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvYmUxMDEtcGhwLW15c3Fs">[BE101] 用 PHP 與 MySQL 學習後端基礎<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<pre><code>學習目標：

 P1 你知道 PHP 是什麼
 P1 你知道前端與後端的差別
 P1 你知道什麼是資料庫
 P1 你了解基本的 SQL 語法，包括 Select、Insert Into、Delete 與 Update
 P1 你能夠寫出基本的 CRUD 應用
 P1 你知道什麼是 Session
 P1 你知道什麼是 Cookie
 P1 你知道 Session 與 Cookie 的差別</code></pre>
<a id="more"></a>
<hr>
<h2 id="「後端」是什麼？"><a href="#「後端」是什麼？" class="headerlink" title="「後端」是什麼？"></a>「後端」是什麼？</h2><p>後端實際上包含以下三大項（括弧內為舉例使用的程式）：</p>
<ol>
<li>網頁伺服器（Apache）：伺服器程式。專門處理 Request 與 Response，是後端最重要的部分。</li>
<li>寫程式（PHP）：接收網頁伺服器的 Request 並執行後端語言，處理成 output，通常是 html。</li>
<li>資料庫系統（MySQL）：資料庫程式。專門用來操作資料庫，能夠更有效率儲存、修改或查詢資料。</li>
</ol>
<h2 id="後端環境建置"><a href="#後端環境建置" class="headerlink" title="後端環境建置"></a>後端環境建置</h2><p>以下透過 XAMPP 來進行實作。XAMPP 結合了 Apache + <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLXR3L01hcmlhREI=">MariaDB<i class="fa fa-external-link-alt"></i></span> + PHP，能夠快速建置後端環境。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTXlTUUw=">MySQL<i class="fa fa-external-link-alt"></i></span> 為目前市佔率最高的資料庫系統。但 XAMPP 上使用的是 MariaDB 而非 MySQL。這是因為當初 MySQL 被甲骨文公司收購後，開發者擔心會有後患，像是轉為商用等等，於是社群就 clone 出 MariaDB ，因此這兩個系統幾乎完全相同。</p>
</blockquote>
<h3 id="XAMPP"><a href="#XAMPP" class="headerlink" title="XAMPP"></a>XAMPP</h3><ol>
<li>到 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXBhY2hlZnJpZW5kcy5vcmcvemhfdHcvaW5kZXguaHRtbA==">XAMPP 官網<i class="fa fa-external-link-alt"></i></span> 下載程式並安裝</li>
<li>開啟 XAMPP 並運行 Apache 和 MySQL</li>
</ol>
<p><img src="https://i.imgur.com/UwHMX0L.png"></p>
<ol start="3">
<li>點選 Adimn 開啟網頁：<code>http://localhost/dashboard/</code>，出現以下畫面就代表安裝成功！</li>
</ol>
<p><img src="https://i.imgur.com/5V5s0ra.png" alt="XAMPP"></p>
<ol start="4">
<li>以 XAMPP 程式而言，PHP 檔案都會放在 htdocs 資料夾內，且<code>網址路徑 = 檔案路徑</code></li>
</ol>
<p><img src="https://i.imgur.com/0DMgMWL.png" alt="htdocs"></p>
<ol start="5">
<li>以下為範例在 hotdocs 另建一個資料夾 heidi，裡面新建 test.php，並在編輯器輸入下列程式碼：</li>
</ol>
<pre><code class="php">&lt;?php
  echo &quot;I am Heidi, yo!&quot;
?&gt;</code></pre>
<ol start="6">
<li>以瀏覽器運行該網址：<code>http://localhost/heidi/test.php</code></li>
</ol>
<p><img src="https://i.imgur.com/dt6vRqk.png" alt="test.php"></p>
<hr>
<h2 id="靜態網頁-vs-動態網頁"><a href="#靜態網頁-vs-動態網頁" class="headerlink" title="靜態網頁 vs 動態網頁"></a>靜態網頁 vs 動態網頁</h2><p>網頁中的「靜態」與「動態」，並非代表視覺上的移動，兩者差異在於是否以「伺服器程式」去產生網頁上的資料。</p>
<h3 id="靜態網頁"><a href="#靜態網頁" class="headerlink" title="靜態網頁"></a>靜態網頁</h3><ul>
<li>server 收到 request 後，找到相對應的檔案（<code>.css</code> 是靜態檔案）後，把檔案直接回傳 response</li>
<li>檔案內容是什麼就回傳什麼</li>
</ul>
<p><img src="https://i.imgur.com/p1FRoiG.png"></p>
<h3 id="動態網頁"><a href="#動態網頁" class="headerlink" title="動態網頁"></a>動態網頁</h3><ul>
<li>server 收到 request 後，會將 <code>.php</code> 檔案給 php 處理成 output，再傳給 server 後回傳 response</li>
<li>可根據用戶的點擊、輸入等操作，迅速產生響應與動態變化，例如部落格、留言板等</li>
</ul>
<p><img src="https://i.imgur.com/Y5BDM4e.png"></p>
<h2 id="PHP-是什麼？"><a href="#PHP-是什麼？" class="headerlink" title="PHP 是什麼？"></a>PHP 是什麼？</h2><p>PHP 全名是 Hypertext Preprocessor（超文本預處理器）。和 ASP、JSP 等都是動態網頁開發語言。</p>
<p>PHP 語言是伺服器端（Server）執行的網頁，因此 PHP 必須在伺服器端執行完後，再將結果回傳給用戶端（Clint）的瀏覽器檢視並渲染。</p>
<h3 id="Apache、PHP-與資料庫運作原理"><a href="#Apache、PHP-與資料庫運作原理" class="headerlink" title="Apache、PHP 與資料庫運作原理"></a>Apache、PHP 與資料庫運作原理</h3><p><img src="https://i.imgur.com/XHHg6LO.png"></p>
<pre><code>request → apache → php → output → apache → response
　　　　　 (server)       (html)</code></pre>
<p>執行步驟大致如下：</p>
<ol>
<li>server 接收 request</li>
<li>server 轉給 php 處理</li>
<li>php 處理成 html</li>
<li>將 output 傳給 server</li>
<li>server 回傳 response</li>
</ol>
<p>由此可知，後端最重要的是「伺服器程式」。若沒有伺服器程式，網站會直接掛掉；但沒有後端語言，就只是變回靜態網站，檔案內容是什麼就回傳什麼。</p>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaGFwcHljb2RpbmcudG9kYXkvcG9zdHMvMjM=">PHP新手指南：3分鐘快速認識PHP<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="PHP-基礎語法"><a href="#PHP-基礎語法" class="headerlink" title="PHP 基礎語法"></a>PHP 基礎語法</h2><ul>
<li>php 語法以 <code>&lt;? php</code> 開頭，<code>?&gt;</code> 結尾包起來，沒有包含在其中的程式碼，就是單純的 html，會直接被顯示出來</li>
<li>每句結尾須加上分號 <code>;</code></li>
</ul>
<pre><code class="php">&lt;?php

  echo &quot;Hello World&quot;;    // 印出 Hello World

?&gt;</code></pre>
<ul>
<li>變數均以 <code>$</code> 符號開頭</li>
<li>不需要宣告變數，直接賦值即可使用</li>
<li>字串連接用 <code>.</code>，數字相加用 <code>+</code></li>
</ul>
<pre><code class="php">&lt;?php

  $x = 10000;
  $y = 5.5;
  $str = &#39;hello&#39;;

  echo $x + $y . &#39;&lt;br&gt;&#39;;  // 印出 10005.5
  echo $x . $str;         //      10000hello

?&gt;</code></pre>
<h3 id="迴圈"><a href="#迴圈" class="headerlink" title="迴圈"></a>迴圈</h3><p>寫法和其他程式語言差不多，惟須注意變數前要加 <code>$</code>：</p>
<pre><code class="php">&lt;?php
  for ($i = 1; $i &lt;= 5; $i++) &#123;
    echo $i . &#39;&lt;br&gt;&#39;;
  &#125;
?&gt;</code></pre>
<p>結果如下：</p>
<p><img src="https://i.imgur.com/RgZfI7h.png" alt="迴圈"></p>
<h3 id="陣列-array"><a href="#陣列-array" class="headerlink" title="陣列 array"></a>陣列 array</h3><ul>
<li><code>sizeof()</code>：返回單元中的元素數量，和 <code>count()</code> 功能相同。</li>
</ul>
<pre><code class="php">&lt;?php
// 建立陣列
$arr = array(1, 3, 5, 7, 9);

// 印出陣列長度：5
echo $length = sizeof($arr) . &#39;&lt;br&gt;&#39;;

// 印出最後一個元素：9
echo $arr[sizeof($arr) - 1];
?&gt;</code></pre>
<ul>
<li>輸出完整陣列：<ul>
<li><code>var_dump()</code>：輸出 index =&gt; 型態和值：type(value)</li>
<li><code>print_r()</code>：較簡潔，輸出 index =&gt; 值：[value]</li>
</ul>
</li>
</ul>
<pre><code class="php">&lt;?php
$arr = array(1, &#39;a&#39;, 10, &#39;b&#39;, 100);
echo var_dump($arr) . &#39;&lt;br&gt;&#39;;
// 印出 array(5) &#123; [0]=&gt; int(1) [1]=&gt; string(1) &quot;a&quot; [2]=&gt; int(10) [3]=&gt; string(1) &quot;b&quot; [4]=&gt; int(100) &#125;

print_r($arr);
// 印出 Array ( [0] =&gt; 1 [1] =&gt; a [2] =&gt; 10 [3] =&gt; b [4] =&gt; 100 )
?&gt;</code></pre>
<h3 id="其他函式"><a href="#其他函式" class="headerlink" title="其他函式"></a>其他函式</h3><ul>
<li><code>data(&quot;Y-m-d H:i:s&quot;)</code>：輸出現在時間</li>
</ul>
<hr>
<h2 id="資料庫系統-Database-System"><a href="#資料庫系統-Database-System" class="headerlink" title="資料庫系統 Database System"></a>資料庫系統 Database System</h2><ul>
<li>資料庫系統（Database System）：專門管理資料庫的程式</li>
<li>資料庫（Database）：儲存資料的地方，可視為多個資料表的集合</li>
</ul>
<p>之所以要有資料庫系統，利用現成的資料庫介面，我們能夠快速進行新增、修改、查看、刪除資料等操作，方便管理檔案與維護。</p>
<h3 id="關聯式資料庫（RDBMS）"><a href="#關聯式資料庫（RDBMS）" class="headerlink" title="關聯式資料庫（RDBMS）"></a>關聯式資料庫（RDBMS）</h3><ul>
<li>全名是 Relational Database Management System</li>
<li>以 SQL 語言（專門用來管理與查詢關聯式資料庫）操作</li>
<li>用不同 table 存取不同類型的內容，但資料之間保有相關性，避免不相關的資料互相干擾</li>
<li>常見程式：MySQL、PostgreSQL、Microsoft SQL Server</li>
<li>例如：會員資料庫，其中明確關聯是會員 ID</li>
</ul>
<h3 id="非關聯式資料庫（NoSQL）"><a href="#非關聯式資料庫（NoSQL）" class="headerlink" title="非關聯式資料庫（NoSQL）"></a>非關聯式資料庫（NoSQL）</h3><ul>
<li>全名是 Not Only SQL</li>
<li>以 NoSQL 語言操作</li>
<li>彈性較高，沒有形態上的限制，可儲存較複雜的資料</li>
<li>常見程式：mongoDB</li>
<li>例如：存取 log 日誌、社群上的大量資訊（按讚數）</li>
</ul>
<h3 id="如何管理資料庫"><a href="#如何管理資料庫" class="headerlink" title="如何管理資料庫"></a>如何管理資料庫</h3><p>我們可分別利用 CLI 或 GUI 介面來進行管理：</p>
<ul>
<li>CLI：mysql connect，在終端機下指令連線</li>
<li>GUI：phpMyAdmin、Adminer、Sequel Pro 等，利用網頁介面連線</li>
</ul>
<h3 id="phpMyAdmin"><a href="#phpMyAdmin" class="headerlink" title="phpMyAdmin"></a>phpMyAdmin</h3><p>phpMyAdmin 是一套基於 PHP 寫的 GUI 資料庫管理軟體，其本質就是一個 PHP 檔案，讓管理者能夠以 GUI 介面來管理 MySQL 資料庫。</p>
<p>可從 <code>http://localhost:8080</code> 點選 phpmyadmin 進入：</p>
<p><img src="https://i.imgur.com/1guMNR9.png"></p>
<p>管理介面如下所示：</p>
<p><img src="https://i.imgur.com/hNpYDDJ.png"></p>
<h2 id="Table-schema-結構簡介"><a href="#Table-schema-結構簡介" class="headerlink" title="Table schema 結構簡介"></a>Table schema 結構簡介</h2><p>Table schema（資料庫結構），當我們在開資料庫以前，要先進行資料型態、有無預設值、是否為唯一等設定，而之後的資料均須符合當初設定的結構，否則會無法成功新增。</p>
<h3 id="資料型態"><a href="#資料型態" class="headerlink" title="資料型態"></a>資料型態</h3><ul>
<li>id：<code>int</code><ul>
<li>勾選 ai（auto increment）為保證遞增，但 id 不一定為連續</li>
<li>設定 primary index：代表是唯一值</li>
</ul>
</li>
<li>VARCHAR：適合存取較短的資料，可設定長度。通常用於：預期資料有特定長度的情況。</li>
<li>TEXT：適合存取較長的資料，不可設定長度。通常用於：留言板、部落格文章。<ul>
<li>通常建議使用 VARCHAR，查詢速度較快，且能夠有效減少資料庫文件大小。</li>
</ul>
</li>
<li>日期：datetime、預設值改成 current timestamp</li>
</ul>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly9yZWFkMDEuY29tL095eGVHeS5odG1s">mysql中char，varchar與text類型的區別和選用<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 index"></a>索引 index</h3><p>可作為書本的目錄，建立某欄位的索引，目的是加快搜尋速度。</p>
<h4 id="Index：索引鍵"><a href="#Index：索引鍵" class="headerlink" title="Index：索引鍵"></a>Index：索引鍵</h4><ul>
<li>可多欄位設定 Index</li>
</ul>
<h4 id="Primary-Key（PK）：主鍵"><a href="#Primary-Key（PK）：主鍵" class="headerlink" title="Primary Key（PK）：主鍵"></a>Primary Key（PK）：主鍵</h4><ul>
<li>每個 table 只能有一個 Primary Key</li>
<li>不能為空值、不能重複，是 table 裡面最主要的欄位</li>
<li>當設置某欄位為 Primary Key 時，該欄位會自動加上 unique index</li>
</ul>
<h4 id="Unique-Index：不重複鍵"><a href="#Unique-Index：不重複鍵" class="headerlink" title="Unique Index：不重複鍵"></a>Unique Index：不重複鍵</h4><ul>
<li>和 Index 相同，差異在於不能允許重複值</li>
</ul>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm5pY2xpbi50dy8yMDE4LzA2LzA5L3NxbC0lRTUlOUYlQkElRTYlOUMlQUMlRTglQTclODAlRTUlQkYlQjUtcHJpbWFyeS1rZXktLy1pbmRleC0vLXVuaXF1ZS0lRTUlQjclQUUlRTUlODglQTUv">[SQL 基本觀念] primary Key / Index / Unique 差別<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<h2 id="MySQL-基礎語法"><a href="#MySQL-基礎語法" class="headerlink" title="MySQL 基礎語法"></a>MySQL 基礎語法</h2><h3 id="查詢資料-SELECT"><a href="#查詢資料-SELECT" class="headerlink" title="查詢資料 SELECT"></a>查詢資料 <code>SELECT</code></h3><ul>
<li>使用 <code>*</code> 查詢全部資料：<code>SELECT * FROM 資料夾名稱</code></li>
</ul>
<pre><code class="php=">SELECT * FROM users
// 從資料夾 users 裡面找到所有列，並取出所有欄位的值。</code></pre>
<ul>
<li>使用 <code>where</code> 條件設定：<code>SELECT * FROM 資料夾名稱 WHERE 條件</code></li>
</ul>
<pre><code class="php=">SELECT * FROM users WHERE username=heidi
// 從資料夾 users 裡面，找到 username 是 heidi 的那列，並取出該欄位的所有值。</code></pre>
<h3 id="新增資料-INSERT"><a href="#新增資料-INSERT" class="headerlink" title="新增資料 INSERT"></a>新增資料 <code>INSERT</code></h3><ul>
<li>使用 <code>INSERT INTO</code> 指令可新增資料：</li>
</ul>
<pre><code class="ph">INSERT INTO &quot;表格名&quot; (&quot;欄位1&quot;, &quot;欄位2&quot;, ...) VALUES (&quot;值1&quot;, &quot;值2&quot;, ...);</code></pre>
<pre><code class="php=">INSERT INTO users(username, content) values (Peter, 1234)
// 新增一筆記錄，username 是 Peter；content 是 1234。</code></pre>
<h3 id="修改資料-UPDATE"><a href="#修改資料-UPDATE" class="headerlink" title="修改資料 UPDATE"></a>修改資料 <code>UPDATE</code></h3><pre><code class="ph">UPDATE &quot;表格名&quot; SET &quot;欄位1&quot;=[新值] WHERE &quot;條件&quot;;
// 若沒有加上 WHERE，就會更新表中的所有行</code></pre>
<pre><code class="php=">UPDATE users SET username = &quot;user02&quot;, content = &quot;content02&quot; WHERE id =2
// 修改 id 為 2 那列，username 為 user02；content 為 content02</code></pre>
<h3 id="刪除資料-DELETE"><a href="#刪除資料-DELETE" class="headerlink" title="刪除資料 DELETE"></a>刪除資料 <code>DELETE</code></h3><pre><code class="php=">DELETE FROM users WHERE id = 2
// 若沒有加上 WHERE，系統會選取所有行，即刪除所有資料。</code></pre>
<h2 id="從前端傳資料給後端"><a href="#從前端傳資料給後端" class="headerlink" title="從前端傳資料給後端"></a>從前端傳資料給後端</h2><p>前端通常利用 <code>form</code> 來傳送資料給後端：</p>
<ul>
<li>form 要設定 method 和 action 屬性<ul>
<li>method：方法，<code>GET</code> 或 <code>POST</code></li>
<li>action：接收資料的程式</li>
</ul>
</li>
</ul>
<ol>
<li>先在 index.php 檔案建立表單</li>
</ol>
<pre><code class="htmlmixed=">&lt;form method=&quot;GET&quot; action=&quot;test.php&quot;&gt;
  name: &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;
  age: &lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;
  &lt;input type=&quot;submit&quot;/&gt;
&lt;/form&gt;</code></pre>
<p>在瀏覽器開啟表單如下：</p>
<p><img src="https://i.imgur.com/Dl9UlBX.png"></p>
<ol start="2">
<li>在接收資料的 test.php 檔案撰寫 php 語法</li>
</ol>
<pre><code class="php=">&lt;?php
  // 用 empty 檢查表單是否為空
  if (empty($_GET[&#39;name&#39;]) || empty($_GET[&#39;age&#39;]))&#123;
      echo &#39;資料有缺，請再次填寫&lt;br&gt;&#39;;
      exit();   // 終止程序
  &#125;;
  // 接收 method 為 GET 的 From input
  echo &quot;Hello!&quot; . $_GET[&#39;name&#39;] . &quot; &lt;br&gt;&quot;;
  echo &quot;Your age is&quot; . $_GET[&#39;age&#39;] . &quot; &lt;br&gt;&quot;;

  print_r($_GET);
?&gt;</code></pre>
<p>在前端以 GET 方法提交表單，資料會以 Query String 的形式將加在網址後方：</p>
<p><img src="https://i.imgur.com/nEr23zE.png"></p>
<h2 id="用-PHP-操作-MySQL"><a href="#用-PHP-操作-MySQL" class="headerlink" title="用 PHP 操作 MySQL"></a>用 PHP 操作 MySQL</h2><h3 id="從-PHP-連線到-MySQL-資料庫"><a href="#從-PHP-連線到-MySQL-資料庫" class="headerlink" title="從 PHP 連線到 MySQL 資料庫"></a>從 PHP 連線到 MySQL 資料庫</h3><h4 id="conn-php"><a href="#conn-php" class="headerlink" title="conn.php"></a>conn.php</h4><ul>
<li>存放帳密等重要資料，需加入 git.ignore 不進行版本控制</li>
</ul>
<pre><code class="php=">&lt;?php
  $server_name = &#39;localhost&#39;;
  $username = &#39;heidi&#39;;
  $password = &#39;h232425123&#39;;
  $db_name = &#39;heidi&#39;;

  // mysqli 的四個參數分別為：伺服器名稱、帳號、密碼、資料庫名稱
  $conn = new mysqli($server_name, $username, $password, $db_name);

  if (!empty($conn-&gt;connect_error)) &#123;
    die(&#39;資料庫連線錯誤:&#39; . $conn-&gt;connect_error);    // die()：終止程序
  &#125;
?&gt;</code></pre>
<h4 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h4><pre><code class="php=">&lt;?php
  // 連線到資料庫
  require_once(&#39;conn.php&#39;);

  // 用 empty 檢查表單是否為空
  if (empty($_GET[&#39;name&#39;]) || empty($_GET[&#39;age&#39;]))&#123;
      echo &#39;資料有缺，請再次填寫&lt;br&gt;&#39;;
      exit();   // 終止程序
  &#125;;
  // 接收 method 為 GET 的 From input
  echo &quot;Hello! &quot; . $_GET[&#39;name&#39;] . &quot; &lt;br&gt;&quot;;
  echo &quot;Your age is &quot; . $_GET[&#39;age&#39;] . &quot; &lt;br&gt;&quot;;

  print_r($_GET);
?&gt;</code></pre>
<h4 id="新增資料"><a href="#新增資料" class="headerlink" title="新增資料"></a>新增資料</h4><pre><code class="php=">&lt;?php
  // 連線到資料庫
  require_once(&#39;conn.php&#39;);

  // $_POST[&#39;key-name&#39;] 取得輸入的資料
  // 以 empty() 判斷值是否為 null
  if (empty($_POST[&#39;username&#39;])) &#123;
    // 中斷後面程序並顯示內容，() 內可輸入訊息字串
    die(&#39;請輸入 username&#39;); 
  &#125;

  $username = $_POST[&#39;username&#39;]; 
         // sprintf() 裡面可以放入替代字元
  $sql = sprintf(  
     // 插入新欄位，%s 代表字串，值是第二個參數
    &quot;INSERT INTO users(username) VALUES(&#39;%s&#39;)&quot;,
    $username
  );
  // 執行結果存在 $result 這個變數中
  $result = $conn-&gt;query($sql);
  // 確認是否有拿到結果
  if (!$result) &#123;
    die($conn-&gt;error);
  &#125;

  header(&quot;Location: index.php&quot;); // 自動跳轉回 index.php
?&gt;</code></pre>
<h4 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h4><pre><code class="php=">&lt;?php
  // 連線到資料庫
  require_once(&#39;conn.php&#39;);

  if (empty($_GET[&#39;id&#39;])) &#123;
    die(&#39;請輸入 id&#39;);
  &#125;

  $id = $_GET[&#39;id&#39;];
  $sql = sprintf(
    &quot;delete from users where id = %d&quot;,
    $id
  );
  echo $sql . &#39;&lt;br&gt;&#39;;
  $result = $conn-&gt;query($sql);
  if (!$result) &#123;
    die($conn-&gt;error);
  &#125;

  if ($conn-&gt;affected_rows &gt;= 1) &#123; // 判斷影響 1 列以上資料
    echo &#39;刪除成功&#39;;
  &#125; else &#123;
    echo &#39;查無資料&#39;;
  &#125;

  // header(&quot;Location: index.php&quot;);
?&gt;</code></pre>
<h4 id="編輯資料"><a href="#編輯資料" class="headerlink" title="編輯資料"></a>編輯資料</h4><pre><code class="php=">&lt;?php
  require_once(&#39;conn.php&#39;);

  if (empty($_POST[&#39;id&#39;]) || empty($_POST[&#39;username&#39;])) &#123;
    die(&#39;請輸入 id 與 username&#39;);
  &#125;

  $id = $_POST[&#39;id&#39;];
  $username = $_POST[&#39;username&#39;];
  $sql = sprintf(
    // 帶入兩個參數：%s（字串）、%d
    &quot;update users set username=&#39;%s&#39; where id=%d&quot;,
    $username,
    $id
  );
  echo $sql . &#39;&lt;br&gt;&#39;;
  $result = $conn-&gt;query($sql);
  if (!$result) &#123;
    die($conn-&gt;error);
  &#125;

  header(&quot;Location: index.php&quot;);
?&gt;</code></pre>
<hr>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtaWFoc3V3b3JrLyVFNyVBQyVBQyVFNCVCOSU5RCVFOSU4MCVCMS0lRTUlQkUlOEMlRTclQUIlQUYlRTUlOUYlQkElRTclQTQlOEUtJUU1JTlGJUJBJUU2JTlDJUFDJUU5JTgxJThCJUU0JUJEJTlDJUU1JThFJTlGJUU3JTkwJTg2LSVFNiU5MCVBRCVFOSU4NSU4RC14YW1wcC0xNTkzZjk4MTczNzc=">[第九週]後端基礎— 基本運作原理(搭配 XAMPP) - Mia<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtaWFoc3V3b3JrLyVFNyVBQyVBQyVFNCVCOSU5RCVFOSU4MCVCMS0lRTUlQkUlOEMlRTclQUIlQUYlRTUlOUYlQkElRTclQTQlOEUtcGhwLSVFNSU5RiVCQSVFNyVBNCU4RSVFOCVBQSU5RSVFNiVCMyU5NS1hNjMyODc4YmY4ZWE=">[第九週]後端基礎 — PHP 基礎語法- Mia<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vYlMtMmV2bEFUY2VWYy1kaS1STXhWQQ==">後端基礎 - PHP、SQL、Database - RZ-Huang<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vSFNnaWJSajJSMjJlbzdiay1xYkpzdz92aWV3LQ==">後端基礎 PHP 與 MySQL - Ruofan Wei<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 12] 結合前端與後端功能實作 Todo List</title>
    <url>/php-todolist/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvYmUxMDEtcGhwLW15c3Fs">[BE101] 用 PHP 與 MySQL 學習後端基礎<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<blockquote>
<p>hw2：<span class="exturl" data-url="aHR0cDovL21lbnRvci1wcm9ncmFtLmNvL210cjA0Z3JvdXAyL0hlaWRpL3dlZWsxMi9odzIvaW5kZXguaHRtbA==">Todo List<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<a id="more"></a>

<h2 id="前端實作"><a href="#前端實作" class="headerlink" title="前端實作"></a>前端實作</h2><h3 id="目標功能："><a href="#目標功能：" class="headerlink" title="目標功能："></a>目標功能：</h3><ul>
<li>新增功能：add</li>
<li>刪除功能：delete</li>
<li>編輯功能：update</li>
<li>更新狀態功能：checked / unchecked</li>
<li>切換列表：All / Active / Completed </li>
<li>清除所有 todo：Clear</li>
</ul>
<p>以上功能只要利用前端就能達成，程式碼如下：</p>
<h3 id="前端介面"><a href="#前端介面" class="headerlink" title="前端介面"></a>前端介面</h3><pre><code class="htmlmixed=">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Week12 Todo List&lt;/title&gt;
  &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css&quot;
    integrity=&quot;sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z&quot; crossorigin=&quot;anonymous&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;div class=&quot;wrapper&quot;&gt;
    &lt;div class=&quot;todo__header&quot;&gt;
      &lt;button type=&quot;button&quot; class=&quot;btn btn-save&quot; href=&quot;#&quot;&gt;Save&lt;/button&gt;
      &lt;button type=&quot;button&quot; class=&quot;btn clear-all&quot; href=&quot;#&quot;&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
    &lt;h1&gt;Todo List&lt;/h1&gt;
    &lt;div class=&quot;todo__input-block&quot;&gt;
      &lt;input class=&quot;todo__input&quot; type=&quot;text&quot; placeholder=&quot;Add New Todo Here...&quot; minlength=&quot;1&quot; maxlength=&quot;128&quot;&gt;
      &lt;button class=&quot;btn-new&quot;&gt;&lt;/button&gt;
    &lt;/div&gt;

    &lt;ul class=&quot;nav nav-middle justify-content-center todo__status&quot;&gt;
      &lt;li class=&quot;nav-item&quot;&gt;
        &lt;a class=&quot;nav-link active&quot; href=&quot;#&quot; data-filter=&quot;all&quot;&gt;All&lt;/a&gt;
      &lt;/li&gt;
      &lt;li class=&quot;nav-item&quot;&gt;
        &lt;a class=&quot;nav-link&quot; href=&quot;#&quot; data-filter=&quot;in-progress&quot;&gt;In Progress&lt;/a&gt;
      &lt;/li&gt;
      &lt;li class=&quot;nav-item&quot;&gt;
        &lt;a class=&quot;nav-link&quot; href=&quot;#&quot; data-filter=&quot;completed&quot;&gt;Completed&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;ul class=&quot;todo__list&quot;&gt;
      &lt;!-- 要新增 template 的區塊 --&gt;
      &lt;li class=&quot;todo&quot;&gt;
        &lt;input class=&quot;todo__check&quot; type=&quot;checkbox&quot; id=&quot;todo-0&quot;&gt;
        &lt;label class=&quot;todo__title&quot; for=&quot;todo&quot;&gt;Coding&lt;/label&gt;
        &lt;button class=&quot;btn-delete&quot;&gt;&lt;/button&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;


&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="前端-JavaScript"><a href="#前端-JavaScript" class="headerlink" title="前端 JavaScript"></a>前端 JavaScript</h3><pre><code class="javascript=">&lt;script&gt;
  let id = 1; 

  const template = `
    &lt;li class=&quot;todo&quot;&gt;
      &lt;input class=&quot;todo__check&quot; type=&quot;checkbox&quot; id=&quot;todo-&#123;id&#125;&quot;&gt;
      &lt;label class=&quot;todo__title&quot; for=&quot;todo-&#123;id&#125;&quot;&gt;&#123;content&#125;&lt;/label&gt;
      &lt;button class=&quot;btn-delete&quot;&gt;&lt;/button&gt;
    &lt;/li&gt;
  `
  // 新增功能: 點擊
  $(&#39;.btn-new&#39;).click(() =&gt; &#123;
    addTodo()
  &#125;);
  // 新增功能: 按 Enter
  $(&#39;.todo__input&#39;).keydown(e =&gt; &#123;
    if (e.key === &#39;Enter&#39;) &#123;
      addTodo()
    &#125;
  &#125;);

  // 刪除功能: 利用事件代理
  $(&#39;.todo__list&#39;).on(&#39;click&#39;, &#39;.btn-delete&#39;, (e) =&gt; &#123;
    $(e.target).parent().remove();
  &#125;);

  // 標記狀態: 已完成 / 未完成
  $(&#39;.todo__list&#39;).on(&#39;change&#39;, &#39;.todo__check&#39;, (e) =&gt; &#123;
    const target = $(e.target);
    const isChecked = target.is(&quot;:checked&quot;);
    if (isChecked) &#123;
      target.parents(&#39;.todo&#39;).addClass(&#39;checked&#39;);
    &#125; else &#123;
      target.parents(&#39;.todo&#39;).removeClass(&#39;checked&#39;);
    &#125;
  &#125;);

  // 篩選 todo 狀態
  $(&#39;.todo__status&#39;).on(&#39;click&#39;, &#39;a&#39;, e =&gt; &#123;
    const target = $(e.target);
    const filter = target.attr(&#39;data-filter&#39;);
    $(&#39;.todo__status a.active&#39;).removeClass(&#39;active&#39;);
    target.addClass(&#39;active&#39;);

    if (filter === &#39;all&#39;) &#123;
      $(&#39;.todo&#39;).show();
    &#125; else if (filter === &#39;in-progress&#39;) &#123;
      $(&#39;.todo&#39;).show();
      $(&#39;.todo.checked&#39;).hide();
    &#125; else &#123;        // completed
      $(&#39;.todo&#39;).hide();
      $(&#39;.todo.checked&#39;).show();
    &#125;
  &#125;);

  // 清除所有 todo
  $(&#39;.clear-all&#39;).click(() =&gt; &#123;
    $(&#39;.todo&#39;).remove();
  &#125;);

  // 儲存 todo
  $(&#39;.btn-save&#39;).click(() =&gt; &#123;
    let todos = [];
    $(&#39;.todo&#39;).each((i, element) =&gt; &#123;
      const input = $(element).find(&#39;.todo__check&#39;);
      const label = $(element).find(&#39;.todo__title&#39;);
      todos.push(&#123;
        id: input.attr(&#39;id&#39;).replace(&#39;todo-&#39;, &#39;&#39;),      // 把 todo-id 的 todo- 換成空字串
        content: label.text(),
        isDone: $(element).hasClass(&#39;checked&#39;)
      &#125;);    
    &#125;);
    JSON.stringify(todos);       // 將 JS 物件轉換成 JSON 字串
  &#125;);

  function addTodo() &#123;
    const value = $(&#39;.todo__input&#39;).val();
    if (!value) return;
    $(&#39;.todo__list&#39;).prepend(
      template
        .replace(&#39;&#123;content&#125;&#39;, escape(value))
        .replace(/&#123;id&#125;/g, id)
    );
    id += 1;
    $(&#39;.todo__input&#39;).val(&#39;&#39;);
  &#125;

  function escape(toOutput) &#123;
    return toOutput
      .replace(/&amp;/g, &#39;&amp;amp;&#39;)
      .replace(/&lt;/g, &#39;&amp;lt;&#39;)
      .replace(/&gt;/g, &#39;&amp;gt;&#39;)
      .replace(/&quot;/g, &#39;&amp;quot;&#39;)
      .replace(/&#39;/g, &#39;&amp;#039;&#39;);
  &#125;
&lt;/script&gt;</code></pre>
<h2 id="前後端串接"><a href="#前後端串接" class="headerlink" title="前後端串接"></a>前後端串接</h2><h3 id="目標功能"><a href="#目標功能" class="headerlink" title="目標功能"></a>目標功能</h3><ul>
<li>儲存功能：Save</li>
</ul>
<h3 id="PHP-API"><a href="#PHP-API" class="headerlink" title="PHP API"></a>PHP API</h3><p>將前端得到的資料 <code>JSON.stringify(todos)</code>，利用 Ajax 方式 POST 到資料庫：</p>
<pre><code class="javascript=">// 儲存 todo
$(&#39;.btn-save&#39;).click(() =&gt; &#123;
  let todos = [];
  $(&#39;.todo&#39;).each((i, element) =&gt; &#123;
    const input = $(element).find(&#39;.todo__check&#39;);
    const label = $(element).find(&#39;.todo__title&#39;);
    todos.push(&#123;
      id: input.attr(&#39;id&#39;).replace(&#39;todo-&#39;, &#39;&#39;),      // 把 todo-id 的 todo- 換成空字串
      content: label.text(),
      isDone: $(element).hasClass(&#39;checked&#39;)
    &#125;);    
  &#125;);
  const data = JSON.stringify(todos);       // 將 JS 物件轉換成 JSON 字串
  $.ajax(&#123;
    type: &#39;POST&#39;,
    url: &#39;http://localhost/heidi/week12_local/hw2/api_add_todo.php&#39;,
    data: &#123;
      todo: data
    &#125;,
    success: function(resp) &#123;
      const respId = resp.id
      window.location = &#39;index.html?id=&#39; + respId;
    &#125;,
    error: function () &#123;
      alert(&#39;Error!&#39;);
    &#125;
  &#125;);
&#125;);</code></pre>
<p>如此即可利用前端 JavaScript 從後端拿取 JSON 格式的資料，並用 <code>JSON.parse()</code> 將 JSON 字串轉換成 JavaScript 物件：</p>
<pre><code class="javascript=">// URLSearchParams(): 解析網址參數
const serchParams = new URLSearchParams(window.location.search);  // ?id=...
const todoId = serchParams.get(&#39;id&#39;);

if (todoId) &#123;
  $.getJSON(&#39;http://localhost/heidi/week12_local/hw2/api_get_todo.php?id=&#39; + todoId, function (data) &#123;
    const todos = JSON.parse(data.data.todo);
    restoreTodos(todos);
  &#125;);
&#125;</code></pre>
<p>將拿到的資料再以 JS 處理新增到頁面，把模版 template 加上 content、id、todoClass：</p>
<pre><code class="javascript=">function restoreTodos(todos) &#123;
  if (todos.length === 0) return;
  // id 要從讀取的最後一個 todo id 繼續增加
  id = todos[todos.length - 1].id + 1;
  for(let i = 0; i &lt; todos.length; i++) &#123;
    const todo = todos[i];
    $(&#39;.todo__list&#39;).prepend(
      template
        .replace(&#39;&#123;content&#125;&#39;, escape(todo.content))
        .replace(/&#123;id&#125;/g, todo.id)
        .replace(&#39;&#123;todoClass&#125;&#39;, todo.isDone ? &#39;checked&#39; : &#39;&#39;)
    );
  &#125;
&#125;</code></pre>
<hr>
<h2 id="Single-Page-Application"><a href="#Single-Page-Application" class="headerlink" title="Single Page Application"></a>Single Page Application</h2><p>Single Page Application（單頁面應用程式），簡稱 SPA。是前端利用 Ajax 以非同步方式串接後端 API，如此可將前後端分離，在交換資料時不需換頁，可透過動態方式更新部分頁面。</p>
<p>而早期的網頁主要採用 Multiple Page Application（多頁式應用程式）設計，與 SPA 概念相對應，每次交換資料時都需換頁。</p>
<h2 id="SPA-的優缺點"><a href="#SPA-的優缺點" class="headerlink" title="SPA 的優缺點"></a>SPA 的優缺點</h2><h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h3><ol>
<li>增進使用者體驗<br>不需換頁即可載入新的資訊。例如 Gmail 或影音播放網站，可以在播放音樂的同時，繼續瀏覽網站其他資訊。</li>
<li>前後端分離<br>後端只需負責制定 API 文件，提供前端資料。前端則利用 Ajax 從後端拿取資料，並以 JavaScript 在 html 動態產生內容。</li>
</ol>
<h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><ol>
<li>SEO（搜尋引擎最佳化）較差<br>由於 SPA 是利用 JavaScript 動態產生內容，檢視原始碼會發現原始內容是空的，<br>解決方法：第一次頁面由 Server side render，之後的操作都改用 Client side render，就可以保證搜尋引擎也能爬到完整的 HTML。</li>
<li>前端工作複雜化<br>原先是利用不同路由處理不同功能，改成由單一頁面統一管理，就像在網頁上實作 APP。</li>
<li>初次載入頁面費時<br>初次瀏覽頁面時會需要下載 JavaScript 或是其他頁面的 template。</li>
</ol>
<h2 id="由後端負責提供只輸出資料的-API-vs-PHP-直接輸出內容"><a href="#由後端負責提供只輸出資料的-API-vs-PHP-直接輸出內容" class="headerlink" title="由後端負責提供只輸出資料的 API vs PHP 直接輸出內容"></a>由後端負責提供只輸出資料的 API vs PHP 直接輸出內容</h2><h3 id="後端負責提供只輸出資料的-API"><a href="#後端負責提供只輸出資料的-API" class="headerlink" title="後端負責提供只輸出資料的 API"></a>後端負責提供只輸出資料的 API</h3><ul>
<li>Server 端接收到請求，會回傳 JSON 或其他特定格式的資料給前端，瀏覽器再將資料動態更新至頁面</li>
<li>因為是動態產生資料，檢視原始碼會發現動態更新的內容是空的</li>
</ul>
<h3 id="PHP-直接輸出內容"><a href="#PHP-直接輸出內容" class="headerlink" title="PHP 直接輸出內容"></a>PHP 直接輸出內容</h3><ul>
<li>Server 端接收到請求，會將所需資料與頁面經處理後回傳 html 檔給前端，瀏覽器透過重整頁面顯示</li>
<li>因此回傳的頁面，檢視原始碼是有包含資料的</li>
</ul>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BodWxpdHcvaW50cm9kdWN0aW9uLW12Yy1zcGEtYW5kLXNzci01NDVjOTQxNjY5ZTk=">跟著小明一起搞懂技術名詞：MVC、SPA 與 SSR<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRlY2hicmlkZ2UuY2MvMjAxNy8wOS8xNi9mcm9udGVuZC1iYWNrZW5kLW12Yy8=">前後端分離與 SPA<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDE2MDcwOQ==">Day20– 前端小字典三十天【每日一字】– SPA<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 21] 補充：Prettier 套件 - 自動整理程式碼格式</title>
    <url>/prettier-code-formatter/</url>
    <content><![CDATA[<h2 id="Prettier：Code-formatter"><a href="#Prettier：Code-formatter" class="headerlink" title="Prettier：Code formatter"></a>Prettier：Code formatter</h2><blockquote>
<p>相關安裝套件與如何操作可參考<span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGUtcmVhY3QtYXBwLmRldi9kb2NzL3NldHRpbmctdXAteW91ci1lZGl0b3Iv">官方文件<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
<p>Prettier 是一個 Code formatter，能夠將 JavaScript, TypeScript, CSS 程式碼格式化，進而統一程式碼風格（Coding Style）。</p>
<a id="more"></a>

<h3 id="安裝套件-amp-設定檔"><a href="#安裝套件-amp-設定檔" class="headerlink" title="安裝套件 &amp; 設定檔"></a>安裝套件 &amp; 設定檔</h3><p>為了進行程式碼格式化，共需要安裝下列三個套件：</p>
<ul>
<li><code>husky</code>: makes it possible to use githooks as if they are npm scripts.</li>
<li><code>lint-staged</code>: allows us to run scripts on staged files in git. See this blog post about lint-staged to learn more about it.</li>
<li><code>prettier</code>: is the JavaScript formatter we will run before commits.</li>
</ul>
<p>並在 package.json 檔案中加上套件相關資訊：</p>
<pre><code class="json=">+  &quot;husky&quot;: &#123;
+    &quot;hooks&quot;: &#123;
+      &quot;pre-commit&quot;: &quot;lint-staged&quot;
+    &#125;
+  &#125;,

+ &quot;lint-staged&quot;: &#123;
+   &quot;src/**/*.&#123;js,jsx,ts,tsx,json,css,scss,md&#125;&quot;: [
+     &quot;prettier --write&quot;
+   ]
+ &#125;,</code></pre>
<p>簡單來說，就是在 pre-commit 之前，透過 husky -&gt; lint-staged -&gt; prettier 這個傳遞過程，對 commit 的檔案做 prettier。</p>
<p>安裝完成後，在 commit 之前，prettier 就會自動檢查程式碼並進行格式化：</p>
<p><img src="https://i.imgur.com/JlV2aOS.png"></p>
<h3 id="在-VSCode-安裝-prettier"><a href="#在-VSCode-安裝-prettier" class="headerlink" title="在 VSCode 安裝 prettier"></a>在 VSCode 安裝 prettier</h3><p>除了安裝套件，在 VSCode 也有提供 <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWVzYmVucC5wcmV0dGllci12c2NvZGU=">Prettier<i class="fa fa-external-link-alt"></i></span> plugin 能夠使用。</p>
<p><img src="https://i.imgur.com/PBQKXwF.png"></p>
<p>接下來，就可以設定在存檔時執行 prettier，在設定中把 Format on Save 選項打勾：</p>
<p><img src="https://i.imgur.com/OEF4TpC.png"></p>
<p>接著隨意更改 JS 檔案並存檔，會看到右下角的小鈴鐺出現通知：</p>
<p><img src="https://i.imgur.com/vBbep8k.png"></p>
<p>點選設定後，可選取預設格式器：</p>
<p><img src="https://i.imgur.com/w33Lf4T.png"></p>
<p>這時候再次存檔，就會發現又下方有顯示 Prettier 運行結果，檔案中若有沒加逗號的地方、或是多於的空格會被格式化：</p>
<p><img src="https://i.imgur.com/1luVuIV.png"></p>
<p>透過 Prettier 這套工具，可以快速將程式碼格式化，但需注意 Prettier 只管理格式問題，語法上的錯誤仍需由 eslint 套件來檢查。</p>
<blockquote>
<p>可參考之前的學習筆記：<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWVzbGludA==">[week3] 設定 eslint：用來檢查語法的工具<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>Front-End</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 22] 再探 React：Function component vs Class component</title>
    <url>/react-class-function-hook/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUzMDItcmVhY3QtaG9va3M=">[FE302] React 基礎 - hooks 版本<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<ul>
<li>參考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmh1bGkudHcvMjAyMC8wNi8xNS9yZWFjdC1mdW5jdGlvbi1jbGFzcy1ob29rLXVzZWVmZmVjdC8=">從實際案例看 class 與 function component 的差異<i class="fa fa-external-link-alt"></i></span><a id="more"></a>

</li>
</ul>
<p>在學會如何在 React 中，以 Function component  搭配 Hooks 寫出簡單的 Todo List 之後，再來要探討使用 Function 或 Class 寫 component 的差異，即使目前主流是使用 Function component，未來還是有機會碰到 Class component 的寫法。</p>
<h2 id="Function-component-vs-Class-component"><a href="#Function-component-vs-Class-component" class="headerlink" title="Function component vs Class component"></a>Function component vs Class component</h2><p>在 React 16.8 之前，因為 function component 還沒有 useState、Hooks 的概念，需要描述 component 的狀態時通常會使用 Class component。</p>
<p>但在 React 16.8 有了 Hooks 以後，就能夠在  Function component 引入 Hooks 來表示狀態，這種寫法也成為目前主流。</p>
<p>而 class component 與 function component 兩者之間的差別主要在於：</p>
<ul>
<li>class component：關注的是這個「生命週期」要做什麼，</li>
<li>function component：每一次 render，都是「重新」呼叫一次 function，並且會記住「當下」傳入的值</li>
</ul>
<hr>
<h2 id="什麼是-Class-component？"><a href="#什麼是-Class-component？" class="headerlink" title="什麼是 Class component？"></a>什麼是 Class component？</h2><p>顧名思義，就是用 class 去實作一個 component，但這種寫法比起 function component，其實需要具備 JavsScript 物件導向的相關知識。</p>
<h3 id="範例：寫出一個-Button-component"><a href="#範例：寫出一個-Button-component" class="headerlink" title="範例：寫出一個 Button component"></a>範例：寫出一個 Button component</h3><p>舉例來說，在之前 Todo List 以 function  寫一個 Button component：</p>
<pre><code class="javascript=">function Button(&#123; onClick, children &#125;) &#123;
  return &lt;button onClick=&#123;onClick&#125;&gt;&#123;children&#125;&lt;/button&gt;;
&#125;

function App() &#123;
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;Button onClick=&#123;handleButtonClick&#125;&gt;Add Todo&lt;/Button&gt;
    // 以下略
&#125;</code></pre>
<p>換成 class component 的寫法如下，兩者的功能其實相同：</p>
<pre><code class="javascript=">// 引入 React
import React from &quot;react&quot;;

class Button extends React.Component &#123;
  render() &#123;
  // 用 this.props 拿取這個 component 的 props
    const &#123; onClick, children &#125; = this.props;
    return &lt;button onClick=&#123;onClick&#125;&gt;&#123;children&#125;&lt;/button&gt;;
  &#125;
&#125;</code></pre>
<h3 id="範例：改寫-TodoItem-component"><a href="#範例：改寫-TodoItem-component" class="headerlink" title="範例：改寫 TodoItem component"></a>範例：改寫 TodoItem component</h3><p>或是改寫之前用 function 寫的 TodoItem：</p>
<pre><code class="javascript=">export default function TodoItem(&#123;
  todo,
  handleDeleteTodo,
  handleToggleIsDone,
&#125;) &#123;
  const handleToggleClick = () =&gt; &#123;
    handleToggleIsDone(todo.id);
  &#125;;

  const handleDeleteClick = () =&gt; &#123;
    handleDeleteTodo(todo.id);
  &#125;;

  return (
    &lt;TodoItemWrapper data-todo-id=&#123;todo.id&#125;&gt;
      &lt;TodoContent $isDone=&#123;todo.isDone&#125;&gt;&#123;todo.content&#125;&lt;/TodoContent&gt;
      &lt;TodoButtonWrapper&gt;
        &lt;Button onClick=&#123;handleToggleClick&#125;&gt;
          &#123;todo.isDone &amp;&amp; &quot;已完成&quot;&#125;
          &#123;!todo.isDone &amp;&amp; &quot;未完成&quot;&#125;
        &lt;/Button&gt;
        &lt;RedButton onClick=&#123;handleDeleteClick&#125;&gt;刪除&lt;/RedButton&gt;
      &lt;/TodoButtonWrapper&gt;
    &lt;/TodoItemWrapper&gt;
  );
&#125;</code></pre>
<p>以 class component 改寫如下，但這樣寫其實會出現錯誤訊息，this 的值會是 undefined：</p>
<pre><code class="javascript=">export default class TodoItemC  extends React.Component &#123;
  // 變成 component 的 method (也可用 inline function 的寫法)
  handleToggleClick() &#123;
    const &#123; handleToggleIsDone, todo &#125; = this.props;
    handleToggleIsDone(todo.id);
  &#125;
  handleDeleteClick() &#123;
    const &#123; handleDeleteTodo, todo &#125; = this.props;
    handleDeleteTodo(todo.id);
  &#125;

  render() &#123;
    const &#123; todo &#125; = this.props;
    return (
      &lt;TodoItemWrapper data-todo-id=&#123;todo.id&#125;&gt;
        &lt;TodoContent $isDone=&#123;todo.isDone&#125;&gt;&#123;todo.content&#125;&lt;/TodoContent&gt;
        &lt;TodoButtonWrapper&gt;
          &lt;Button onClick=&#123;handleToggleClick&#125;&gt;
            &#123;todo.isDone ? &quot;已完成&quot; : &quot;未完成&quot;&#125;
          &lt;/Button&gt;
          &lt;RedButton onClick=&#123;handleDeleteClick&#125;&gt;刪除&lt;/RedButton&gt;
        &lt;/TodoButtonWrapper&gt;
      &lt;/TodoItemWrapper&gt;
    );
  &#125;
&#125;</code></pre>
<p>這是因為 this 的值會根據怎麼呼叫 function 決定，在嚴格模式中直接呼叫 onClick 的話 this 的值就會是 undefined：</p>
<p><img src="https://i.imgur.com/ZQOcT1O.png"></p>
<p>有兩種解決方式：</p>
<ul>
<li>透過 cunstructor 初始化 props 並綁定 this 指向</li>
<li>改成 classmethod 綁定 this 指向</li>
</ul>
<h4 id="透過-cunstructor-初始化-props-並綁定-this-指向"><a href="#透過-cunstructor-初始化-props-並綁定-this-指向" class="headerlink" title="透過 cunstructor 初始化 props 並綁定 this 指向"></a>透過 cunstructor 初始化 props 並綁定 this 指向</h4><p>透過 constructor，將 props 初始化，在利用 bind 來綁定 this 指向 constructor 裡面的 this，也就是 TodoItemC 這個 component：</p>
<pre><code class="javascript=">export default class TodoItemC extends React.Component &#123;
  constructor(props) &#123;
    // 初始化 props
    super(props);

    // 利用 bind 將 this 固定指向現在 constructor 裡面的 this
    this.handleToggleClick = this.handleToggleClick.bind(this);
    this.handleDeleteClick = this.handleDeleteClick.bind(this);
  &#125;

  // 變成 component 的 method (也可用 inline function 的寫法)
  handleToggleClick() &#123;
    const &#123; handleToggleIsDone, todo &#125; = this.props;
    handleToggleIsDone(todo.id);
  &#125;
  handleDeleteClick() &#123;
    const &#123; handleDeleteTodo, todo &#125; = this.props;
    handleDeleteTodo(todo.id);
  &#125;

  render() &#123;
    const &#123; todo &#125; = this.props;
    return (
      &lt;TodoItemWrapper data-todo-id=&#123;todo.id&#125;&gt;
        &lt;TodoContent $isDone=&#123;todo.isDone&#125;&gt;&#123;todo.content&#125;&lt;/TodoContent&gt;
        &lt;TodoButtonWrapper&gt;
          // 這裡要加上 this 使用
          &lt;Button onClick=&#123;this.handleToggleClick&#125;&gt;
            &#123;todo.isDone ? &quot;已完成&quot; : &quot;未完成&quot;&#125;
          &lt;/Button&gt;
          &lt;RedButton onClick=&#123;this.handleDeleteClick&#125;&gt;刪除&lt;/RedButton&gt;
        &lt;/TodoButtonWrapper&gt;
      &lt;/TodoItemWrapper&gt;
    );
  &#125;
&#125;</code></pre>
<h4 id="改用-classmethod-綁定-this-指向"><a href="#改用-classmethod-綁定-this-指向" class="headerlink" title="改用 classmethod 綁定 this 指向"></a>改用 classmethod 綁定 this 指向</h4><p>另一種解決方法，就是改用 classmethod 寫法，類似箭頭函式，同樣能綁定 this：</p>
<pre><code class="javascript=">export default class TodoItemC extends React.Component &#123;
  handleToggleClick = () =&gt; &#123;
    const &#123; handleToggleIsDone, todo &#125; = this.props;
    handleToggleIsDone(todo.id);
  &#125;;
  handleDeleteClick = () =&gt; &#123;
    const &#123; handleDeleteTodo, todo &#125; = this.props;
    handleDeleteTodo(todo.id);
  &#125;;

// 以下略</code></pre>
<h3 id="Class-component-中的-state"><a href="#Class-component-中的-state" class="headerlink" title="Class component 中的 state"></a>Class component 中的 state</h3><p>在 Class Component 的 state 同樣要寫在 constructor 裡面，進行 props 初始化，以及設定初始 state：</p>
<pre><code class="javascript=">export default class TodoItemC extends React.Component &#123;
  constructor(props) &#123;
    // 初始化
    super(props);
    // 設定初始 state
    this.state = &#123;
      counter: 1,
    &#125;;
  &#125;
  handleToggleClick = () =&gt; &#123;
    const &#123; handleToggleIsDone, todo &#125; = this.props;
    handleToggleIsDone(todo.id);
    // 設定 state
    this.setState = &#123;
      counter: this.state.counter + 1,
    &#125;;
  &#125;;</code></pre>
<h2 id="Class-component-的生命週期"><a href="#Class-component-的生命週期" class="headerlink" title="Class component 的生命週期"></a>Class component 的生命週期</h2><p>關於 class component 的生命週期架構可參考附圖：</p>
<p><img src="https://i.imgur.com/CV4MKmC.png"><br>（圖片來源：<span class="exturl" data-url="aHR0cHM6Ly9wcm9qZWN0cy53b2p0ZWttYWoucGwvcmVhY3QtbGlmZWN5Y2xlLW1ldGhvZHMtZGlhZ3JhbS8=">React LifeCycle Methods Diagram<i class="fa fa-external-link-alt"></i></span>）</p>
<p>可和之前提過的 React Hook 流程圖進行對照，改成用 useEffect 執行：</p>
<p><img src="https://i.imgur.com/iY123nV.png"><br>（圖片來源：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvbmF2b24vaG9vay1mbG93JUVGJUJDJTg5">https://github.com/donavon/hook-flow）<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="實作一個-Counter-component"><a href="#實作一個-Counter-component" class="headerlink" title="實作一個 Counter component"></a>實作一個 Counter component</h3><p>這裡重新建立一個 Counter.js 作為範例，首先將 index.js 改成引入 Counter：</p>
<pre><code class="javascript=">import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
import Counter from &quot;./Counter&quot;;

ReactDOM.render(&lt;Counter /&gt;, document.getElementById(&quot;root&quot;));</code></pre>
<p>建立 Counter.js：</p>
<pre><code class="javascript=">import React from &quot;react&quot;;

export default class Counter extends React.Component &#123;
  constructor(props) &#123;
    // 初始化
    super(props);
    this.state = &#123;
      counter: 1,
    &#125;;
  &#125;

  handleClick = () =&gt; &#123;
    this.setState(&#123;
      counter: this.state.counter + 1,
    &#125;);
  &#125;;

  render() &#123;
    const &#123; counter &#125; = this.state;
    return (
      &lt;div&gt;
        &lt;button onClick=&#123;this.handleClick&#125;&gt;+1&lt;/button&gt;
        counter: &#123;counter&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;</code></pre>
<p>結果如下，藉由點擊事件來改變 component 狀態：</p>
<iframe src="https://codesandbox.io/embed/reactclass-component-life-cycle-1-yhws5?fontsize=14&hidenavigation=1&theme=dark"
     style="width:80%; height:200px; border:0; border-radius: 4px; overflow:hidden;"
     title="React_class component_ life cycle-1"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

<h3 id="Test-component-amp-內建-method"><a href="#Test-component-amp-內建-method" class="headerlink" title="Test component &amp; 內建 method"></a>Test component &amp; 內建 method</h3><p>加上 Test component，並設定只有在 count 等於 1 時會出現 Test，以及使用 React 內建 method 來觀察 component 的生命週期：</p>
<ul>
<li>componentDidMount：會在 component mount 之後執行</li>
<li>componentDidUpdate：會在 component update 之後執行</li>
<li>componentWillUnmount：會在 component unmount 之前執行</li>
</ul>
<pre><code>class Test extends React.Component &#123;
  componentDidMount() &#123;
    console.log(&quot;test mount&quot;);
  &#125;
  componentWillUnmount() &#123;
    console.log(&quot;test unmount&quot;);
  &#125;
  render() &#123;
    return &lt;div&gt;test!&lt;/div&gt;;
  &#125;
&#125;

export default class Counter extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123;
      counter: 1,
    &#125;;
    console.log(&quot;constructor&quot;);
  &#125;
  // 使用 react 內建的 method, this 會指向這個 component
  componentDidMount() &#123;
    // 會在 component mount 之後執行
    console.log(&quot;did mount&quot;, this.state);
  &#125;
  // 拿到上一次的參數: prevProps 和 prevState
  componentDidUpdate(prevProps, prevState) &#123;
    // 會在 component update 之後執行
    console.log(&quot;prevState&quot;, prevState);
    console.log(&quot;update!&quot;);
  &#125;
  componentWillUnmount() &#123;
    // 會在 component unmount 之前執行
    console.log(&quot;unmount&quot;);
  &#125;

  handleClick = () =&gt; &#123;
    this.setState(&#123;
      counter: this.state.counter + 1,
    &#125;);
  &#125;;

  render() &#123;
    const &#123; counter &#125; = this.state;
    console.log(&quot;render&quot;);
    return (
      &lt;div&gt;
        &lt;button onClick=&#123;this.handleClick&#125;&gt;+1&lt;/button&gt;
        counter: &#123;counter&#125;
        &#123;counter === 1 &amp;&amp; &lt;Test /&gt;&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;</code></pre>
<p>結果如下：</p>
<iframe src="https://codesandbox.io/embed/reactclass-component-life-cycle-2-ikftq?fontsize=14&hidenavigation=1&theme=dark"
     style="width:80%; height:200px; border:0; border-radius: 4px; overflow:hidden;"
     title="React_class component_ life cycle-2"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>


<p>第一次渲染畫面，只有第一次會有 constructor 和 mount：</p>
<p><img src="https://i.imgur.com/iG3pxlB.png"></p>
<p>點擊第一次，第二次渲染畫面，count 不等於 1，test unmount：</p>
<p><img src="https://i.imgur.com/RLdOBft.png"></p>
<p>點擊第二次，第三次渲染畫面：</p>
<p><img src="https://i.imgur.com/r6zc3yw.png"></p>
<h3 id="其他少見的-method"><a href="#其他少見的-method" class="headerlink" title="其他少見的 method"></a>其他少見的 method</h3><p>輸入 component 會發現有些 method 被畫刪除線，代表目前版本不建議使用：</p>
<p><img src="https://i.imgur.com/xWDgAL8.png"></p>
<ul>
<li>componentDidCatch：進行錯誤處理</li>
<li>shouldComponentUpdate：決定要不要 update，也可透過傳入的參數決定要不要 update，詳細可參考<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvcmVhY3QtY29tcG9uZW50Lmh0bWw=">官方文件<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>舉例來說，在 Counter component 加入這段，若 return false 就不會進行 update；反之 return true 就會：</p>
<pre><code class="javascript=">  shouldComponentUpdate(nextProps, nextState) &#123;
    return false;
  &#125;</code></pre>
<p>以下舉個簡單範例：</p>
<pre><code class="javascript=">  shouldComponentUpdate(nextProps, nextState) &#123;
    // 當 counter &gt; 5 時，就不會再 update
    if (nextState.counter &gt; 5) return false;
    return true;
  &#125;</code></pre>
<p>結果如下，當 counter: 5 之後，再點擊也不會有反應：</p>
<p><img src="https://i.imgur.com/XrScAIB.png"></p>
<p>這通常會和之前在 React 效能優化提到的 memo 搭配使用，根據比對 props 是否相同或自訂條件。</p>
<p>另一個方法，是把 Component 改寫成 PureComponent，和 memo 的效果類似：</p>
<pre><code class="javascript=">export default class Counter extends React.PureComponent</code></pre>
<p>React 會自動進行優化，加上 shouldComponentUpdate 判斷，當 props 裡面的屬性有變動時才會進行 update，沒有的話就不進行 re-render。</p>
<p>–</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>在實作 React 時，會瞭解到 class component 和 function component 用不同方式去思考如何建立 component，背後的概念其實差蠻多的，需要轉變成另一種想法。</p>
<p>最後再簡單記錄 class component 和 function component 兩者之間的差異：</p>
<h3 id="class-component"><a href="#class-component" class="headerlink" title="class component"></a>class component</h3><ul>
<li>透過 ES6 語法來實作物件導向的 class component</li>
<li>由於 this 指向的關係，state 和 props 會拿到最新的結果，但是會較不易於進行 callback 操作</li>
<li>提供許多 lifecycle method 使用，方便管理較複雜的 component 狀態</li>
</ul>
<h3 id="function-component"><a href="#function-component" class="headerlink" title="function component"></a>function component</h3><ul>
<li>透過閉包的形式來管理狀態的 function component</li>
<li>把許多 method 都寫在 function 中，自己本身就像是 render function，較容易抽出共同邏輯，或是進行模組化測試</li>
<li>生命週期的方法，是以 useEffect 來決定 render 要做的事情</li>
</ul>
<p>參考文章：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9wamNoZW5kZXIuZ2l0aHViLmlvLzIwMTgvMDgvMjkvcmVhY3QtJUU3JTk0JTlGJUU1JTkxJUJEJUU5JTgwJUIxJUU2JTlDJTlGJUVGJUJDJTg4bGlmZS1jeWNsZSVFRiVCQyU4OS8=">[React] 生命週期（life cycle）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 21] 初探 React：Component、JSX 語法、props 與 state 的不同</title>
    <url>/react-jsx-props/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUzMDItcmVhY3QtaG9va3M=">[FE302] React 基礎 - hooks 版本<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<pre><code>學習目標：

 P1 我知道 React 的目的以及原理
 P1 我知道我們為什麼需要 React
 P1 我知道使用 React 跟之前使用 jQuery 的區別
 P1 我理解 state 跟 props 的不同</code></pre>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="React-版本差異"><a href="#React-版本差異" class="headerlink" title="React 版本差異"></a>React 版本差異</h3><p>關於 React 發展歷史，其實起源於 2013 年由 Facebook 開源出來的一個 Library，直到 2015 年更新到 v15 版本後又為更多人使用。</p>
<p>而 React 16.8.0 則是第一個支援 Hook 的版本，這部分我們之後會再提到。到 2020 年 10 月出現 React v17，課程將以此版本為主，和 v16 基本上沒有太大的差異。</p>
<h3 id="React-中一定會用到的-ES6-語法"><a href="#React-中一定會用到的-ES6-語法" class="headerlink" title="React 中一定會用到的 ES6 語法"></a>React 中一定會用到的 ES6 語法</h3><p>在開始之前，可以先複習這篇：<span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIxNzA4NQ==">React 中一定會用到的 JavaScript 語法<i class="fa fa-external-link-alt"></i></span>，主要包括下列幾個重點：</p>
<ul>
<li>樣板字面值（Template literals／Template strings）</li>
<li>箭頭函式（arrow functions）</li>
<li>物件屬性名稱縮寫（Shorthand property names）</li>
<li>解構賦值（Destructuring assignment）</li>
<li>展開語法（spread syntax）</li>
<li>其餘語法（rest syntax）</li>
</ul>
<p>可事先具備這些知識，或到時候再搭配 MDN 查詢用法，因為這些是之後實作 React 時一定會碰到的語法。</p>
<hr>
<h2 id="React：JavaScript-函式庫"><a href="#React：JavaScript-函式庫" class="headerlink" title="React：JavaScript 函式庫"></a>React：JavaScript 函式庫</h2><p>我們經常會聽到前端三大框架：React、Vue、Angular，但根據 <span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnLw==">React<i class="fa fa-external-link-alt"></i></span> 官網定義：</p>
<blockquote>
<p>React: A JavaScript library for building user interfaces</p>
</blockquote>
<p>嚴格來說，React 其實不算是一個框架，而是一個 JavaScript Libaray。通常使用 React 時會搭配其他 Libaray 使用，整個生態系結合起來就會和框架差不多。</p>
<h3 id="為什麼我們需要-React？"><a href="#為什麼我們需要-React？" class="headerlink" title="為什麼我們需要 React？"></a>為什麼我們需要 React？</h3><p>我們可以從「React 提供了哪些功能」的角度來思考這個問題。</p>
<p>之所以會有 React 的誕生，可從原有的 JavaScript MVC 架構談起：Facebook 認為 MVC 模式已無法滿足擴展需求，隨著應用規模增加，系統的複雜度會成級數成長，增加開發難度以及不易進行後續維護。</p>
<p>因此開源出 React 這個 JavaScript Library，負責處理 MVC 的 View（介面）部分，解決思路就是「當狀態改變時，直接重新渲染畫面」，引入 Virtual DOM 的概念，透過 DOM Diff 演算法算出實際需要更新的部分，有效減少渲染次數以提高效能。</p>
<p>瞭解到 React 的發展過程之後，再回到「為什麼我們需要 React？」這個問題，React 的核心概念如下：</p>
<ul>
<li>Component 元件化<ul>
<li>開發 React 很重要的一點，就是去思考在頁面有哪些重複性高或相似的 Element，再透過 JSX 語法將這些 Element 建立成一個 Component</li>
<li>讓每個 Components 擁有重複性及可擴充性，以模組化的方式進行開發</li>
</ul>
</li>
<li>JSX 語法<ul>
<li>透過 JSX 語法，即可將 HTML 語法轉成 JavaScript 的形式，讓我們用來建立 React elements</li>
</ul>
</li>
<li>Virtual DOM<ul>
<li>因為操作 DOM 這件事，其實會耗費很大的成本；而 React 背後運行機制，就是透過比對 Virtual DOM 來避免直接操作 DOM，藉此來提升效能</li>
<li>此外，因為建立 Virtual DOM 這一虛擬層，也讓我們能夠對程式碼進行更多操作</li>
</ul>
</li>
<li>Hooks API<ul>
<li>hook 其實就是 function，讓我們可以在 function component 中管理狀態和使用生命周期等功能，藉此簡化程式碼與提高重用性</li>
</ul>
</li>
</ul>
<h3 id="可以不用-React-嗎？"><a href="#可以不用-React-嗎？" class="headerlink" title="可以不用 React 嗎？"></a>可以不用 React 嗎？</h3><p>由於 React 中，強調「模組化」的概念，如果是實作一個靜態網頁，或是專案規模較小、沒有模組化需求時，直接使用 HTML、CSS、JavaScript 等進行開發會更方便省時。</p>
<p>因此，並不是所有專案都適合用 React 進行開發，應該根據網站需求去決定合適的工具。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZm9vaXNoLmNvbS9yZWFjdGpzLw==">React 教學 - React JavaScript UI Library<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="初探-React"><a href="#初探-React" class="headerlink" title="初探 React"></a>初探 React</h2><p>在開始前可先透過 <span class="exturl" data-url="aHR0cHM6Ly9jb2Rlc2FuZGJveC5pby8=">CodeSandbox<i class="fa fa-external-link-alt"></i></span> 進行練習，這是一個支援前端框架開發線上編輯器（IDE），類似複雜版的 Codepen。</p>
<p>點選 Create Sandbox，並選擇 React 來快速建立開發環境：</p>
<p><img src="https://i.imgur.com/j6UFABA.png"></p>
<p>建立完成的初始畫面如下，藉由像這樣快速建立環境，也能用來幫助線上 debug：</p>
<p><img src="https://i.imgur.com/d5LQgbX.png"></p>
<h3 id="JSX：用來建立-React-元素"><a href="#JSX：用來建立-React-元素" class="headerlink" title="JSX：用來建立 React 元素"></a>JSX：用來建立 React 元素</h3><blockquote>
<p>簡單來說，JSX（JavaScript extension syntax）就是 HTML/XML + JavaScript。</p>
</blockquote>
<p>React 提供的 JSX 語法，是透過底層的 Babel 機制，將 HTML 語法轉成 JavaScript Function 的形式，讓我們能用來建立 React elements：</p>
<pre><code class="javascript=">const rootElement = document.getElementById(&quot;root&quot;);
ReactDOM.render(&lt;h2&gt;app&lt;/h2&gt;, rootElement
);</code></pre>
<p>以 mount Hello 這個 component 為例：</p>
<blockquote>
<p>mount：意思是把 component 放到畫面上</p>
</blockquote>
<pre><code class="javascript=">function Hello() &#123;
  // 在 Hello() 中 return 什麼，就會在畫面 render 出什麼
  return &lt;h1&gt;hello world!&lt;/h1&gt;
&#125;

const rootElement = document.getElementById(&quot;root&quot;);
ReactDOM.render(&lt;Hello /&gt;, rootElement
);</code></pre>
<p><img src="https://i.imgur.com/CapcKxx.png"></p>
<p>Hello() 這個 component 可以接收參數 props，寫在大括號中會被解讀 React 為 JavaScript 程式碼執行，例如 <code>&#123;JS code&#125;</code>：</p>
<pre><code class="javascript=">function Hello(props) &#123;
  return &lt;h1&gt;Hello, &#123;props.name&#125;!&lt;/h1&gt;
&#125;

const rootElement = document.getElementById(&quot;root&quot;);
ReactDOM.render(&lt;Hello name=&quot;Heidi&quot;/&gt;, rootElement
);</code></pre>
<h4 id="ES6-的解構寫法"><a href="#ES6-的解構寫法" class="headerlink" title="ES6 的解構寫法"></a>ES6 的解構寫法</h4><p>更常見的寫法，是把 props 參數改成 ES6 的解構寫法，也就是在大括號內傳入參數：</p>
<pre><code class="javascript=">function Hello(&#123;name&#125;) &#123;
  return &lt;h1&gt;Hello, &#123;name&#125;!&lt;/h1&gt;
&#125;</code></pre>
<h3 id="使用-JSX-語法需注意的地方"><a href="#使用-JSX-語法需注意的地方" class="headerlink" title="使用 JSX 語法需注意的地方"></a>使用 JSX 語法需注意的地方</h3><p>JSX 語法和 template engine 不同，在使用上沒有那麼自由，必須遵守幾點規則，以避免寫出不合法的 JSX ：</p>
<ul>
<li>沒有迴圈的概念</li>
<li>沒有 if-else 判斷式</li>
</ul>
<p>那麼該如何解決這種情況呢？以下有兩種解決方式，以及範例程式碼：</p>
<ul>
<li>透過三元運算子來進行判斷：適用於只有 ture/false 的情況</li>
</ul>
<pre><code class="javascript=">&#123;todo.isDone ? &#39;已完成&#39; : &#39;未完成&#39;&#125;</code></pre>
<ul>
<li>透過邏輯運算子 &amp;&amp; 的短路行為：適用於多種可能的情況</li>
</ul>
<pre><code class="javascript=">&#123;todo.isDone &amp;&amp; &#39;已完成&#39;&#125;
&#123;!todo.isDone &amp;&amp; &#39;未完成&#39;&#125;</code></pre>
<h3 id="JSX-特性：自動-escape"><a href="#JSX-特性：自動-escape" class="headerlink" title="JSX 特性：自動 escape"></a>JSX 特性：自動 escape</h3><p>此外，根據<span class="exturl" data-url="aHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2ludHJvZHVjaW5nLWpzeC5odG1sI2pzeC1wcmV2ZW50cy1pbmplY3Rpb24tYXR0YWNrcw==">官方文件<i class="fa fa-external-link-alt"></i></span>，JSX 語法能夠預防 Injection Attacks，提供 escape 功能。</p>
<p><img src="https://i.imgur.com/eRabFE4.png"></p>
<p>如果真的想要 render 出 innerHTML，則需透過 <span class="exturl" data-url="aHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2RvbS1lbGVtZW50cy5odG1sI2Rhbmdlcm91c2x5c2V0aW5uZXJodG1s">dangerouslysetinnerhtml<i class="fa fa-external-link-alt"></i></span> 這個冗長的標籤，一般而言不會使用這個方法。</p>
<p>但需要注意，如果在 a 連結標間中，有使用者輸入的區塊，例如：</p>
<pre><code class="javascript=">&lt;a href=&#123;todo.content&#125;&gt;click me!&lt;/a&gt;</code></pre>
<p>這時若被惡意輸入 <code>javascript:alert()</code> 程式碼，點擊 a 連結就會執行該 JS 程式碼。這其實因為 React 沒有跳脫冒號，造成的 click based XSS：</p>
<p><img src="https://i.imgur.com/bnbqnMb.png"></p>
<p>防範方式有兩種：</p>
<ul>
<li>不要在 a 標籤內放入使用者輸入</li>
<li>加上 encodeURIComponent() 語法，把字串轉化成 escape 格式的字符串</li>
</ul>
<pre><code class="javascript="> &lt;a href=&#123;window.encodeURIComponent(todo.content)&#125;&gt;click me!&lt;/a&gt;</code></pre>
<h3 id="常見的-component：Counter"><a href="#常見的-component：Counter" class="headerlink" title="常見的 component：Counter"></a>常見的 component：Counter</h3><p>最後再以常見的 Counter component 為例：</p>
<pre><code class="javascript=">function Counter() &#123;
  // useState() 會建立一個陣列 state, 傳入參數為初始值
  const [value, setValue] = React.useState(1);
  function handleClick() &#123;
    // 透過呼叫 setValue() 來更動 state
    setValue(value + 1);
  &#125;
  // 建立 onClick 監聽事件
  return &lt;button onClick=&#123;handleClick&#125;&gt;&#123;value&#125;&lt;/button&gt;;
&#125;

const rootElement = document.getElementById(&quot;root&quot;);
ReactDOM.render(
&lt;Counter /&gt;, rootElement
);</code></pre>
<p>透過點擊 button 觸發事件來改變 state，React 再根據 state 內容來 render 出畫面：</p>
<iframe src="https://codesandbox.io/embed/chutan-react-n4z9g?fontsize=14&hidenavigation=1&theme=dark"
     style="width:80%; height:200px; border:0; border-radius: 4px; overflow:hidden;"
     title="初探 React"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

<hr>
<h2 id="React-的思考模式跟以前的思考模式有什麼不一樣？"><a href="#React-的思考模式跟以前的思考模式有什麼不一樣？" class="headerlink" title="React 的思考模式跟以前的思考模式有什麼不一樣？"></a>React 的思考模式跟以前的思考模式有什麼不一樣？</h2><p>React 最大的不同，在於多了 Component 和 State 這兩個概念。</p>
<h3 id="Component-元件"><a href="#Component-元件" class="headerlink" title="Component 元件"></a>Component 元件</h3><p>這和以往的思考模式其實很不一樣，像是在切好的 UI 畫面上，將每個 element 新增各種功能；或是以 MVC 架構進行開發。</p>
<p>而在 React 中，一個元件（component）是 React 的最小單位，再透過 Props 來設定屬性或資料。由於所有東西或介面都是由元件所組成，強調的是 UI 元件的封裝性、共用性及擴展性。</p>
<h3 id="React-State"><a href="#React-State" class="headerlink" title="React State"></a>React State</h3><p>在 React 是「透過資料的狀態，決定是否重新渲染畫面」，這和以往直接更改操作 DOM 元素不同；而是以類似間接的方式，透過 React 演算法比對 Virtual DOM 來決定是否更新真實 DOM。</p>
<p>也就是說，Component 是透過資料狀態，來決定是否更新 UI 畫面，而 Component 中有兩種資料來源：</p>
<ol>
<li>外部傳進 Component 的 Props</li>
<li>Component 內部的 State</li>
</ol>
<p>每當 React 偵測到 Props 或 State 有改變時，就會自動重新渲染。</p>
<p>剛開始對這種以 Component 和 State 為核心概念的寫法很不習慣，但卻也有點熟悉的感覺，就像以前在實作前後端分離的留言板或 Todo List 時很像。可能也因為 function component，又和透過功能區分的模組化很類似，但需要考慮到該如何更改 State 來呈現畫面。</p>
<hr>
<h2 id="State-跟-Props-的差別在哪裡？"><a href="#State-跟-Props-的差別在哪裡？" class="headerlink" title="State 跟 Props 的差別在哪裡？"></a>State 跟 Props 的差別在哪裡？</h2><p>State 和 Props 都是 JavaScript 物件，我們在前面有提到，當這兩者之一有改變時，會觸發 React 重新渲染畫面。兩者差別在於：</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><ul>
<li>在 Component 內部被管理，類似於 function 中的宣告變數</li>
<li>是 Component 本身的狀態，只有該 Component 能透過 setState 變更 state，這部分我們會在之後的 Hooks 詳細介紹</li>
</ul>
<h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><ul>
<li>從外部傳進 Component，類似於 function 的參數</li>
<li>由於 React 單向資料流的特性，Props 是父層由上往下傳遞給子層</li>
<li>Props 不能被接收的子層修改，但也可能是父層的 State，可透過 setState 進行變更，再把更新的 State 值做為新的 Props 傳遞給子層</li>
</ul>
<h3 id="包在標籤中間的-props：children"><a href="#包在標籤中間的-props：children" class="headerlink" title="包在標籤中間的 props：children"></a>包在標籤中間的 props：children</h3><p>在 React component 中，包在標籤中間的東西，稱為 children，children 也是一個 props。</p>
<p>以 Todoitem 為例，這裡的 children 指的就是 <code>Watch a movie</code>：</p>
<pre><code class="javascript=">function Todoitem(&#123;n, children&#125;) &#123;
  return &lt;h1&gt;Todo &#123;n&#125;: &#123;children&#125;&lt;/h1&gt;
&#125;

const rootElement = document.getElementById(&quot;root&quot;);
ReactDOM.render(
&lt;Todoitem n=&#123;1&#125;&gt;
  Watch a movie
&lt;/Todoitem&gt;, rootElement
);</code></pre>
<p><img src="https://i.imgur.com/gX8yUJ5.png"></p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZm9vaXNoLmNvbS9yZWFjdGpzL3N0YXRlLmh0bWw=">React State - React 教學Tutorial - Fooish 程式技術<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDE4NTA5NQ==">React Day5 - state 與 setState<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIxMDIyMQ==">React的props與state<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIwMDY0MA==">【DAY 04】React！說，Props是誰啊？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIxNDQ5NQ==">【Day 6】Child Component &amp;&amp; Props<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="環境建置：create-react-app"><a href="#環境建置：create-react-app" class="headerlink" title="環境建置：create-react-app"></a>環境建置：create-react-app</h2><p>React 環境建置可分為兩種：</p>
<ul>
<li>自己從頭開始做<ul>
<li>使用 React + Webpack 打包 + Bable 編譯 + Webpack Dev Server</li>
</ul>
</li>
<li>使用現成的套件<ul>
<li>create-react-app，由 React 官方提供</li>
</ul>
</li>
</ul>
<p>這裡會以現成的程式來做示範，詳細說明可參考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHA=">facebook/create-react-app<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="安裝指令"><a href="#安裝指令" class="headerlink" title="安裝指令"></a>安裝指令</h3><p>依照下方指令安裝相關套件並啟動：</p>
<pre><code>$ npx create-react-app my-app
$ cd my-app
$ npm start</code></pre>
<p>成功運行後，就會在 localhost 開一個 server：</p>
<p><img src="https://i.imgur.com/K7dEnLz.png"></p>
<p>在開始專案之前，首先要閱讀 <code>README.md</code> 的說明，還有查看 <code>package.json</code> 確認安裝了哪些套件等訊息。</p>
<p>再來是 src\index.js 檔案，和我們在 CodeSandbox 看到的內容非常類似：</p>
<pre><code class="javascript=">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import &#39;./index.css&#39;;
import App from &#39;./App&#39;;
// 與資料收集、效能有關
import reportWebVitals from &#39;./reportWebVitals&#39;;

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById(&#39;root&#39;)
);

reportWebVitals();</code></pre>
<ul>
<li><code>React.StrictMode</code>：代表<span class="exturl" data-url="aHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3N0cmljdC1tb2RlLmh0bWwjaWRlbnRpZnlpbmctdW5zYWZlLWxpZmVjeWNsZXM=">嚴格模式<i class="fa fa-external-link-alt"></i></span>中，會像 ESLint 進行檢查與警告，但有時為了偵測，可能會呼叫兩次，造成和想像中不同的結果，因此建議不加上</li>
<li><code>&lt;App /&gt;</code>：render 出 App conponent，也就是 render 的畫面</li>
</ul>
<p>可在 src\App.js 檔案，修改要 render 的畫面：</p>
<pre><code class="javascript=">function App() &#123;
  return (
    &lt;div className=&quot;App&quot;&gt;
      Hello World!
    &lt;/div&gt;
  );
&#125;

export default App;</code></pre>
<p>重整頁面即可看到結果：</p>
<p><img src="https://i.imgur.com/HPUh5ly.png"></p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>到這裡我們瞭解 React 重要的概念 Component，以及如何使用 JSX 語法來建立 React 元素。</p>
<p>此外，除了可以利用線上編輯器 CodeSandbox，也可以在本地端安裝官方提供的 create-react-app 套件，來快速建置 React 開發環境。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 22] React：用 SPA 架構實作一個部落格（四）- 優化篇</title>
    <url>/react-optimization/</url>
    <content><![CDATA[<p>在完成部落格的基本功能之後，再來要進行優化的部分，也就是解決畫面閃爍的問題。</p>
<p><a href="https://heidiliu2020.github.io/react-blog-test/#/">部落格 DEMO</a></p>
<a id="more"></a>
<h2 id="一、處理登入狀態的畫面閃爍"><a href="#一、處理登入狀態的畫面閃爍" class="headerlink" title="一、處理登入狀態的畫面閃爍"></a>一、處理登入狀態的畫面閃爍</h2><p>在 <span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWZlMzAyLXJlYWN0LWJsb2ctbG9naW4=">[week 22] React：用 SPA 架構實作一個部落格（二）- 身分驗證<i class="fa fa-external-link-alt"></i></span> 這篇筆記中，有提到登入狀態時，重整頁面會出現畫面閃爍的問題，之所以會有這個現象，是因為畫面進行了兩次 render：</p>
<ul>
<li>預設為登出狀態（第一次 render）</li>
<li>當我們發 API 確認有登入之後，才會顯示登入狀態（第二次 render）</li>
</ul>
<p>為了解決這個問題，就是在「確認是否登入之前，不要顯示和登入登出狀態有關的東西」。</p>
<h3 id="App-js：設定-isLoadingGetMe-狀態"><a href="#App-js：設定-isLoadingGetMe-狀態" class="headerlink" title="App.js：設定 isLoadingGetMe 狀態"></a>App.js：設定 isLoadingGetMe 狀態</h3><ul>
<li>App.js</li>
</ul>
<p>在 App.js 執行開始，就先設定一個 isLoadingGetMe，預設值為 true，也就是不顯示登入登出：</p>
<pre><code class="javascript=">const [isLoadingGetMe, setLoadingGetMe] = useState(true);</code></pre>
<p>一旦接收到 getMe() 回傳的 response 時，或是發現沒有 token 時，就會改成 false，顯示登入登出：</p>
<pre><code class="javascript=">import &#123; getMe &#125; from &quot;../../WebAPI&quot;;
import &#123; getAuthToken &#125; from &quot;../../utils&quot;;

useEffect(() =&gt; &#123;
  // 以 getAuthToken 從 localStorage 讀取 token
  if (getAuthToken()) &#123;
    // 有 token 才 call API
    getMe().then((response) =&gt; &#123;
      if (response.ok) &#123;
        setUser(response.data);
        setLoadingGetMe(false);
      &#125;
    &#125;);
  &#125; else &#123;
    setLoadingGetMe(false);
  &#125;
&#125;, []);</code></pre>
<p>並透過 Provider 將參數設為全域變數：</p>
<pre><code class="jsx=">import &#123; AuthContext, LoadingContext &#125; from &quot;../../contexts&quot;;

// ...

&lt;AuthContext.Provider value=&#123;&#123; user, setUser &#125;&#125;&gt;
  &lt;Root&gt;
     &lt;LoadingContext.Provider
        value=&#123;&#123; isLoading, setIsLoading, isLoadingGetMe &#125;&#125;
      &gt;

    //  ...   

    &lt;/LoadingContext.Provider&gt;
  &lt;/Root&gt;
&lt;/AuthContext.Provider&gt;</code></pre>
<h3 id="context-js：建立-context"><a href="#context-js：建立-context" class="headerlink" title="context.js：建立 context"></a>context.js：建立 context</h3><p>在 src/context.js 建立 context，初始值設為 null：</p>
<pre><code class="javascript=">import &#123; createContext &#125; from &quot;react&quot;;

// 初始值為 null
export const AuthContext = createContext(null);
export const LoadingContext = createContext(null);</code></pre>
<h3 id="Header-js：根據-isLoadingGetMe-顯示登入狀態"><a href="#Header-js：根據-isLoadingGetMe-顯示登入狀態" class="headerlink" title="Header.js：根據 isLoadingGetMe 顯示登入狀態"></a>Header.js：根據 isLoadingGetMe 顯示登入狀態</h3><p>首先從 context.js 引入參數，以及引入需要的 hooks：</p>
<pre><code class="javascript=">import React, &#123; useContext &#125; from &quot;react&quot;;
import &#123; Link, NavLink, useHistory, useLocation &#125; from &quot;react-router-dom&quot;;

import &#123; AuthContext, LoadingContext &#125; from &quot;../../contexts&quot;;
import &#123; setAuthToken &#125; from &quot;../../utils&quot;;</code></pre>
<p>接著就可以根據 isLoadingGetMe 以及 user 的布林值，決定如何顯示登入狀態：</p>
<pre><code class="javascript=">export default function Header() &#123;
  const &#123; isLoadingGetMe &#125; = useContext(LoadingContext);
  const &#123; user, setUser &#125; = useContext(AuthContext);
  const location = useLocation();

  // 登出功能
  const history = useHistory();
  const handleLogout = () =&gt; &#123;
    setAuthToken(&quot;&quot;);
    setUser(null);
    if (location.pathname !== &quot;/&quot;) &#123;
      history.push(&quot;/&quot;);
    &#125;
  &#125;;

  return (
    &lt;HeaderContainer&gt;
      &lt;Brand&gt;
        &lt;Link to=&quot;/&quot; replace&gt;
          React 部落格
        &lt;/Link&gt;
      &lt;/Brand&gt;
      &lt;NavbarList&gt;
        &lt;StyledLink exact to=&quot;/about&quot; replace activeClassName=&quot;active&quot;&gt;
          關於我
        &lt;/StyledLink&gt;
        &lt;StyledLink to=&quot;/post-list/&quot; replace activeClassName=&quot;active&quot;&gt;
          文章列表
        &lt;/StyledLink&gt;
        &#123;isLoadingGetMe ? (
          &lt;LoadingGetMe&gt;資料讀取中...&lt;/LoadingGetMe&gt;
        ) : (
          &lt;&gt;
            &#123;!user &amp;&amp; (
              &lt;StyledLink to=&quot;/register&quot; replace activeClassName=&quot;active&quot;&gt;
                註冊
              &lt;/StyledLink&gt;
            )&#125;
            &#123;!user &amp;&amp; (
              &lt;StyledLink to=&quot;/login&quot; replace activeClassName=&quot;active&quot;&gt;
                登入
              &lt;/StyledLink&gt;
            )&#125;
            &#123;user &amp;&amp; (
              &lt;StyledLink to=&quot;/new-post&quot; replace activeClassName=&quot;active&quot;&gt;
                發布文章
              &lt;/StyledLink&gt;
            )&#125;
            &#123;user &amp;&amp; (
              &lt;StyledLink to=&quot;&quot; replace onClick=&#123;handleLogout&#125;&gt;
                登出
              &lt;/StyledLink&gt;
            )&#125;
          &lt;/&gt;
        )&#125;
      &lt;/NavbarList&gt;
    &lt;/HeaderContainer&gt;
  );
&#125;</code></pre>
<p>重點在於 isLoadingGetMe  的判斷邏輯：</p>
<ul>
<li>如果 isLoadingGetMe 為 true，就不會顯示裡面和登入狀態有關的東西</li>
<li>當 isLoadingGetMe 為 faluse，才會再根據 user 是否為 true，決定要顯示「註冊、登入」還是「發布文章、登出」</li>
</ul>
<pre><code class="javascript=">        &#123;isLoadingGetMe ? (
          &lt;LoadingGetMe&gt;資料讀取中...&lt;/LoadingGetMe&gt;
        ) : (
          &lt;&gt;
            &#123;!user &amp;&amp; (
              &lt;StyledLink to=&quot;/register&quot; replace activeClassName=&quot;active&quot;&gt;
                註冊
              &lt;/StyledLink&gt;
            )&#125;
            &#123;!user &amp;&amp; (
              &lt;StyledLink to=&quot;/login&quot; replace activeClassName=&quot;active&quot;&gt;
                登入
              &lt;/StyledLink&gt;
            )&#125;
            &#123;user &amp;&amp; (
              &lt;StyledLink to=&quot;/new-post&quot; replace activeClassName=&quot;active&quot;&gt;
                發布文章
              &lt;/StyledLink&gt;
            )&#125;
            &#123;user &amp;&amp; (
              &lt;StyledLink to=&quot;&quot; replace onClick=&#123;handleLogout&#125;&gt;
                登出
              &lt;/StyledLink&gt;
            )&#125;
          &lt;/&gt;
        )&#125;</code></pre>
<hr>
<h2 id="二、處理呼叫-API-造成的畫面閃爍"><a href="#二、處理呼叫-API-造成的畫面閃爍" class="headerlink" title="二、處理呼叫 API 造成的畫面閃爍"></a>二、處理呼叫 API 造成的畫面閃爍</h2><p>當我們需要 call API 時，必須考慮到非同步的問題。舉例來說，當我們進入文章列表時，第一次 render 會先看到空的列表，第二次 render 才會出現文章。</p>
<p>為了解決這個問題，我們可以將第一次 render 改為 Loading 畫面，等到第二次 render 再顯示文章頁面。</p>
<p>那麼就開始吧！</p>
<h3 id="App-js：設定-isLoading-狀態"><a href="#App-js：設定-isLoading-狀態" class="headerlink" title="App.js：設定 isLoading 狀態"></a>App.js：設定 isLoading 狀態</h3><p>首先，同樣在 APP 執行時就先設第一個 isLoading 狀態，預設值為 false，當我們有進行 call API 的動作時才會設為 true：</p>
<pre><code class="javascript=">const [isLoading, setIsLoading] = useState(false);</code></pre>
<p>同樣透過 Provider 將參數設為全域變數：</p>
<pre><code class="jsx="> &lt;LoadingContext.Provider
    value=&#123;&#123; isLoading, setIsLoading, isLoadingGetMe &#125;&#125;&gt;
    // ...
&lt;/LoadingContext.Provider&gt;</code></pre>
<h3 id="PoseListPage-js：根據-isLoading-狀態顯示畫面"><a href="#PoseListPage-js：根據-isLoading-狀態顯示畫面" class="headerlink" title="PoseListPage.js：根據 isLoading 狀態顯示畫面"></a>PoseListPage.js：根據 isLoading 狀態顯示畫面</h3><p>接著引入 context，還有 isLoading 時要顯示的 Loading component：</p>
<pre><code class="javascript=">import React, &#123; useState, useEffect, useRef, useContext &#125; from &quot;react&quot;;
import &#123; LoadingContext, AuthContext &#125; from &quot;../../contexts&quot;;
import Loading from &quot;../../components/Loading&quot;;</code></pre>
<p>接著是根據 isLoading 狀態顯示畫面，在 call API 時會設為 true，直到接收 response 後會設為 false：</p>
<pre><code class="javascript=">export default function HomePage() &#123;
  const &#123; isLoading, setIsLoading &#125; = useContext(LoadingContext);
  const [posts, setPosts] = useState([]);

  useEffect(() =&gt; &#123;
    setIsLoading(true);
    getPosts()
      .then((posts) =&gt; setPosts(posts))
      .then(() =&gt; &#123;
        setIsLoading(false);
      &#125;);
  &#125;, [setIsLoading]);

  return (
    &lt;Root&gt;
      &#123;isLoading ? (
        &lt;Loading /&gt;
      ) : (
        &lt;PostsListContainer&gt;
          &lt;PostsListTitle&gt;最新文章&lt;/PostsListTitle&gt;
          &#123;posts &amp;&amp; posts.map((post) =&gt; &lt;PostList post=&#123;post&#125; key=&#123;post.id&#125; /&gt;)&#125;
          &lt;ReadMore&gt;
            &lt;Link to=&quot;/post-list&quot;&gt;查看更多&lt;/Link&gt;
          &lt;/ReadMore&gt;
        &lt;/PostsListContainer&gt;
      )&#125;
    &lt;/Root&gt;
  );
&#125;</code></pre>
<h2 id="三、透過-react-spinner-設定-loading-畫面"><a href="#三、透過-react-spinner-設定-loading-畫面" class="headerlink" title="三、透過 react-spinner 設定 loading 畫面"></a>三、透過 react-spinner 設定 loading 畫面</h2><blockquote>
<p>使用方法可參考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhdmlkaHUyMDAwL3JlYWN0LXNwaW5uZXJz">davidhu2000 / react-spinners<i class="fa fa-external-link-alt"></i></span> 介紹，以及樣式 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZGF2aWRodS5pby9yZWFjdC1zcGlubmVycy8=">DEMO<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h3><pre><code>npm install react-spinners --save</code></pre>
<h3 id="官方使用範例"><a href="#官方使用範例" class="headerlink" title="官方使用範例"></a>官方使用範例</h3><p>官方範例是用 class component 去寫的，但其實概念和 function component 沒有差太多，狀態就從 App.js 設定的 isLoading 去判斷即可：</p>
<pre><code class="javascript=">import React from &quot;react&quot;;
import &#123; css &#125; from &quot;@emotion/core&quot;;
import ClipLoader from &quot;react-spinners/ClipLoader&quot;;

// Can be a string as well. Need to ensure each key-value pair ends with ;
const override = css`
  display: block;
  margin: 0 auto;
  border-color: red;
`;

class AwesomeComponent extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123;
      loading: true
    &#125;;
  &#125;

  render() &#123;
    return (
      &lt;div className=&quot;sweet-loading&quot;&gt;
        &lt;ClipLoader
          css=&#123;override&#125;
          size=&#123;150&#125;
          color=&#123;&quot;#123abc&quot;&#125;
          loading=&#123;this.state.loading&#125;
        /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;</code></pre>
<ul>
<li>Loading.js</li>
</ul>
<p>改寫 Loading component 如下：</p>
<pre><code class="javascript=">import React from &quot;react&quot;;
import styled from &quot;styled-components&quot;;
// 要引用的樣式
import &#123; PuffLoader &#125; from &quot;react-spinners&quot;;

// 全版的半透明背景
const LoadingWapper = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
`;

export default function Loading() &#123;
  return (
    &lt;LoadingWapper&gt;
      &lt;PuffLoader size=&#123;60&#125; color=&#123;&quot;#4A90E2&quot;&#125; /&gt;
    &lt;/LoadingWapper&gt;
  );
&#125;</code></pre>
<p>效果如下：</p>
<p><img src="https://i.imgur.com/MNaWqI0.gif"></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>useEffect</tag>
        <tag>useState</tag>
        <tag>useContext</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 21] 補充：在 React 使用 PropTypes 進行型別檢查</title>
    <url>/react-proptypes/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUzMDItcmVhY3QtaG9va3M=">[FE302] React 基礎 - hooks 版本<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<p>之前介紹過 Prettier 和 eslint 這兩個前端工具，能夠分別檢查程式碼格式，以及檢查語法：</p>
<a id="more"></a>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLXByZXR0aWVy">[week 21] 補充：Prettier 套件 - 自動整理程式碼格式<i class="fa fa-external-link-alt"></i></span></li>
<li><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWVzbGludA==">[week 3] 設定 eslint：用來檢查語法的工具<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
<p>在 VSCode 可以針對錯誤進行快速修復，也可以選擇加入註解，忽略 eslint 的錯誤訊息：</p>
<p><img src="https://i.imgur.com/NPyX5Mj.png"></p>
<p>除此之外，React 有另一個能夠提升程式碼品質的功能，也就是透過 PropTypes 來驗證 Props 型態。</p>
<h2 id="利用-PropTypes-驗證-Props"><a href="#利用-PropTypes-驗證-Props" class="headerlink" title="利用 PropTypes 驗證 Props"></a>利用 PropTypes 驗證 Props</h2><blockquote>
<p>詳細可參考官方文件：<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvdHlwZWNoZWNraW5nLXdpdGgtcHJvcHR5cGVzLmh0bWw=">Typechecking With PropTypes<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>在使用前，需要先修改 eslint 規則，也就是在 react 專案新增 .eslintrc.json 檔案。</p>
<p>內容如下，或是參考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lhbm5pY2tjci9lc2xpbnQtcGx1Z2luLXJlYWN0">yannickcr/eslint-plugin-react<i class="fa fa-external-link-alt"></i></span>，意思是專案中的每個 component 都要加上 props，否則會出現警告訊息：</p>
<pre><code class="json=">&#123;
  &quot;extends&quot;: [&quot;react-app&quot;],
  &quot;rules&quot;: &#123;
    &quot;react/prop-types&quot;: &quot;warn&quot;
  &#125;
&#125;</code></pre>
<p>之後輸入 npm start 指令運行 React，就會在終端機介面看到警告訊息。</p>
<p>接下來會以 TodoItem component 作為範例。</p>
<h3 id="引入使用-ProtoTypes"><a href="#引入使用-ProtoTypes" class="headerlink" title="引入使用 ProtoTypes"></a>引入使用 ProtoTypes</h3><p>首先要在 TodoItem.js 引入使用 ProtoTypes：</p>
<pre><code class="javascript=">import PropTypes from &#39;prop-types&#39;;</code></pre>
<p>接著幫 TodoItem component 的 props 加上 PropTypes，注意 function 在這裡是縮寫 func：</p>
<pre><code class="javascript=">TodoItem.propTypes = &#123;
  todo: PropTypes.object,
  handleDeleteTodo: PropTypes.func,
  handleToggleIsDone: PropTypes.func,
&#125;;</code></pre>
<p>也可以將 object 寫得更詳細，描述物件中的 key-value 以及型別：</p>
<pre><code class="javascript=">TodoItem.propTypes = &#123;
  todo: PropTypes.shape(&#123;
    id: PropTypes.number,
    content: PropTypes.string,
    isDone: PropTypes.bool,
  &#125;),
  handleDeleteTodo: PropTypes.func,
  handleToggleIsDone: PropTypes.func,
&#125;;
</code></pre>
<p>加上 PropTypes 進行修改的好處在於：</p>
<ul>
<li>Console 不會再出現 warning</li>
<li>未來若有其他人接手專案時，能夠快速瀏覽這個 Component 有哪些參數，以及瞭解 PropTypes 型別</li>
<li>也能透過一些 Library 將 PropTypes 產生一份文件</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 21] React 基礎：style &amp; 如何撰寫 CSS</title>
    <url>/react-styled-component/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUzMDItcmVhY3QtaG9va3M=">[FE302] React 基礎 - hooks 版本<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="React-中的-style"><a href="#React-中的-style" class="headerlink" title="React 中的 style"></a>React 中的 style</h2><p>在 React 中有很多種方式可以寫 CSS，主要又可分為下列三種：</p>
<h3 id="一、inline-style-行內樣式"><a href="#一、inline-style-行內樣式" class="headerlink" title="一、inline-style 行內樣式"></a>一、inline-style 行內樣式</h3><p>直接在 HTML 標籤內加入 style 屬性，例如 <code>style=&#123;&#125;</code>，但需注意下列幾點：</p>
<ul>
<li>inline style 裡面放的是 object</li>
<li>只能傳入該元素支援的 inline style</li>
<li>而不能傳入偽元素或 hover</li>
<li>因為是 JavaScript 程式碼，需改為駝峰式命名</li>
</ul>
<pre><code class="javascript=">function Title(&#123; size &#125;) &#123;
  if (size === &#39;XL&#39;) &#123;
    return &lt;h1&gt;hello!&lt;/h1&gt;
  &#125;
  return(
    // 兩個大括號包住: JavaScript 程式碼 + 以物件形式
    &lt;h2 style=&#123;&#123;
      color: 'blue',
      // 需改為駝峰式命名
      textAlign: 'center'
    &#125;&#125;&gt;hello!&lt;/h2&gt;
  )
&#125;</code></pre>
<p>顯示結果：</p>
<p><img src="https://i.imgur.com/QGFGRwV.png"></p>
<h3 id="二、使用-webpack-打包"><a href="#二、使用-webpack-打包" class="headerlink" title="二、使用 webpack 打包"></a>二、使用 webpack 打包</h3><p>在標籤加上 className 屬性（因為 class 是保留字），會被瀏覽器渲染成 css 中的 class，再透過 webpack 打包來引入該 css 檔案：</p>
<pre><code class="javascript=">// 透過 webpack 來引入 css
import &#39;./App.css&#39;;

function App() &#123;
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;Title /&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<p>然後編輯 App.css 檔案：</p>
<pre><code class="css=">.App &#123;
  text-align: center;
  background: yellowgreen;
&#125;</code></pre>
<p>顯示結果：</p>
<p><img src="https://i.imgur.com/nBoFnXg.png"></p>
<h3 id="三、使用-styled-components-套件"><a href="#三、使用-styled-components-套件" class="headerlink" title="三、使用 styled-components 套件"></a>三、使用 styled-components 套件</h3><p>styled-components 是一個 library，也是目前的主流作法。用了 styled-components 套件之後，基本上就不需再直接寫 App.css 等檔案，之後會以此方法進行介紹。</p>
<p>首先安裝 <span class="exturl" data-url="aHR0cHM6Ly9zdHlsZWQtY29tcG9uZW50cy5jb20v">styled-components<i class="fa fa-external-link-alt"></i></span> 套件，然後運行程式：</p>
<pre><code>$ npm install --save styled-components
$ npm run start</code></pre>
<p>css 是透過標籤模板的寫法，在也就是在 “`” 反引號裡面寫入 css 樣式：</p>
<pre><code class="css">style.p`&lt;css code&gt;`</code></pre>
<p>修改 App.js 檔案，直接在 style 後面接元素名稱，並在反引號中寫入 css 程式碼：</p>
<pre><code class="javascript=">// 引入 styled-components 套件
import styled from &#39;styled-components&#39;;

const Description = styled.p`
  color: red;
  padding: 20px;
  bottom: 1px solid #000;
`

function App() &#123;
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;Title /&gt;
      &lt;Description&gt;  // =&gt; 編譯後會變成 &lt;p&gt;
        這是副標題
      &lt;/Description&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<p>可以想成 Description 就是有 style.p 的 component，而 React 會動態隨機產生 className，並加入設定好的 class：</p>
<p><img src="https://i.imgur.com/634Pzhw.png"></p>
<h3 id="以切出簡單的-TodoItem-為例"><a href="#以切出簡單的-TodoItem-為例" class="headerlink" title="以切出簡單的 TodoItem 為例"></a>以切出簡單的 TodoItem 為例</h3><p>根據上述範例，其實就是在 styled 後面寫 css 程式碼，因此也可寫成 Sass 語法：</p>
<pre><code class="javascript=">const TodoItemWrapper = styled.div`
  max-width: 80%;
  margin: 5px auto;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 16px;
  border: 1px solid #eee;
`
const TodoContent = styled.div`
  color: #000;
`

// 不用傳入任何東西，但仍需在最後加上反引號
const TodoButtonWrapper = styled.div``

const Button = styled.button`
  padding: 4px;
  color: #232332;
  // 也可使用 Sass 語法
  &amp;:hover &#123;
    color: red;
  &#125;
  &amp; + &amp; &#123;
    margin-left: 4px;
  &#125;
`

function App() &#123;
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;TodoItemWrapper&gt;
        &lt;TodoContent&gt;This is Todo&lt;/TodoContent&gt;
        &lt;TodoButtonWrapper&gt;
          &lt;Button&gt;未完成&lt;/Button&gt;
          &lt;Button&gt;刪除&lt;/Button&gt;
        &lt;/TodoButtonWrapper&gt;
      &lt;/TodoItemWrapper&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<p>結果如下：</p>
<p><img src="https://i.imgur.com/NTDXvq3.png"></p>
<p>通常會把模板 TodoItem 獨立寫成 component，改寫後如下：</p>
<pre><code class="javascript=">function TodoItem (&#123; size, content &#125;) &#123;
  return (
    &lt;TodoItemWrapper&gt;
      &lt;TodoContent size=&#123;size&#125;&gt;&#123;content&#125;&lt;/TodoContent&gt;
      &lt;TodoButtonWrapper&gt;
        &lt;Button&gt;未完成&lt;/Button&gt;
        &lt;Button&gt;刪除&lt;/Button&gt;
      &lt;/TodoButtonWrapper&gt;
    &lt;/TodoItemWrapper&gt;
  );
&#125;

function App() &#123;
  const titleSize = &quot;M&quot;
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;TodoItem content=&#123;123&#125; /&gt;
      &lt;TodoItem content=&#123;456&#125; size=&quot;XL&quot; /&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<p>也可以在 TodoContent 傳入參數 props，傳入參數的程式碼需寫在 <code>$&#123;...&#125;</code> 裡面，而在括號內的 css 程式碼則要用反引號包住：</p>
<pre><code class="javascript=">const TodoContent = styled.div`
  color: #000;
  font-size: 12px;
  $&#123;props =&gt; props.size === &#39;XL&#39; &amp;&amp; `
    font-size: 20px;
  `&#125;
`</code></pre>
<p>結果如下：</p>
<p><img src="https://i.imgur.com/P06HZye.png"></p>
<h2 id="styled-component-實戰"><a href="#styled-component-實戰" class="headerlink" title="styled component 實戰"></a>styled component 實戰</h2><p>有關 styled component 套件的詳細功能可參考<span class="exturl" data-url="aHR0cHM6Ly9zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9iYXNpY3M=">官方文件<i class="fa fa-external-link-alt"></i></span>，接著要舉一些常用語法作為範例。</p>
<h3 id="範例一：透過-styled-繼承樣式"><a href="#範例一：透過-styled-繼承樣式" class="headerlink" title="範例一：透過 styled() 繼承樣式"></a>範例一：透過 styled() 繼承樣式</h3><ul>
<li>如果是對 styled component 進行 restyle，裡面寫的 css 程式碼會蓋過原本的樣式：</li>
</ul>
<pre><code class="javascript=">// 繼承 Button 這個 styled component
const GreenButton = styled(Button)`
  background: green;
  color: #eee;
`

function TodoItem (&#123; size, content &#125;) &#123;
  return (
    &lt;TodoItemWrapper&gt;
      &lt;TodoContent size=&#123;size&#125;&gt;&#123;content&#125;&lt;/TodoContent&gt;
      &lt;TodoButtonWrapper&gt;
        &lt;Button&gt;未完成&lt;/Button&gt;
        &lt;GreenButton&gt;刪除&lt;/GreenButton&gt;
      &lt;/TodoButtonWrapper&gt;
    &lt;/TodoItemWrapper&gt;
  );
&#125;</code></pre>
<ul>
<li>如果是對一般的 component 進行 restyle，則需要在 component 傳入 className，用來接收 BlackTodoItem 這個 class 屬性：</li>
</ul>
<pre><code class="javascript=">// 繼承 TodoItem component，需要傳入 className
function TodoItem (&#123; className, size, content &#125;) &#123;
  return (
    &lt;TodoItemWrapper className=&#123;className&#125;&gt;
      &lt;TodoContent size=&#123;size&#125;&gt;&#123;content&#125;&lt;/TodoContent&gt;
      &lt;TodoButtonWrapper&gt;
        &lt;Button&gt;未完成&lt;/Button&gt;
        &lt;GreenButton&gt;刪除&lt;/GreenButton&gt;
      &lt;/TodoButtonWrapper&gt;
    &lt;/TodoItemWrapper&gt;
  );
&#125;
  // 繼承 TodoItem
  const BlackTodoItem = styled(TodoItem)`
    background: #000;
  `

function App() &#123;
  const titleSize = &quot;M&quot;
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;TodoItem content=&#123;123&#125; /&gt;
      &lt;BlackTodoItem content=&#123;456&#125; size=&quot;XL&quot; /&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
<p><img src="https://i.imgur.com/teWo6kl.png"></p>
<h3 id="範例二：透過-MEDIA-QUERY-實作-RWD"><a href="#範例二：透過-MEDIA-QUERY-實作-RWD" class="headerlink" title="範例二：透過 MEDIA QUERY 實作 RWD"></a>範例二：透過 MEDIA QUERY 實作 RWD</h3><p>像 MEDIA QUERY 這類通用性高的程式碼，可以獨立放在 constants\style.js 檔案，以便重複使用：</p>
<pre><code class="javascript=">export const MEDIA_QUERY_MD = &#39;@media screen and &#123;min-width: 768px&#125;&#39;
export const MEDIA_QUERY_LG = &#39;@media screen and &#123;min-width: 1000px&#125;&#39;</code></pre>
<p>接著就可直接在 App.js 引入使用：</p>
<pre><code class="javascript=">import &#123; MEDIA_QUERY_MD, MEDIA_QUERY_LG&#125; from &#39;./constants/style&#39;;

const Button = styled.button`
  padding: 4px;
  color: #232332;
  font-size: 20px;

  $&#123;MEDIA_QUERY_MD&#125; &#123;
    font-size 16px;
  &#125;

  $&#123;MEDIA_QUERY_LG&#125; &#123;
    font-size: 12px;
  &#125;

  &amp;:hover &#123;
    color: red;
  &#125;
  &amp; + &amp; &#123;
    margin-left: 4px;
  &#125;
`</code></pre>
<p>RWD 結果如下：</p>
<p><img src="https://i.imgur.com/OVfi3XR.gif"></p>
<h3 id="範例三：使用-Sass-向量變數"><a href="#範例三：使用-Sass-向量變數" class="headerlink" title="範例三：使用 Sass 向量變數"></a>範例三：使用 Sass 向量變數</h3><p>透過傳入 Global 參數，我們能使用 Sass 向量變數。</p>
<p>舉例來說，我們可在 index.js 引入 <span class="exturl" data-url="aHR0cHM6Ly9zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9hcGkjdGhlbWVwcm92aWRlcg==">ThemeProvider<i class="fa fa-external-link-alt"></i></span>：</p>
<pre><code class="javascript=">import &#123; ThemeProvider &#125; from &#39;styled-components&#39;;

// 宣告 theme 變數
const theme = &#123;
  colors: &#123;
    primary_300: &#39;#ff7777&#39;,
    primary_400: &#39;#e33e3e&#39;,
    primary_500: &#39;#af0505&#39;,
  &#125;
&#125;

ReactDOM.render(
  // 包住 App，並自訂 theme 屬性
  &lt;ThemeProvider theme=&#123;theme&#125;&gt;
    &lt;App /&gt;
  &lt;/ThemeProvider&gt;,
  document.getElementById(&#39;root&#39;)
);</code></pre>
<p>這樣就可以在 App.js 中取用這些變數：</p>
<pre><code class="javascript=">const TodoContent = styled.div`
  font-size: 30px;
  color: $&#123;props =&gt; props.theme.colors.primary_300&#125;;

  $&#123;MEDIA_QUERY_MD&#125; &#123;
    font-size: 20px;
    color: $&#123;props =&gt; props.theme.colors.primary_400&#125;;
  &#125;

  $&#123;MEDIA_QUERY_LG&#125; &#123;
    font-size: 12px;
    color: $&#123;props =&gt; props.theme.colors.primary_500&#125;;
  &#125;
`</code></pre>
<p>也可以把 TodoItem component 獨立成 TodoItem.js 這個檔案，並且 export ：</p>
<pre><code class="javascript=">export default function TodoItem() &#123;...&#125;</code></pre>
<p>並在 App.js 引入：</p>
<pre><code class="javascript=">import TodoItem from &#39;./TodoItem&#39;</code></pre>
<p>這麼做的好處就是，依照功能切割程式碼，能夠達到模組化，進而提高程式碼可讀性。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9wamNoZW5kZXIuYmxvZ3Nwb3QuY29tLzIwMTcvMDEvamF2YXNjcmlwdC1lczYtdGVtcGxhdGUtbGl0ZXJhbHN0YWdnZWQuaHRtbA==">[筆記] JavaScript ES6 中的模版字符串（template literals）和標籤模版（tagged template）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly95YWtpbWhzdS5jb20vcHJvamVjdC9wcm9qZWN0X3cyMV8wNV9SZWFjdF9iYXNpY19DU1MuaHRtbA==">[第二十一週] React 基礎：如何寫 CSS<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 22] React：用 SPA 架構實作一個部落格（三）- 淺談測試</title>
    <url>/react-test/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUzMDItcmVhY3QtaG9va3M=">[FE302] React 基礎 - hooks 版本<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<a id="more"></a>
<h2 id="淺談測試"><a href="#淺談測試" class="headerlink" title="淺談測試"></a>淺談測試</h2><p>這篇會稍微談談有關測試的東西，測試在現今已漸漸成為重要的議題，主要目的就是為了避免產品出現 Bug，藉此提高使用者體驗。</p>
<h3 id="測試的種類"><a href="#測試的種類" class="headerlink" title="測試的種類"></a>測試的種類</h3><p>測試簡單來說可分成以下三種：</p>
<ul>
<li>單元測試 Unit testing <ul>
<li>以程式碼的最小單位進行測試</li>
</ul>
</li>
<li>整合測試 Integration testing <ul>
<li>對不同模組之間的交互作用進行測試</li>
</ul>
</li>
<li>端對端測試 End-to-end testing 或 E2E testing <ul>
<li> 從使用者角度出發，對真實系統進行測試</li>
<li> 主要為「人工測試」</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/ybx5NbQ.png"></p>
<p>（參考資料：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1pbmlhc3AuY29tL3Bvc3QvMjAxOS8wMi8xOC9Vbml0LXRlc3RpbmctSW50ZWdyYXRpb24tdGVzdGluZy1lMmUtdGVzdGluZw==">一次搞懂單元測試、整合測試、端對端測試之間的差異<i class="fa fa-external-link-alt"></i></span>）</p>
<h2 id="React-Testing-Library：測試-React-Component"><a href="#React-Testing-Library：測試-React-Component" class="headerlink" title="React Testing Library：測試 React Component"></a>React Testing Library：測試 React Component</h2><p>如果要測試 React Component，可使用 <span class="exturl" data-url="aHR0cHM6Ly90ZXN0aW5nLWxpYnJhcnkuY29tL2RvY3MvcmVhY3QtdGVzdGluZy1saWJyYXJ5L2ludHJvLw==">React Testing Library<i class="fa fa-external-link-alt"></i></span> 套件，這在安裝 React 時就有內建。</p>
<p>其原理是把 React 的 Component 給 render 出來，並非真的 render 在瀏覽器上，而是透過 JS DOM 模擬成 JS 來執行，即可針對 render 出來的畫面進行各種測試。</p>
<p>在我們建立專案時，就有個 App.test.js 檔案可用來寫測試內容：</p>
<p><img src="https://i.imgur.com/4dcIFV1.png"></p>
<p>每個測試會用一個 function 包住：</p>
<pre><code class="javascript=">import &#123; render, screen &#125; from &#39;@testing-library/react&#39;;
import App from &#39;./App&#39;;

test(&#39;renders learn react link&#39;, () =&gt; &#123;
  // render component
  render(&lt;App /&gt;);
  // 確認是否有出現指定文字
  const linkElement = screen.getByText(/learn react/i);
  // 確認是否有在 document 裡面
  expect(linkElement).toBeInTheDocument();
&#125;);</code></pre>
<p>在終端機輸入指令即可執行測試：</p>
<pre><code>$ npm run test</code></pre>
<p>測試預設會找 App.test.js 在上次 commit 時有更動的部分，例如輸入 a 可跑所有測試結果：</p>
<p><img src="https://i.imgur.com/Hao9KG7.png"></p>
<p>由於 App.test.js 是 watch 模式，只要檔案有變動就會自動跑測試，結果會長這樣：</p>
<p><img src="https://i.imgur.com/EA3y0KO.png"></p>
<h3 id="實際應用"><a href="#實際應用" class="headerlink" title="實際應用"></a>實際應用</h3><p>但實際在測試時並不會真的去 call API，因為 mock API 代表要做什麼事，而我們在意的點其實是：</p>
<ul>
<li>會不會發 request 去 back-end</li>
<li>拿到 API response 之後，會不會顯示想要的資料</li>
</ul>
<p>也就是說，測試其實不需要知道 back-end 回覆的內容，而是透過 mock API Point，就可以在打 API 之前回傳一個結構，藉此來測試顯示的資料。</p>
<p>例如以下範例，藉由 mock API 來模擬每次 fetch 會回傳的資料，再使用 await waitfor() 非同步處理進行測試：</p>
<p><img src="https://i.imgur.com/OX9LJ4X.png"></p>
<p>這種測試方法其實就類似於 Unit testing 或 Integration testing，再來要介紹的是用於 End-to-end testing 的程式。</p>
<h2 id="Cypress：JS-E2E-testing"><a href="#Cypress：JS-E2E-testing" class="headerlink" title="Cypress：JS E2E testing"></a>Cypress：JS E2E testing</h2><p>End-to-end testing 的特點在於會真的跑一個 Browser 起來，並將手動測試轉變成程式碼執行，因此會更接近使用者實際在使用網站的感受。</p>
<p>我們要介紹的是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3lwcmVzcy5pby8=">cypress<i class="fa fa-external-link-alt"></i></span> 這套 E2E testing 程式，在測試時也有提供錄影功能，能夠記錄錯誤截圖等等。</p>
<h3 id="安裝程式"><a href="#安裝程式" class="headerlink" title="安裝程式"></a>安裝程式</h3><pre><code>$ npm install cypress</code></pre>
<h3 id="如何執行"><a href="#如何執行" class="headerlink" title="如何執行"></a>如何執行</h3><pre><code>$ npx cypress open</code></pre>
<p>或是在 package.json 的 scripts 新增 cypress open 指令，即可使用 <code>npm run cypress:open</code> 指令執行：</p>
<p><img src="https://i.imgur.com/GNMrji1.png"></p>
<p>第一次執行 cypress open 時，會自動在 my-app 資料夾建立 cypress 相關程式，像是 integration 裡的內建測試等等。</p>
<p><img src="https://i.imgur.com/GPisKnv.png"></p>
<p>執行後會自動開啟 GUI 介面：</p>
<p><img src="https://i.imgur.com/deKsjBl.png"></p>
<p>預設的測試檔名為 <code>spec.js</code>，例如我們可在 integration 建立一個 home.spec.js，並在 my-app 底下的 cypress.json 新增 baseUrl：</p>
<pre><code class="json=">&#123;
  &quot;baseUrl&quot;: &quot;http://localhost:3000/react-board-test&quot;
&#125;</code></pre>
<p>然後在 home.spec.js 寫入<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmN5cHJlc3MuaW8vZ3VpZGVzL2dldHRpbmctc3RhcnRlZC90ZXN0aW5nLXlvdXItYXBwLmh0bWwjU3RlcC0yLVZpc2l0LXlvdXItc2VydmVy">官網範例<i class="fa fa-external-link-alt"></i></span>：</p>
<pre><code class="javascript=">describe(&quot;The Home Page&quot;, () =&gt; &#123;
  it(&quot;successfully loads&quot;, () =&gt; &#123;
  // 改成連線到首頁
    cy.visit(&quot;/&quot;);
  &#125;);
&#125;);
</code></pre>
<p>點選 cypress 介面中的 home.spec.js 執行：</p>
<p><img src="https://i.imgur.com/20LvIQ2.png"></p>
<p>此時會自動開啟 Chrome 瀏覽器跑測試，結果如下：</p>
<p><img src="https://i.imgur.com/L5NO3Ag.png"></p>
<h3 id="透過-route-來-mock-API"><a href="#透過-route-來-mock-API" class="headerlink" title="透過 route 來 mock API"></a>透過 route 來 mock API</h3><p>但是和先前的例子一樣，我們通常不會真的去 call API，而是會 mock API，在 cypress 可透過 route 來模擬 API，可參考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmN5cHJlc3MuaW8vYXBpL2NvbW1hbmRzL3JvdXRlLmh0bWwjU3ludGF4">官方文件<i class="fa fa-external-link-alt"></i></span>。</p>
<p>首先要修改 cypress.json 設定檔，加上 <code>experimentalFetchPolyfill</code> 參數：</p>
<pre><code class="json=">&#123;
  &quot;baseUrl&quot;: &quot;http://localhost:3000/react-board-test&quot;,
  &quot;experimentalFetchPolyfill&quot;: true
&#125;</code></pre>
<p>改寫 home.spec.js 範例如下，這樣就是一個簡單的測試：</p>
<pre><code class="javascript=">describe(&quot;The Home Page&quot;, () =&gt; &#123;
  it(&quot;successfully loads&quot;, () =&gt; &#123;
    cy.server();
    // mock API
    cy.route(
      &quot;https://student-json-api.lidemy.me/posts?_sort=createdAt&amp;_order=desc&quot;,
      [
        &#123;
          id: 1,
          title: &quot;Hello World!&quot;,
          createdAt: 20202020,
        &#125;,
      ]
    );
    // 導向首頁
    cy.visit(&quot;/&quot;);
    // 測試: 確認頁面是否包含該字串
    cy.contains(&quot;Hello World!&quot;);
  &#125;);
&#125;);</code></pre>
<p>測試結果如下：</p>
<p><img src="https://i.imgur.com/TdVmUf5.png"></p>
<p>查看 Request URL 會發現網址有被 cypress 換成 mock API，藉此來 mock 回傳結果：</p>
<p><img src="https://i.imgur.com/xYYEpka.png"></p>
<ul>
<li>參考文章：<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2hhbm5haC1saW4vY3lwcmVzcy1lMmUtdGVzdGluZy0lRTUlODglOUQlRTYlOEUlQTItYTEwZWNhM2MwY2Y3">[Cypress 1] E2E Testing 初探<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="React-Testing-Library-vs-Cypress"><a href="#React-Testing-Library-vs-Cypress" class="headerlink" title="React Testing Library vs Cypress"></a>React Testing Library vs Cypress</h2><p>以上介紹的兩種測試，差別在於：</p>
<ul>
<li>React Testing Library<ul>
<li>類似於 Unit testing 或 Integration testing</li>
<li>利用 JavaScript 模擬環境</li>
</ul>
</li>
<li>Cypress<ul>
<li>E2E testing</li>
<li>實際在瀏覽器載入頁面，透過 mock API 的方式測試行為</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 22] React：用 SPA 架構實作一個部落格（二）- 身分驗證</title>
    <url>/react-usecontext/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUzMDItcmVhY3QtaG9va3M=">[FE302] React 基礎 - hooks 版本<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<blockquote>
<p>參考文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmh1bGkudHcvMjAxOS8wOS8xOC9zcGEtY29tbW9uLXByb2JsZW0tYWJvdXQtcm91dGVyLw==">淺談新手在學習 SPA 時的常見問題：以 Router 為例<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="如何進行身分驗證？"><a href="#如何進行身分驗證？" class="headerlink" title="如何進行身分驗證？"></a>如何進行身分驗證？</h2><p>在實作登入功能之前，必須先瞭解下列兩種進行身分驗證的方法有何不同：</p>
<ul>
<li>透過 Cookie 驗證，取得 Session ID</li>
<li>把 Session ID 存在瀏覽器的 LocalStorage 裡</li>
</ul>
<h3 id="透過-Cookie-驗證"><a href="#透過-Cookie-驗證" class="headerlink" title="透過 Cookie 驗證"></a>透過 Cookie 驗證</h3><p>與本篇要實作的 SPA 不同，過去我們通常是利用 Cookie 來驗證使用者登入狀態，流程大致如下：</p>
<p><img src="https://i.imgur.com/giVnm0P.png"></p>
<ol>
<li>使用者在登入時會打一個 API 給 Server，Server 確認沒問題之後，會回傳包含 Set-Cookie 的 HTTP Response Header</li>
<li>當使用者需要進行身分驗證時，會打一個 GET/me 的 API 給 Server，瀏覽器會自動帶入 Cookie，假如 Session ID 是正確的，Server 就會回傳 data，反之則回傳錯誤</li>
</ol>
<h3 id="把-Session-ID-存在-LocalStorage"><a href="#把-Session-ID-存在-LocalStorage" class="headerlink" title="把 Session ID 存在 LocalStorage"></a>把 Session ID 存在 LocalStorage</h3><p>但是到了 SPA 之後，我們就比較少用 Cookie 來進行驗證，而是把 Session ID 存在瀏覽器的 LocalStorage 裡，每次發 Resquest 時會自動帶入資料，流程如下：</p>
<p><img src="https://i.imgur.com/8xvtM4x.png"></p>
<ol>
<li>使用者在登入後，Server 會回傳一個 JSON Web Token（一種固定格式的資料），並且儲存在瀏覽器的 LocalStorage 裡</li>
<li>當需要進行身分驗證時，就會自動在 header 帶上這個 JWT 給 Serever，確認沒問題後回傳 data</li>
</ol>
<h3 id="打一個-POST-API-到-Server"><a href="#打一個-POST-API-到-Server" class="headerlink" title="打一個 POST API 到 Server"></a>打一個 POST API 到 Server</h3><p>我們可以試著透過 Postman 打 POST API 到 Server 測試：</p>
<pre><code>POST/
https://student-json-api.lidemy.me/login

Body
&#123;&quot;username&quot;:&quot;user01&quot;, &quot;password&quot;:&quot;Lidemy&quot;&#125;</code></pre>
<p>若 username 和 password 驗證沒問題，Server 就會回傳一個以 base64 編碼的 JWT token：</p>
<pre><code class="json=">&#123;
    &quot;ok&quot;: 1,
    &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIwMSIsInVzZXJJZCI6MSwiaWF0IjoxNjA3NzQzMTA5fQ.FgTlsa57WOYNZEBj5HtL74uIVDuKFWErrmQ72qXuHmo&quot;
&#125;</code></pre>
<p>結果如下：</p>
<p><img src="https://i.imgur.com/QB2O67D.png"></p>
<p>把這段 JWT token 拿到 <span class="exturl" data-url="aHR0cHM6Ly9qd3QuaW8v">jwt 官網<i class="fa fa-external-link-alt"></i></span> 進行解析，可以轉換成 JSON 格式，因此不建議儲存一些敏感資訊（例如密碼、地址等）在 token：</p>
<p><img src="https://i.imgur.com/IVpVipo.png"></p>
<h3 id="透過-token-取得使用者資訊"><a href="#透過-token-取得使用者資訊" class="headerlink" title="透過 token 取得使用者資訊"></a>透過 token 取得使用者資訊</h3><p>接下來我們打一個 GET API 到 Server，並帶上剛才的 token，Server 就會回傳使用者資訊：</p>
<pre><code>GET/
https://student-json-api.lidemy.me/me

Bearer Token
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIwMSIsInVzZXJJZCI6MSwiaWF0IjoxNjA3NzQzMTA5fQ.FgTlsa57WOYNZEBj5HtL74uIVDuKFWErrmQ72qXuHmo</code></pre>
<p>結果如下：</p>
<p><img src="https://i.imgur.com/QyTsG90.png"></p>
<p>學會如何透過打 API 拿到 token 進行身分驗證後，再來我們要實際應用在部落格的登入機制，那麼開始吧！</p>
<hr>
<h2 id="實作：登入功能"><a href="#實作：登入功能" class="headerlink" title="實作：登入功能"></a>實作：登入功能</h2><h3 id="1-設定串接-API-的方法：登入-amp-身分驗證"><a href="#1-設定串接-API-的方法：登入-amp-身分驗證" class="headerlink" title="1. 設定串接 API 的方法：登入 &amp; 身分驗證"></a>1. 設定串接 API 的方法：登入 &amp; 身分驗證</h3><p>同樣參考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpZGVteS9saWRlbXktc3R1ZGVudC1qc29uLWFwaS1zZXJ2ZXIjJUU4JUE4JUJCJUU1JTg2JThB"> API 文件說明<i class="fa fa-external-link-alt"></i></span>，在 WebAPI.js 新增 login 和 getMe 兩個 API：</p>
<pre><code class="javascript=">// 登入
export const login = (username, password) =&gt; &#123;
  return fetch(`$&#123;BASE_URL&#125;/login`, &#123;
    method: &quot;POST&quot;,
    headers: &#123;
      &quot;content-type&quot;: &quot;application/json&quot;,
    &#125;,
    body: JSON.stringify(&#123;
      username,
      password,
    &#125;),
  &#125;).then((res) =&gt; res.json());
&#125;;

// 身分驗證
export const getMe = () =&gt; &#123;
  // 從 localStorage 拿取 token
  const token = localStorage.getItem(&quot;token&quot;);
  return fetch(`$&#123;BASE_URL&#125;/me`, &#123;
    headers: &#123;
      authorization: `Bearer $&#123;token&#125;`,
    &#125;,
  &#125;)
    .then((res) =&gt; res.json())
&#125;;</code></pre>
<h3 id="2-實作-LoginPage-js"><a href="#2-實作-LoginPage-js" class="headerlink" title="2. 實作 LoginPage.js"></a>2. 實作 LoginPage.js</h3><p>可透過 onSubmit 與 onChange 事件機制，拿到 input.value 的值。</p>
<p>在 React 中，value 若為空值（undefined），等同於沒有傳 value，所以這裡初始值要參數設為空字串，也就是 <code>useState(&quot;&quot;)</code>：</p>
<pre><code class="javascript=">export default function LoginPage() &#123;
  // 在 React 中 value 若是 undefined，等同於沒有傳 value
  const [username, setUsername] = useState(&quot;&quot;);
  const [password, setPassword] = useState(&quot;&quot;);

  // 阻止送出表單
  const handleSubmit = (e) =&gt; &#123;
    e.preventDefault();
    // 確認是否有抓到 username
    alert(username);
  &#125;;

  const handleUsername = (e) =&gt; &#123;
    setUsername(e.target.value);
  &#125;;

  const handlePassword = (e) =&gt; &#123;
    setPassword(e.target.value);
  &#125;;
  return (
    &lt;Root&gt;
      &lt;LoginForm onSubmit=&#123;handleSubmit&#125;&gt;
        &lt;LoginTitle&gt;登入&lt;/LoginTitle&gt;
        &lt;LoginInput&gt;
          username: &lt;input value=&#123;username&#125; onChange=&#123;handleUsername&#125; /&gt;
        &lt;/LoginInput&gt;
        &lt;LoginInput&gt;
          password:
          &lt;input type=&quot;password&quot; value=&#123;password&#125; onChange=&#123;handlePassword&#125; /&gt;
        &lt;/LoginInput&gt;
        &lt;LoginSubmit&gt;
          &lt;button&gt;登入&lt;/button&gt;
        &lt;/LoginSubmit&gt;
      &lt;/LoginForm&gt;
    &lt;/Root&gt;
  );
&#125;</code></pre>
<p>結果如下，按下 button 成功拿取 input.value：</p>
<p><img src="https://i.imgur.com/pJDBs0Z.png"></p>
<h3 id="3-建立-utils-js-管理常用功能"><a href="#3-建立-utils-js-管理常用功能" class="headerlink" title="3. 建立 utils.js 管理常用功能"></a>3. 建立 utils.js 管理常用功能</h3><p>在拿取 token 時，其實可以再進行優化，例如把 token 相關的程式碼獨立到 utils.js 管理，即可避免打錯字：</p>
<pre><code class="javascript=">const TOKEN_NAME = &quot;token&quot;;

// 將 token 存到 localStorage
export const setAuthToken = (token) =&gt; &#123;
  localStorage.setItem(TOKEN_NAME, token);
&#125;;

// 從 localStorage 讀取 token
export const getAuthToken = () =&gt; &#123;
  return localStorage.getItem(TOKEN_NAME);
&#125;;</code></pre>
<h3 id="4-串接-API：login"><a href="#4-串接-API：login" class="headerlink" title="4. 串接 API：login"></a>4. 串接 API：login</h3><ul>
<li>WebAPI.js：引入使用 getAuthToken()，從 localStorage 讀取 token 的值：</li>
</ul>
<pre><code class="javascript=">import &#123; getAuthToken &#125; from &quot;./utils&quot;;

// 身分驗證
export const getMe = () =&gt; &#123;
  // 從 localStorage 讀取 token
  const token = getAuthToken();
  return fetch(`$&#123;BASE_URL&#125;/me`, &#123;
    headers: &#123;
      authorization: `Bearer $&#123;token&#125;`,
    &#125;,
  &#125;)
    .then((res) =&gt; res.json())
&#125;;</code></pre>
<ul>
<li>LoginPage.js：使用 setAuthToken() 儲存 token：</li>
</ul>
<pre><code class="javascript=">import &#123; login &#125; from &quot;../../WebAPI&quot;;
import &#123; setAuthToken &#125; from &quot;./utils&quot;;

export default function LoginPage() &#123;
  // 在 React 中 value 若是 undefined，等同於沒有傳 value
  const [username, setUsername] = useState(&quot;&quot;);
  const [password, setPassword] = useState(&quot;&quot;);
  const [errorMessage, setErrorMessage] = useState();

  // 阻止送出表單
  const handleSubmit = (e) =&gt; &#123;
    e.preventDefault();
    login(username, password).then((data) =&gt; &#123;
      // 若 ok 為 0 代表錯誤
      if (data.ok === 0) &#123;
        return setErrorMessage(data.message);
      &#125;
      // 成功的話就把 token 存到 localStorage
      setAuthToken(data.token);
    &#125;);
  &#125;;

  // ...</code></pre>
<p>確認是否有成功透過 localStorage 存取 token：</p>
<p><img src="https://i.imgur.com/mDMvUs9.png"></p>
<h3 id="useHistory：跳轉頁面"><a href="#useHistory：跳轉頁面" class="headerlink" title="useHistory：跳轉頁面"></a>useHistory：跳轉頁面</h3><p>登入成功之後，接著要把使用者導回首頁，可透過 react-router 提供的 Hooks：<span class="exturl" data-url="aHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vd2ViL2FwaS9Ib29rcy91c2VoaXN0b3J5">useHistory<i class="fa fa-external-link-alt"></i></span> 來主動跳轉路由。</p>
<ul>
<li>引入套件：</li>
</ul>
<pre><code class="javascript=">import &#123; useHistory &#125; from &quot;react-router-dom&quot;;</code></pre>
<ul>
<li>將程式碼修改如下，即可在登入後跳轉至首頁：</li>
</ul>
<pre><code class="javascript=">  const history = useHistory();

  const handleSubmit = (e) =&gt; &#123;
    e.preventDefault();
    login(username, password).then((data) =&gt; &#123;
      if (data.ok === 0) &#123;
        return setErrorMessage(data.message);
      &#125;
      // 成功的話就把 token 存到 localStorage
      setAuthToken(data.token);
      // 並導回首頁
      history.push(&quot;/&quot;);
    &#125;);
  &#125;;</code></pre>
<h2 id="實作：身分驗證"><a href="#實作：身分驗證" class="headerlink" title="實作：身分驗證"></a>實作：身分驗證</h2><p>在完成登入功能後，在以 getMe() 拿到使用者資訊之前都還不算登入成功，我們還需要保持登入狀態，也就是把使用者資料透過 Context 存到全域環境中，才能傳給底下的每個 Component 使用。</p>
<h3 id="1-createContext：傳入預設值"><a href="#1-createContext：傳入預設值" class="headerlink" title="1. createContext：傳入預設值"></a>1. createContext：傳入預設值</h3><ul>
<li>contexts.js</li>
</ul>
<p>為了讓其他 Component 也能讀取 user 資料，可在 src 目錄底下建立一個 contexts.js，即可透過 AuthContext() 來取值：</p>
<pre><code class="javascript=">import &#123; createContext &#125; from &quot;React&quot;;

// 初始值為 null
export const AuthContext = createContext(null);</code></pre>
<ul>
<li>App.js</li>
</ul>
<p>把登入狀態存在 Component 的最頂端，只要在 App.js 存 user 狀態，即可透過有無 user 判斷是否登入：</p>
<pre><code class="javascript=">export default function App() &#123;
  // user 有東西就代表有登入
  const [user, setUser] = useState(null);

  //...</code></pre>
<h3 id="2-Context-Provider：提供子層-value"><a href="#2-Context-Provider：提供子層-value" class="headerlink" title="2. Context Provider：提供子層 value"></a>2. Context Provider：提供子層 value</h3><ul>
<li>App.js</li>
</ul>
<p>用 Context Provider 包住整個組件，並設定 value，這裡可傳入物件型態的參數，把 <code>&#123;user, setUser&#125;</code> 傳給子層：</p>
<pre><code class="javascript=">import AuthContext from &quot;../../contexts&quot;;
// ...
  return (
    &lt;AuthContext.Provider value=&#123;&#123;user, setUser&#125;&#125;&gt;
      &lt;Root&gt;
       // 路由配置 ...        
      &lt;/Root&gt;
    &lt;/AuthContext.Provider&gt;
  );
&#125;</code></pre>
<ul>
<li>LoginPage.js</li>
</ul>
<p>引入 AuthContext 取得 user 資訊，用 setUser 儲存狀態，並以 getMe 發出 resquest 進行身分驗證：</p>
<pre><code class="javascript=">import &#123; AuthContext &#125; from &quot;../../contexts&quot;;

export default function LoginPage() &#123;
  const &#123; setUser &#125; = useContext(AuthContext);

// ...

  const handleSubmit = (e) =&gt; &#123;
    e.preventDefault();
    login(username, password).then((data) =&gt; &#123;
      if (data.ok === 0) &#123;
        return setErrorMessage(data.message);
      &#125;
      setAuthToken(data.token);
      getMe().then((response) =&gt; &#123;
        if (data.ok !== 1) &#123;
          // 在 getMe() 出錯代表還沒成功登入，因此要把 token 清空
          setAuthToken(null);
          setErrorMessage(response.toString());
        &#125;
        setUser(response.data);
        // 並導回首頁
        history.push(&quot;/&quot;);</code></pre>
<ul>
<li>Header.js</li>
</ul>
<p>接著就可以根據登入狀態，判斷導覽列是否顯示「登入、註冊」或是「發布文章、登出」。</p>
<p>注意這裡的判斷式裡面，只能包含一個 JSX 標籤，否則會出錯，例如 <code>&#123;user &amp;&amp; &lt;Link&gt;...&lt;/Link&gt;&#125;</code>：</p>
<pre><code class="javascript=">export default function Header() &#123;
  const location = useLocation();
  const &#123; user, setUser &#125; = useContext(AuthContext);
  const history = useHistory();

  const handleLogout = () =&gt; &#123;
    setAuthToken(&quot;&quot;);
    setUser(null);
    if (location.pathname !== &quot;/&quot;) &#123;
      history.push(&quot;/&quot;);
    &#125;
  &#125;;

  return (
    &lt;HeaderContainer&gt;
      &lt;Brand&gt;
        &#123;/* 加上 replace: 避免出現錯誤 -&gt; &quot;Hash history cannot PUSH the same path&quot; */&#125;
        &lt;Link to=&quot;/&quot; replace&gt;
          React 部落格
        &lt;/Link&gt;
      &lt;/Brand&gt;
      &lt;NavbarList&gt;
        &lt;StyledLink exact to=&quot;/about&quot; replace activeClassName=&quot;active&quot;&gt;
          關於我
        &lt;/StyledLink&gt;
        &lt;StyledLink exact to=&quot;/posts&quot; replace activeClassName=&quot;active&quot;&gt;
          文章列表
        &lt;/StyledLink&gt;
        &#123;!user &amp;&amp; (
          &lt;StyledLink to=&quot;/register&quot; activeClassName=&quot;active&quot;&gt;
            註冊
          &lt;/StyledLink&gt;
        )&#125;
        &#123;!user &amp;&amp; (
          &lt;StyledLink to=&quot;/login&quot; activeClassName=&quot;active&quot;&gt;
            登入
          &lt;/StyledLink&gt;
        )&#125;
        &#123;user &amp;&amp; (
          &lt;StyledLink to=&quot;/new-post&quot; activeClassName=&quot;active&quot;&gt;
            發布文章
          &lt;/StyledLink&gt;
        )&#125;
        &#123;user &amp;&amp; (
          &lt;StyledLink to=&quot;&quot; onClick=&#123;handleLogout&#125;&gt;
            登出
          &lt;/StyledLink&gt;
        )&#125;
      &lt;/NavbarList&gt;
    &lt;/HeaderContainer&gt;
  );
&#125;</code></pre>
<p>結果如下：</p>
<p><img src="https://i.imgur.com/NLbXTNr.png"></p>
<p>但這麼寫還有個問題，就是重新整理之後，又會變成未登入狀態，其實 localStorage 還是有 token 存在。</p>
<h3 id="3-useEffect：在-reneder-之後驗證身分"><a href="#3-useEffect：在-reneder-之後驗證身分" class="headerlink" title="3. useEffect：在 reneder 之後驗證身分"></a>3. useEffect：在 reneder 之後驗證身分</h3><p>可使用 useEffect 來解決這個問題，如此一來，在畫面 mount 的時候，就會透過 call getMe API 來驗證身分：</p>
<pre><code class="javascript=">export default function App() &#123;
  const [user, setUser] = useState(null);

  useEffect(() =&gt; &#123;
    // 以 getAuthToken 從 localStorage 讀取 token
    if (getAuthToken()) &#123;
      // 有 token 才 call API
      getMe().then((response) =&gt; &#123;
        if (response.ok) &#123;
          setUser(response.data);
        &#125;
      &#125;);
    &#125;
  &#125;, []);

// ...</code></pre>
<hr>
<h2 id="補充功能"><a href="#補充功能" class="headerlink" title="補充功能"></a>補充功能</h2><h3 id="1-styled-reset：CSS-Reset"><a href="#1-styled-reset：CSS-Reset" class="headerlink" title="1. styled-reset：CSS Reset"></a>1. styled-reset：CSS Reset</h3><p>React 也可搭配 styled-reset 套件，進行 CSS Reset 規格化，詳細參考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3phY2FuZ2VyL3N0eWxlZC1yZXNldCNyZWFkbWU=">官方文件<i class="fa fa-external-link-alt"></i></span>。</p>
<p>安裝套件：</p>
<pre><code>$ npm i styled-reset</code></pre>
<p>引入 styled-reset 套件使用：</p>
<pre><code class="javascript=">import React from &#39;react&#39;
import &#123; Reset &#125; from &#39;styled-reset&#39;

const App = () =&gt; (
  &lt;React.Fragment&gt;
    &lt;Reset /&gt;
    &lt;div&gt;Hi, I&#39;m an app!&lt;/div&gt;
  &lt;/React.Fragment&gt;
)</code></pre>
<h3 id="2-在-Root-設置全域背景圖片"><a href="#2-在-Root-設置全域背景圖片" class="headerlink" title="2. 在 Root 設置全域背景圖片"></a>2. 在 Root 設置全域背景圖片</h3><p>在 App.js 引入 img：</p>
<pre><code class="javascript=">import img from &quot;../../images/bg.jpg&quot;;</code></pre>
<p>以 styled-component 調整 App 中 Root Component 的 css，就會 render 到所有 pages：</p>
<pre><code class="javascript=">const Root = styled.div`
  font-family: &quot;monospace&quot;, &quot;微軟正黑體&quot;;
  color: #4a4a4a;
  box-sizing: border-box;
  padding: 80px 10px;
  background: #fff url($&#123;img&#125;) center center fixed no-repeat;
  background-size: cover;
  height: 100%;
`;</code></pre>
<p>以 LoginPage.js 為例，可針對不同頁面進行微調：</p>
<pre><code class="javascript=">const Root = styled.div`
  height: 100vh;
  padding-top: 100px;
`;</code></pre>
<h3 id="3-優化：畫面閃爍問題"><a href="#3-優化：畫面閃爍問題" class="headerlink" title="3. 優化：畫面閃爍問題"></a>3. 優化：畫面閃爍問題</h3><p>在登入狀態時，重整畫面會出現畫面閃爍的問題，如下圖所示：</p>
<p><img src="https://i.imgur.com/bzRXGRP.gif"></p>
<p>之所以會有這個現象，是因為畫面進行了兩次 render：</p>
<ul>
<li>預設為登出狀態（第一次 render）</li>
<li>當我們發 API 確認有登入之後，才會顯示登入狀態（第二次 render）</li>
</ul>
<p>要改善這個問題的核心概念在於：</p>
<h4 id="在確認是否登入之前，不要顯示和登入登出狀態有關的東西。"><a href="#在確認是否登入之前，不要顯示和登入登出狀態有關的東西。" class="headerlink" title="在確認是否登入之前，不要顯示和登入登出狀態有關的東西。"></a>在確認是否登入之前，不要顯示和登入登出狀態有關的東西。</h4><p>在 APP 執行開始，可以有新的 state（isLoadingGetMe 或是 isGettingUser），預設值為 ture，也就是不顯示登入登出。</p>
<p>一旦接收到 getMe() 回傳的 response 時，或是發現沒有 token 時，就會改成 false，顯示登入登出。</p>
<pre><code class="javascript=">  useEffect(() =&gt; &#123;
    // 以 getAuthToken 從 localStorage 讀取 token
    if (getAuthToken()) &#123;
      // 有 token 才 call API
      getMe().then((response) =&gt; &#123;
        if (response.ok) &#123;
          setUser(response.data);
          setLoadingGetMe(false);
        &#125;
      &#125;);
    &#125; else &#123;
      setLoadingGetMe(false);
    &#125;
  &#125;, []);</code></pre>
<p>也可以實作一個 Loading 畫面，等到渲染完成再顯示頁面。</p>
<h3 id="4-函式宣告-vs-函式呼叫"><a href="#4-函式宣告-vs-函式呼叫" class="headerlink" title="4. 函式宣告 vs 函式呼叫"></a>4. 函式宣告 vs 函式呼叫</h3><p>這裡以 onChange 事件監聽為例：</p>
<ul>
<li>宣告函式 handlePageChange，當 onChange 時會執行函式 handlePageChange</li>
</ul>
<pre><code class="javascript=">onChange=&#123;handlePageChange&#125;</code></pre>
<ul>
<li>會直接呼叫函式 handlePageChange()，並傳入參數 page</li>
</ul>
<pre><code class="javascript=">onChange=&#123;handlePageChange(page)&#125;</code></pre>
<ul>
<li>定義一個新的函式給 onChange，當 onChange 時會執行丟進去的函式</li>
</ul>
<pre><code class="javascript=">onChange=&#123;() =&gt; handlePageChange(page)&#125;

// 等同於
onChange=&#123;function() &#123; 
  return handlePageChange(page)
&#125;</code></pre>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>在實作部落格時可以發現，我們在最一開始雖然擬定了專案架構，實際上還是會在實作的過程進行調整，最後構成的專案架構如下：</p>
<ul>
<li>src<ul>
<li>components 組件<ul>
<li>App 管理路由、設置全域變數</li>
<li>Header 導覽列</li>
<li>Footer 置底訊息</li>
</ul>
</li>
<li>constants 常數</li>
<li>pages 頁面<ul>
<li>HomePage 首頁（顯示最新五篇）</li>
<li>AboutPage 關於我</li>
<li>PostListPage 文章列表頁面</li>
<li>PostPage 單一文章頁面</li>
<li>NewPostPage 發布文章頁面</li>
<li>LoginPage 登入頁面</li>
<li>Register 註冊頁面</li>
</ul>
</li>
<li>WebAPI.js 管理 API</li>
<li>utils.js 管理常用方法</li>
<li>contexts.js 管理傳給子層的 value</li>
</ul>
</li>
</ul>
<p>一旦 components 資料夾中，結構變得更複雜時，會再根據不同功能來區分資料夾，例如 common、post，注意當檔案是 compontent 時，才會以大寫英文開頭命名。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
        <tag>useContext</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 21] React 性能優化：Virtual DOM &amp; 如何避免 re-render</title>
    <url>/react-virtual-dom/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUzMDItcmVhY3QtaG9va3M=">[FE302] React 基礎 - hooks 版本<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 React 課程最一開始，也就是<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWZlMzAyLXJldmlldw==">實作 Todo List<i class="fa fa-external-link-alt"></i></span> 作為範例有提到，新增 todo 時「透過更改資料，畫面再根據資料進行渲染」，可確保兩者永遠一致：</p>
<p><img src="https://i.imgur.com/k1STU0n.png"></p>
<p>那時採取的是簡單暴力的作法，也就是當 State 改變，我們就清空畫面並重新渲染 DOM 元素：</p>
<p><img src="https://i.imgur.com/vf17UN9.png"></p>
<p>但這其實會有效能問題，假如我們今天總共有 100 個 DOM，即使只修改其中一個，卻還是必須清空並重新 Render 這 100 個 DOM。</p>
<p>這樣其實非常沒有效率，應該只需要重新 Render 有更動的部分就好。那麼 React 是如何解決這個問題呢？其實核心概念就是「如何快速找到要改變的地方」。</p>
<h2 id="Reconciliation：React-的渲染機制"><a href="#Reconciliation：React-的渲染機制" class="headerlink" title="Reconciliation：React 的渲染機制"></a>Reconciliation：React 的渲染機制</h2><p>在 React 當中，透過 Reconciliation 渲染機制可以快速找出 State 改變的地方：</p>
<ul>
<li>透過 State 的改變，render 出 Virtual DOM</li>
<li>透過比對 Virtual DOM 的不同，再更新真的 DOM 到畫面</li>
</ul>
<p><img src="https://i.imgur.com/ApLV4M6.png"></p>
<h3 id="什麼是-Virtual-DOM？"><a href="#什麼是-Virtual-DOM？" class="headerlink" title="什麼是 Virtual DOM？"></a>什麼是 Virtual DOM？</h3><p>Virtual DOM 實際上就是用 JavaScript 物件來描述 DOM 結構。</p>
<p>當 DOM 的節點需要更動時，不會直接修改 DOM，而是透過 DOM diff 演算法比較 Virtual DOM 修改前與修改後的樹狀結構，再批次更新真實的 DOM 節點。</p>
<p><img src="https://i.imgur.com/ADMTzi4.png"><br>（圖片來源：<span class="exturl" data-url="aHR0cHM6Ly90dXRvcmlhbHNsaW5rLmNvbS9BcnRpY2xlcy9XaGF0LWlzLVZpcnR1YWwtRE9NLzE1ODAlRUYlQkMlODk=">https://tutorialslink.com/Articles/What-is-Virtual-DOM/1580）<i class="fa fa-external-link-alt"></i></span></p>
<p>比如下方這段 DOM 結構：</p>
<pre><code class="htmlmixed=">&lt;div className=&quot;APP&quot;&gt;
  &lt;TodoItem&gt;
    Watch a Movie
  &lt;/TodoItem&gt;
&lt;/div&gt;</code></pre>
<p>若以 JavaScript 物件形式寫成 Virtual DOM：</p>
<pre><code class="javascript=">&#123;
  tag: &#39;div&#39;,
    props: &#123;
      className: &#39;APP&#39;
    &#125;
  children: [
    &#123;
      tag: &#39;TodoItem&#39;,
      children: &#39;Watch a Movie&#39;
    &#125;
  ]
&#125;    </code></pre>
<h3 id="為什麼需要-Virtual-DOM？"><a href="#為什麼需要-Virtual-DOM？" class="headerlink" title="為什麼需要 Virtual DOM？"></a>為什麼需要 Virtual DOM？</h3><p>因為操作 DOM 這件事，其實會耗費很大的成本；而 React 背後運行機制，就是透過比對 Virtual DOM 來避免直接操作 DOM，藉此來提升效能。</p>
<p>除了提升效能這個優點，因為建立 Virtual DOM 這一虛擬層，我們能夠對程式碼進行更多操作，例如：</p>
<ul>
<li>轉成真的 DOM 結構</li>
<li>轉成 Markdown 語法</li>
<li>轉成 mobile APP 語法</li>
</ul>
<p>簡單總結 Virtual DOM 帶來的兩大優點：</p>
<ul>
<li>在 State 改變時，透過比對 Virtual DOM 來判斷是否更新、建立真的 DOM，藉此優化效能</li>
<li>可透過 Virtual DOM 建立更多操作</li>
</ul>
<p>參考文章：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jeXRoaWx5YS5naXRodWIuaW8vMjAxNy8wMy8zMS92aXJ0dWFsLWRvbS8=">Virtual DOM 概述<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tLyVFNiU4OSU4QiVFNSVBRiVBQiVFNyVBRCU4NiVFOCVBOCU5OC9idWlsZC1hLXNpbXBsZS12aXJ0dWFsLWRvbS01Y2YxMmNjZjM3OWY=">Virtual DOM | 為了瞭解原理，那就來實作一個簡易 Virtual DOM 吧！<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRlY2hicmlkZ2UuY2MvMjAxOS8wMi8wNC92ZG9tLWZyb20tc2NyYXRjaC8=">從頭打造一個簡單的 Virtual DOM<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="如何避免-re-render？"><a href="#如何避免-re-render？" class="headerlink" title="如何避免 re-render？"></a>如何避免 re-render？</h2><p>透過 React 的 Function Component，我們能將頁面切割成許多 Component 來方便管理。</p>
<p>但需注意這樣的結構，一但 props 或 state 改變時就很容易觸發 re-render（重新渲染），這如果發生在大型專案，不斷重新渲染可能產生效能問題，加重伺服器的負擔。</p>
<h3 id="memo：Higher-Order-Component"><a href="#memo：Higher-Order-Component" class="headerlink" title="memo：Higher Order Component"></a>memo：Higher Order Component</h3><p>React.memo 是一個 HOC（Higher Order Component），根據<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvaGlnaGVyLW9yZGVyLWNvbXBvbmVudHMuaHRtbA==">官網說明<i class="fa fa-external-link-alt"></i></span>：</p>
<blockquote>
<p>HOC: a higher-order component is a function that takes a component and returns a new component.<br>（把一個元件丟進 HOC 函數時，會經過一些處理並返回新元件）</p>
</blockquote>
<p>用法如下：</p>
<pre><code class="javascript=">const MyComponent = React.memo(function MyComponent(props) &#123;
    ...
&#125;);</code></pre>
<p>比如說，當子元件依賴於父元件的狀態（state）或事件（event），在父元件中宣告狀態與事件方法，可透過 props 將傳遞到子元件中。</p>
<p>但如果是在父元件的狀態被改變，props 結果不變的情況下，子元件即使沒有改變，仍然會被重新渲染，像這樣多餘的渲染就會造成效能浪費。</p>
<p>而 React.memo 這個 HOC 就負責比較元件當中的 props 有沒有改變，減少元件不必要的渲染。</p>
<p>以下方 input 作為範例：</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="React memo" src="https://codepen.io/heidiliu2020/embed/preview/rNMOpLY?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/heidiliu2020/pen/rNMOpLY'>React memo</a> by Heidi-Liu
  (<a href='https://codepen.io/heidiliu2020'>@heidiliu2020</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>而 memo 與 useCallback 常會搭配使用，useCallback 讓 props 的 Object 在父元件重新渲染時，不重新分配記憶體位址，讓 memo 不會因為重新分配記憶體位址造成渲染。</p>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>useMemo 的用法則是無關於父元件，主要用在當元件重新渲染時，減少在元件中複雜的程式重複執行。</p>
<h3 id="什麼情況需要進行優化"><a href="#什麼情況需要進行優化" class="headerlink" title="什麼情況需要進行優化"></a>什麼情況需要進行優化</h3><p>性能優化總是會有成本，但並不總是帶來好處。具體來說，使用這類型的 hooks 可能會複雜化程式碼；也可能反而使性能下降。因此，除非需要進行昂貴的運算，否則必要的情況下不建議使用。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tLyVFNiU4OSU4QiVFNSVBRiVBQiVFNyVBRCU4NiVFOCVBOCU5OC9yZWFjdC1vcHRpbWl6ZS1wZXJmb3JtYW5jZS11c2luZy1tZW1vLXVzZWNhbGxiYWNrLXVzZW1lbW8tYTc2YjZiMjcyZGYz">React 性能優化那件大事，使用 memo、useCallback、useMemo<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDI0MDI5Nj9zYz1pVGhvbWVS">關於props的記憶，React Memo (新增範例及說明)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qYW5jYXQuZ2l0aHViLmlvL3Bvc3QvMjAxOS90cmFuc2xhdGlvbi11c2VtZW1vLWFuZC11c2VjYWxsYmFjay8=">【譯】什麼時候使用useMemo 和useCallback<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81Njk3NTY4MQ==">React Hooks 第一期：聊聊useCallback<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="React-事件機制"><a href="#React-事件機制" class="headerlink" title="React 事件機制"></a>React 事件機制</h2><p>在 React 的事件機制，其實是透過 root 這層進行事件代理，而不是綁在 button 等 DOM 節點上。</p>
<p>當我們開啟開發者工具，查看修改 todo 狀態 button 的監聽事件，會是以下畫面：</p>
<p><img src="https://i.imgur.com/YKxqY4S.png"></p>
<p>但如果把 button 的 click 監聽事件給 remove，還是能夠更改狀態：</p>
<p><img src="https://i.imgur.com/7jftRiR.png"></p>
<p>這是因為，React 是由上層的節點 root 進行事件監聽，也就是以 <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code> 作為事件代理：</p>
<p><img src="https://i.imgur.com/7I8Yekk.png"></p>
<p>React 透過這樣的事件機制能夠提升效能，也確保動態新增的元素能夠捕捉到事件機制。</p>
<hr>
<h2 id="useContext：用來解決-Props-drilling"><a href="#useContext：用來解決-Props-drilling" class="headerlink" title="useContext：用來解決 Props drilling"></a>useContext：用來解決 Props drilling</h2><p>由於 React 單向資料流的特性，資料傳遞須遵循從上到下的單一方向性。</p>
<p>當子元件的狀態改變影響到父元件或共享元件，會透過事件機制等方式通知父元件，render 之後再透過 props 把更新的值傳遞給子元件達成畫面更新。</p>
<p>但如果父子之間隔了許多層元件，還是必須把 props 一層一層傳下去，這種情況就是 Props drilling，容易造成 bugs 難以維護。</p>
<p>而 useContext 可以解決這個問題。useContext 是用來接收與父元件傳遞資料時的 Hooks，用途和 props 相同，</p>
<p>參考文章：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRlY2hicmlkZ2UuY2MvMjAxOC8wNy8yMS9hZHZhbmNlZC1yZWFjdC1jb21wb25lbnQtcGF0dGVybnMtbm90ZS1JSS8=">進階 React Component Patterns 筆記（下）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wamNoZW5kZXIuYmxvZ3Nwb3QuY29tLzIwMTkvMDcvcmVhY3QtcmVhY3QtY29udGV4dC1hcGkuaHRtbA==">[React] React Context API 以及 useContext Hook 的使用<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2Vuam95LWxpZmUtZW5qb3ktY29kaW5nL3JlYWN0LSVFNSU5QyVBOC1ob29rcy0lRTQlQjglQUQlRTQlQkIlQTUtdXNlY29udGV4dC0lRTglODglODctdXNlcmVkdWNlci0lRTUlQUYlQTYlRTclOEYlQkUtcmVkdXgtM2E4YWE0MDNkOWU0">React | 在 Hooks 中以 useContext 與 useReducer 實現 Redux<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="補充：Virtual-DOM-的起源"><a href="#補充：Virtual-DOM-的起源" class="headerlink" title="補充：Virtual DOM 的起源"></a>補充：Virtual DOM 的起源</h2><p>推薦這篇：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01yRXJIdS9ibG9nL2lzc3Vlcy8yNg==">了不起的Virtual DOM(一)：起源<i class="fa fa-external-link-alt"></i></span>，有談到 Virtual DOM 的起源，其實任何技術或工具的誕生都是有原因的，例如框架是因應逐漸擴大的程式規模，為了可維護性與便於開發而出現。</p>
<p>前端在 MVC 模式中，隨著應用規模增加，Model 與 View 之間的複雜關係使得開發難度增加。</p>
<p><img src="https://i.imgur.com/09TAbTq.png"></p>
<p>而為了改善 MVC 模式，之後就出現了 MVP 模式，將 MVC 中的 Controller 改為 Presenter，使 Model 和 View 兩者之間相互獨立，但這同樣有個缺點，就是 Presenter 需要承擔的功能過多，難以後續維護。</p>
<p><img src="https://i.imgur.com/UOlvxGZ.png"></p>
<p>MVVM 結構是以 MVP 作為基礎進行改良，將原來的 Presenter 進化為 View Of Model（VM：視圖模型），負責 View 與 Model 的雙向綁定，將 View與 Model 之間的手動維護更新改為自動更新，這麼做的好處是大幅提高可維護性。但也需注意 ViewModel 構建與維護成本相對較高，複雜的視圖也帶來性能成本，因此不適用較簡單的頁面。</p>
<p><img src="https://i.imgur.com/XaC6n6i.png"></p>
<p>直到 React 出現，解決思路就是「當 Model 發生改變時直接重新渲染 View」，引入 Virtual DOM 的概念。透過 JavaScript 物件來描述 DOM 結構，產生當下 Model 對應的 Virtual DOM 結構，再和上次的 Virtual DOM 結構透過 Diff 演算法比較，再將兩者差異建立在真實 DOM 上。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>其實關於 React 優化，還是不太瞭解該如何使用 hooks 來避免重新渲染，只有大概瞭解原理，還有並不是所有情況都是用性能優化。除非是在大型專案，需要進行昂貴的計算才可能會用到，因此這部分等之後有機會再來深入研究。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 21] 前端框架 - 先別急著學 React</title>
    <url>/react/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUzMDItcmVhY3QtaG9va3M=">[FE302] React 基礎 - hooks 版本<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<pre><code>學習目標：

 P1 我知道 React 的目的以及原理
 P1 我知道我們為什麼需要 React
 P1 我知道使用 React 跟之前使用 jQuery 的區別
 P1 我理解 state 跟 props 的不同</code></pre>
<a id="more"></a>
<hr>
<h2 id="先別急著學-React"><a href="#先別急著學-React" class="headerlink" title="先別急著學 React"></a>先別急著學 React</h2><p>在開始之前，我們先來複習如何用 jQuery 來做出一個簡單的 Todo List 吧！</p>
<ol>
<li>以下是套用 Bootstrap 切的版型，不過切版部分不是這次要探討的重點：</li>
</ol>
<pre><code class="htmlmixed=">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css&quot;
    integrity=&quot;sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2&quot; crossorigin=&quot;anonymous&quot;&gt;</code></pre>
<iframe height="324" style="width: 100%;" scrolling="no" title="[week21] Todo List template" src="https://codepen.io/heidiliu2020/embed/preview/vYKoNJK?height=324&theme-id=dark&default-tab=html,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/heidiliu2020/pen/vYKoNJK'>[week21] Todo List template</a> by Heidi-Liu
  (<a href='https://codepen.io/heidiliu2020'>@heidiliu2020</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<ol start="2">
<li>接著引入使用 jQuery：</li>
</ol>
<pre><code class="javascript=">&lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;</code></pre>
<ol start="3">
<li>就可以來新增功能了：</li>
</ol>
<ul>
<li>新增</li>
<li>切換已完成/未完成</li>
<li>刪除</li>
</ul>
<iframe height="265" style="width: 100%;" scrolling="no" title="[week21] Todo List template" src="https://codepen.io/heidiliu2020/embed/preview/vYKoNJK?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/heidiliu2020/pen/vYKoNJK'>[week21] Todo List template</a> by Heidi-Liu
  (<a href='https://codepen.io/heidiliu2020'>@heidiliu2020</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<h2 id="初探-Component"><a href="#初探-Component" class="headerlink" title="初探 Component"></a>初探 Component</h2><p>根據 <span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvY29tcG9uZW50cy1hbmQtcHJvcHMuaHRtbA==">React<i class="fa fa-external-link-alt"></i></span> 官網定義：</p>
<blockquote>
<p>Component 使你可以將 UI 拆分成獨立且可複用的程式碼，並且專注於各別程式碼的思考。</p>
</blockquote>
<p>簡單來說，component（元件、組件）其實就像 JavaScript 的 function，可接收任意的 props（參數， property 的簡寫）並且回傳描述畫面的 React element。</p>
<p>以我們剛才實作的 todolist 來說，就可以根據功能分成不同的 component：</p>
<p><img src="https://i.imgur.com/XYSTyfM.png"></p>
<h3 id="Component-amp-Props"><a href="#Component-amp-Props" class="headerlink" title="Component &amp; Props"></a>Component &amp; Props</h3><p>再來我們可試著用 component 的概念改寫程式碼，例如切割出 Todo 和 Button component。</p>
<ol>
<li><p>必須用英文大寫開頭命名來辨別是 component：
　</p>
<pre><code class="javascript=">// Todo component: 用來回傳 html 內容, 用大寫英文開頭
function Todo(content) &#123;
return `
 &lt;li class=&quot;todo list-group-item d-flex justify-content-between align-items-center&quot;&gt;
   &lt;div class=&quot;todo-title &quot;&gt;$&#123;content&#125;&lt;/div&gt;
   &lt;div class=&quot;btn-group&quot;&gt;
     $&#123;Button(&#39;btn-undone btn-outline-secondary&#39;, &#39;未完成&#39;)&#125;
     $&#123;Button(&#39;btn-delete btn-outline-danger&#39;, &#39;刪除&#39;)&#125;
   &lt;/div&gt;
 &lt;/li&gt;
`
&#125;
// Button component
function Button(className, content) &#123;
return `
 &lt;button class=&quot;btn $&#123;className&#125;&quot; type=&quot;button&quot;&gt;$&#123;content&#125;&lt;/button&gt;
`
&#125;</code></pre>
</li>
<li><p>監聽事件就可改成 Button component 寫法，比起原本的 HTML 程式碼，用 component 寫法會更容易閱讀：</p>
</li>
</ol>
<pre><code class="javascript=">$(&#39;.todos&#39;).on(&#39;click&#39;, &#39;.btn-undone&#39;, e =&gt; &#123;
  const todo = $(e.target).parent();
  e.target.remove();
  todo.prepend(
    Button(&#39;btn-done btn-outline-success&#39;, &#39;已完成&#39;)
  );
&#125;); 

$(&#39;.todos&#39;).on(&#39;click&#39;, &#39;.btn-done&#39;, e =&gt; &#123;
  const todo = $(e.target).parent();
  e.target.remove();
  todo.prepend(
    Button(&#39;btn-undone btn-outline-secondary&#39;, &#39;未完成&#39;)
  );
&#125;); </code></pre>
<ol start="3">
<li>但其實這個寫法還能再做優化，像是 Button() 如果要再傳入更多參數，就會很難快速判斷。因此我們可以改成傳入物件，也就是 props（參數）來簡化：</li>
</ol>
<pre><code class="javascript=">// Todo component: 傳入物件作為參數
function Todo(props) &#123;
  return `
    &lt;li class=&quot;todo list-group-item d-flex justify-content-between align-items-center&quot;&gt;
      &lt;div class=&quot;todo-title &quot;&gt;$&#123;props.content&#125;&lt;/div&gt;
      &lt;div class=&quot;btn-group&quot;&gt;
        $&#123;Button(&#123;
          className: &#39;btn-undone btn-outline-secondary&#39;,
          content: &#39;未完成&#39;
          &#125;)&#125;
        $&#123;Button(&#123;
          className: &#39;btn-delete btn-outline-danger&#39;,
          content: &#39;刪除&#39;
          &#125;)&#125;
      &lt;/div&gt;
    &lt;/li&gt;
  `
&#125;
// Button component: 傳入物件作為參數
function Button(props) &#123;
  return `
    &lt;button class=&quot;btn $&#123;props.className&#125;&quot; type=&quot;button&quot;&gt;$&#123;props.content&#125;&lt;/button&gt;
  `
&#125;</code></pre>
<p>監聽事件也同樣以物件的形式修改，完整程式碼與執行畫面如下：</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="[week21] Todo List template_component" src="https://codepen.io/heidiliu2020/embed/preview/dypbKLw?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/heidiliu2020/pen/dypbKLw'>[week21] Todo List template_component</a> by Heidi-Liu
  (<a href='https://codepen.io/heidiliu2020'>@heidiliu2020</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<p>透過這種寫法，我們能夠將重複的區塊變成模板，建立統一的規則來封裝，也會提高程式碼的可讀性。</p>
<p>但 component 其實是一種抽象的概念，還有另外一種較為標準的寫法 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvV2ViX0NvbXBvbmVudHM=">Web Components<i class="fa fa-external-link-alt"></i></span>，類似建立新的 HTML 標籤來使用，只是目前瀏覽器支援度還不高，這部分我們並不進行討論。</p>
<h2 id="資料-vs-畫面（UI）"><a href="#資料-vs-畫面（UI）" class="headerlink" title="資料 vs 畫面（UI）"></a>資料 vs 畫面（UI）</h2><p>根據前面的範例，是把資料放到畫面上來呈現，也就是在新增、修改 todo 時，同時去更動資料和畫面。因此我們可從 UI 去抽取資料，但我們無法直接把 HTML 程式碼存到資料庫，而是要去除標籤，轉換成 JSON 等最原始的資料形式。</p>
<p>此外，透過這種方式其實有個壞處，假如有部分資料沒有更動到，就可能導致資料與畫面不一致。</p>
<p><img src="https://i.imgur.com/TKkUPnR.png"></p>
<p>至於要如何解決這個問題，我們可以改成直接修改資料，然後畫面從資料產生，即可保持資料與畫面的一致性。</p>
<p><img src="https://i.imgur.com/k1STU0n.png"></p>
<p>這其實就是 React 第二個重要概念 State，畫面永遠由 state 產生。用數學式可表示成 <code>UI = f(state)</code>，代表 state 不變的話，透過 state 產生的 UI 也不會改變。</p>
<h2 id="畫面永遠都由-state-產生"><a href="#畫面永遠都由-state-產生" class="headerlink" title="畫面永遠都由 state 產生"></a>畫面永遠都由 state 產生</h2><p>根據 <span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvcmVhY3QtY29tcG9uZW50Lmh0bWwjc3RhdGU=">React<i class="fa fa-external-link-alt"></i></span> 官網定義：</p>
<blockquote>
<p>State 包含了某個 component 內特定的、會隨時間改變的資料，這個 state 是由使用者定義的。它應是一個簡單的 JavaScript object。</p>
</blockquote>
<blockquote>
<p>如果某個值並沒有在 render 或資料流中被使用（例如計時器的 ID），你不需要將它放在 state 內。</p>
</blockquote>
<p>繼續舉剛才的範例，我們可以把 todos 放到 state 物件中，並且將 Todo component 中的 todo 加上 id：</p>
<pre><code class="javascript=">  let id = 0;
  let state = &#123;
    todos: []
  &#125;

  function Todo(props) &#123;
    // 自訂屬性通常以 data- 開頭
    return `
      &lt;li class=&quot;data-id=&quot;$&#123;id&#125;&quot;&gt;
       ...
    `</code></pre>
<ul>
<li>新增 todo：透過 updateState() 來更新資料</li>
</ul>
<pre><code class="javascript=">  $(&#39;.btn-add&#39;).click(() =&gt; &#123;
    const content = $(&#39;.input-todo&#39;).val();
    if (!content) return;
    $(&#39;.input-todo&#39;).val(&#39;&#39;);
    // 更新 state
    updateState(&#123;
      todos: [...state.todos, &#123;
        id,
        content,
        isDone: false
      &#125;]
    &#125;);
    id++;
  &#125;);</code></pre>
<ul>
<li>呼叫 updateState() 來更新資料，再根據資料 render 出畫面：</li>
</ul>
<pre><code class="javascript=">// 更新 state
function updateState(newState) &#123;
  state = newState;
  render();
&#125;

function render() &#123;
  // 先把畫面清空
  $(&#39;.todos&#39;).empty();
  $(&#39;.todos&#39;).append(
    // 把每個 todo 的 HTML 集合起來放到畫面上
    state.todos.map(todo =&gt; Todo(todo)).join(&#39;&#39;)
  );
&#125;</code></pre>
<ul>
<li>刪除 todo：透過篩選掉資料中相對應的 todo 來更新 state</li>
</ul>
<pre><code class="javascript=">$(&#39;.todos&#39;).on(&#39;click&#39;, &#39;.btn-delete&#39;, e =&gt; &#123;
  // 讀取該 todo id
  const id = Number($(e.target).parents(&#39;.todo&#39;).attr(&#39;data-id&#39;));
  // 更新 state: 篩選掉資料中相對應的 todo
  updateState(&#123;
    todos: state.todos = state.todos.filter(todo =&gt; todo.id !== id)
  &#125;);
&#125;);</code></pre>
<p>修改 todo 狀態也是類似概念，完整程式碼如下：</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="[week21] Todo List template_component &amp; state" src="https://codepen.io/heidiliu2020/embed/preview/wvzvBbY?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/heidiliu2020/pen/wvzvBbY'>[week21] Todo List template_component &amp; state</a> by Heidi-Liu
  (<a href='https://codepen.io/heidiliu2020'>@heidiliu2020</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<hr>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>在剛接觸 React 時，覺得和之前實作的 <span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWJlMTAxLXBocC10b2RvbGlzdA==">SPA 留言版<i class="fa fa-external-link-alt"></i></span>概念很類似，以非同步方式串接後端 API，透過將前後端分離，以動態方式來更新頁面，同樣是直接更新後端資料來顯示前端畫面。</p>
<p>我們也從 Todo List 範例中，學到 React 最重要的兩個概念 Component 和 State：</p>
<ul>
<li>透過 Component 將畫面與功能模組化，並以傳入的參數 props 來設定屬性或是資料</li>
<li>因為畫面永遠由 State 產生，我們會直接更改資料，再由資料去顯示畫面</li>
</ul>
<p>瞭解到這些概念後，我們就能正式入門 React 這套 JavaScript Library。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 5] 複習週 - 前四週學習與解題心得</title>
    <url>/review/</url>
    <content><![CDATA[<ul>
<li>Command line 的使用</li>
<li>Git 的基本操作</li>
<li>JavaScript 基本語法及程式思維</li>
<li>網路基本概念</li>
<li>解題心得 - Lidemy HTTP Challenge</li>
</ul>
<a id="more"></a>
<h3 id="Command-line-的使用"><a href="#Command-line-的使用" class="headerlink" title="Command line 的使用"></a>Command line 的使用</h3><p>第一次在終端機輸入指令，像是害怕把電腦弄壞似的，總是擔心會輸錯指令；也還記得第一次卡在 vim 介面出不來，最後使用重開大法解決（？）事後也證明其實不需顧慮這麼多，就算手殘打錯字，也只會回傳錯誤訊息而已XD </p>
<h4 id="複習筆記："><a href="#複習筆記：" class="headerlink" title="複習筆記："></a>複習筆記：</h4><ul>
<li><a href="http://jtliu.coderbridge.io/2020/06/14/command-line-codediary/"><br>coderbridge - [Week 1] Command Line 入門 &amp; 基本指令</a></li>
</ul>
<h3 id="Git-的基本操作"><a href="#Git-的基本操作" class="headerlink" title="Git 的基本操作"></a>Git 的基本操作</h3><p>在剛學習程式語言時，就看過幾篇文章說 Git 版本控制非常重要！而且剛好現在工作的地方是使用 SVN，雖然平常只有接觸到下載或更新檔案，但實際接觸到也更能夠了解到彼此之間的差異。</p>
<p>到現在邁入第六週，許多指令也已經記在腦海裡，想想還真是不可思議！雖然每次交作業時還是會一邊看<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vcWltWTNLajRRVmVYM3ZmNC05dUJFQQ==">步驟<i class="fa fa-external-link-alt"></i></span>來操作，相信多練習幾次就會更加熟記起來！
　</p>
<h4 id="複習筆記：-1"><a href="#複習筆記：-1" class="headerlink" title="複習筆記："></a>複習筆記：</h4><ul>
<li><a href="https://jtliu.coderbridge.io/2020/06/19/git-beginner-codediary/"><br>coderbridge -  [week 1] 版本控制 - Git 概念 ＆ 基本指令</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vRF9BUFZrSldUWnlad1M0VFYwZzk3Zw==">[week 1] 版本控制 - Git 進階指令 &amp; GitHub<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="JavaScript-基本語法及程式思維"><a href="#JavaScript-基本語法及程式思維" class="headerlink" title="JavaScript 基本語法及程式思維"></a>JavaScript 基本語法及程式思維</h3><p>在迴圈卡住似乎是必經之路，把觀念建立起來之後就是不斷解題練習。有時候還是會發生程式碼雖然幾乎對了，卻因為把值放在大括號錯誤位置，導致無法拿到預期輸出。</p>
<p>再來是了解如何在 LIOJ 上解題，一開始在「如何把值傳入」這件事情陷入苦戰，經歷過無數個 WA；最後還是先看了參考影片，也了解到有時卡住可能是某些觀念還需要釐清，例如值的型態、邊界數字等，都是需要注意的地方。還有透過 eslint 檢查語法，讓自己習慣依照規則去撰寫程式碼，熟悉之後在 commit 時就比較不會跳出一整排錯誤需要修正了。</p>
<p>雖然還有些題目沒做完，會再找空閒時間當作複習慢慢完成。筆記也想再好好整理，並且更新到 coderbridg 上。複習週沒能完成這些事情，之後如果有空檔會再回來補上！</p>
<h4 id="尚須整理-amp-補筆記（位移運算子、ES6）："><a href="#尚須整理-amp-補筆記（位移運算子、ES6）：" class="headerlink" title="尚須整理 &amp; 補筆記（位移運算子、ES6）："></a>尚須整理 &amp; 補筆記（位移運算子、ES6）：</h4><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vNzEwSlFnTUpSUnFxOTVfeDcxWl9Idw==">[week 2] 先別急著寫 leetcode - 虛擬碼、Debugger、解題技巧<i class="fa fa-external-link-alt"></i></span> </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vOVd5MGJ4c1NSdXlQWmx6RjhTTlR4QQ==">[week 2] JavaScript 基礎 - 基本語法、值的型別、變數、迴圈、函數<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vVWdVS0ZGbFVUcW1VTkVZMU0wZmg4Zw==">[week 3] JavaScript 技能：ES6 + npm + Jest<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="網路基本概念"><a href="#網路基本概念" class="headerlink" title="網路基本概念"></a>網路基本概念</h3><p>是前四週挫折感最重的一週，但也難怪畢竟是接觸全新的東西，必須花費更多時間來熟悉。前面有關 HTTP 的概念在火球數也有提到一些，但到了實際串接 API 部分就突然懵懂了。</p>
<p>還記得在寫 week4 的第一項作業時完全沒有頭緒，最後還是先找了參考解答，了解整個流程應該要如何操作。了解之後其實就和課程提到的實戰練習很像，知道不同 Method 的使用時機。還有最一開始的傳紙條故事，其實就和送出請求、回傳資料的概念是一樣的，重新看過文章後才漸漸有所體會。</p>
<h4 id="尚須整理-amp-補筆記（curl-指令）"><a href="#尚須整理-amp-補筆記（curl-指令）" class="headerlink" title="尚須整理 &amp; 補筆記（curl 指令）"></a>尚須整理 &amp; 補筆記（curl 指令）</h4><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vV2R3LVBIWm9Ub1N4aS1Nd3lrVjhhUSMlRTYlQjclQkElRTglQUIlODctQVBJ">[week 4] 網路基礎概論 - HTTP 協定、TCP/IP、API<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="解題心得-Lidemy-HTTP-Challenge"><a href="#解題心得-Lidemy-HTTP-Challenge" class="headerlink" title="解題心得 - Lidemy HTTP Challenge"></a>解題心得 - Lidemy HTTP Challenge</h2><p>謝謝 Huli 製作這麼有趣的小遊戲！其實剛開始對 API 串接還是有點不太了解，透過小遊戲實際操作，漸漸能夠知道自己究竟傳入哪些資訊，要如何才能拿到想要的資訊，或是該如何進行身分驗證等等，也讓自己對有點挫敗的第四週重拾些許信心。目前玩到 Lv10，之後也會想把後面慢慢解完！</p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><ul>
<li>了解如何使用 query string 傳入 token。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9zdGFydA==">https://lidemy-http-challenge.herokuapp.com/start<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjE/dG9rZW49JTdCR09HT0dPJTdE">https://lidemy-http-challenge.herokuapp.com/lv1?token={GOGOGO}<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="Lv1"><a href="#Lv1" class="headerlink" title="Lv1"></a>Lv1</h3><ul>
<li>了解如何在 token 後面帶上其他資訊（name）。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjE/dG9rZW49JTdCR09HT0dPJTdEJmFtcDtuYW1lPUhlaWRp">https://lidemy-http-challenge.herokuapp.com/lv1?token={GOGOGO}&amp;name=Heidi<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="Lv2"><a href="#Lv2" class="headerlink" title="Lv2"></a>Lv2</h3><ul>
<li>了解如何在 token 後面帶上其他資訊（id）。</li>
<li>這題是 54~58 一個一個試，最後發現 id 56 符合結果。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjI/dG9rZW49JTdCSGVsbE9XT3JsZCU3RCZhbXA7aWQ9NTY=">https://lidemy-http-challenge.herokuapp.com/lv2?token={HellOWOrld}&amp;id=56<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="Lv3"><a href="#Lv3" class="headerlink" title="Lv3"></a>Lv3</h3><ul>
<li>了解如何透過 node.js 傳入 request，利用 POST 來新增書籍。</li>
<li>這題稍微卡關了一下，因為一開始有點搞不懂 header、body、form 的階層關係，修改過後原來這兩種寫法都能得到 response：<code>&#123; message: &#39;新增成功&#39;, id: &#39;1989&#39; &#125;</code>。</li>
</ul>
<pre><code class="js">// 在 body 以 query string 帶入 name 和 ISBN
  headers: &#123;
    &#39;content-type&#39;: &#39;application/x-www-form-urlencoded&#39;,
  &#125;,
  body: &#39;name=《大腦喜歡這樣學》&amp;ISBN=9789863594475&#39;</code></pre>
<pre><code class="js">// 在 form 帶入 name 和 ISBN
headers: &#123;
  &#39;content-type&#39;: &#39;application/x-www-form-urlencoded&#39;,
&#125;,
form: &#123;
　name: &#39;《大腦喜歡這樣學》&#39;,
　ISBN: &#39;9789863594475&#39;
&#125;</code></pre>
<ul>
<li>得到回應為：<code>&#123; message: &#39;新增成功&#39;, id: &#39;1989&#39; &#125; </code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjM/dG9rZW49JTdCNTU2Nk5PMSU3RCZhbXA7aWQ9MTk4OQ==">https://lidemy-http-challenge.herokuapp.com/lv3?token={5566NO1}&amp;id=1989<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjQ/dG9rZW49JTdCTEVhcm5IT1d0b0xlQXJuJTdE">https://lidemy-http-challenge.herokuapp.com/lv4?token={LEarnHOWtoLeArn}<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="Lv4"><a href="#Lv4" class="headerlink" title="Lv4"></a>Lv4</h3><ul>
<li><p>了解如何透過 GET 來獲得所有書籍資訊，並從中篩選出符合結果的書名和作者。</p>
</li>
<li><p>得到回應為：<code> &#123; id: 79, name: &#39;世界末日與冷酷異境&#39;, author: &#39;村上春樹&#39;, ISBN: &#39;9571313408&#39; &#125;,</code></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjQ/dG9rZW49JTdCTEVhcm5IT1d0b0xlQXJuJTdEJmFtcDtpZD03OQ==">https://lidemy-http-challenge.herokuapp.com/lv4?token={LEarnHOWtoLeArn}&amp;id=79<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjU/dG9rZW49JTdCSGFydWtpTXVyYWthbWklN0Q=">https://lidemy-http-challenge.herokuapp.com/lv5?token={HarukiMurakami}<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<h3 id="Lv5"><a href="#Lv5" class="headerlink" title="Lv5"></a>Lv5</h3><ul>
<li>了解如何透過 DELETE 來獲得刪除書籍。</li>
<li>得到的 response 好像讓人有點不安（？）下一題才知道是因為沒有登入就能夠新增刪除，缺少了身分驗證。</li>
</ul>
<pre><code>&#123;
  message: &#39;\n咦...是刪掉了沒錯，但總覺得哪裡怪怪的，算了，先這樣吧！下一關的 token 為 &#123;CHICKENCUTLET&#125;\n&#39;
&#125;</code></pre>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjY/dG9rZW49JTdCQ0hJQ0tFTkNVVExFVCU3RA==">https://lidemy-http-challenge.herokuapp.com/lv6?token={CHICKENCUTLET}<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="Lv6"><a href="#Lv6" class="headerlink" title="Lv6"></a>Lv6</h3><ul>
<li>了解如何將 http basic authorization 帶入 Header 進行身分驗證。</li>
<li>這關有稍微卡住，一開始是驗證碼少加 Basic，然後又卡一陣子找不到錯在哪裡，才發現原來是 圖書館資訊系統 API v2 接點最後有多加 <code>/v2</code>，真是魔鬼藏在細節裡，諸此類小地方都需要更加注意！</li>
</ul>
<pre><code class="js">  method: &#39;GET&#39;,
  url: `https://lidemy-http-challenge.herokuapp.com/api/v2/me`,
  headers: &#123;
    &#39;Authorization&#39;: &#39;Basic YWRtaW46YWRtaW4xMjM=&#39;,
  &#125;,</code></pre>
<ul>
<li><p>得到回應為：<code>&#123; username: &#39;admin&#39;, email: &#39;lib@lidemy.com&#39; &#125;</code></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjY/dG9rZW49JTdCQ0hJQ0tFTkNVVExFVCU3RCZhbXA7dXNlcm5hbWU9YWRtaW4mYW1wO2VtYWlsPWxpYkBsaWRlbXkuY29t">https://lidemy-http-challenge.herokuapp.com/lv6?token={CHICKENCUTLET}&amp;username=admin&amp;email=lib@lidemy.com<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjc/dG9rZW49JTdCU0VDdXJpdHlJc0ltUE9SVGFudCU3RA==">https://lidemy-http-challenge.herokuapp.com/lv7?token={SECurityIsImPORTant}<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<h3 id="Lv7"><a href="#Lv7" class="headerlink" title="Lv7"></a>Lv7</h3><ul>
<li>和 Lv5 類似。了解如何透過 DELETE 刪除書籍，但要在 Header 多加上身分驗證。</li>
</ul>
<pre><code class="js">  method: &#39;DELETE&#39;,
  url: `https://lidemy-http-challenge.herokuapp.com/api/v2/books/89`,
  headers: &#123;
    &#39;Authorization&#39;: &#39;Basic YWRtaW46YWRtaW4xMjM=&#39;,
  &#125;,</code></pre>
<ul>
<li>得到回應為：<code>&#123; message: &#39;\n希望下一次進這本書的時候不會再被偷走了。下一關的 token 為 &#123;HsifnAerok&#125;\n&#39; &#125;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjg/dG9rZW49JTdCSHNpZm5BZXJvayU3RA==">https://lidemy-http-challenge.herokuapp.com/lv8?token={HsifnAerok}<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="Lv8"><a href="#Lv8" class="headerlink" title="Lv8"></a>Lv8</h3><ul>
<li>了解如何透過 GET 查詢書籍，再以 PATCH 更改書籍資訊。</li>
</ul>
<pre><code class="js">  method: &#39;GET&#39;,
  url: `https://lidemy-http-challenge.herokuapp.com/api/v2/books`,
  headers: &#123;
    &#39;Authorization&#39;: &#39;Basic YWRtaW46YWRtaW4xMjM=&#39;,
  &#125;,</code></pre>
<ul>
<li><p>找到與目標相符的資料：<code>&#123;id: 72, name: &#39;日日好日：茶道教我的幸福15味【電影書腰版】&#39;, author: &#39;森下典子&#39;, ISBN: &#39;9981835427&#39;&#125;,</code>，一開始還沒看清楚作者名字是四個字，幸好最後檢查有發現到！</p>
</li>
<li><p>把 ISBN 最後一碼改成 3，和 Lv3 使用的 POST 一樣要在 Header 加上 content type：</p>
</li>
</ul>
<pre><code class="js">  method: &#39;PATCH&#39;,
  url: `https://lidemy-http-challenge.herokuapp.com/api/v2/books/72`,
  headers: &#123;
    &#39;Authorization&#39;: &#39;Basic YWRtaW46YWRtaW4xMjM=&#39;,
    &#39;content-type&#39;: &#39;application/x-www-form-urlencoded&#39;,
  &#125;,
  form: &#123;
    name: &#39;日日好日：茶道教我的幸福15味【電影書腰版】&#39;,
    ISBN: &#39;9981835423&#39;
  &#125;,</code></pre>
<ul>
<li>得到回應為：<code>&#123; message: &#39;\n希望之後他們能引進語音輸入系統，我就只要講講話就好。下一關的 token 為 &#123;NeuN&#125;\n&#39; &#125;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjk/dG9rZW49JTdCTmV1TiU3RA==">https://lidemy-http-challenge.herokuapp.com/lv9?token={NeuN}<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="Lv9"><a href="#Lv9" class="headerlink" title="Lv9"></a>Lv9</h2><ul>
<li>了解如何在 Header 帶上參數 <code>X-Library-Number</code> 和 <code>User-Agent</code>。想到在 Request 補充影片剛好就有提到 <code>User-Agent</code> 的用途，查到了這篇文章：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yODA4NjI1Mg==">談談UserAgent 字符串的規律和偽造方法<i class="fa fa-external-link-alt"></i></span>。</li>
</ul>
<pre><code class="js">  method: &#39;GET&#39;,
  url: `https://lidemy-http-challenge.herokuapp.com/api/v2/sys_info`,
  headers: &#123;
    &#39;Authorization&#39;: &#39;Basic YWRtaW46YWRtaW4xMjM=&#39;,
    &#39;User-Agent&#39;:&#39;MSIE 6.0&#39;,
    &#39;X-Library-Number&#39;: &#39;20&#39;
  &#125;,</code></pre>
<ul>
<li>得到回傳值：</li>
</ul>
<pre><code class="js">&#123;
  message: &#39;success&#39;,
  version: &#39;1A4938Jl7&#39;,
  owner: &#39;lib&#39;,
  createdAt: &#39;121290329301&#39;
&#125;</code></pre>
<ul>
<li><p>把 version 的值放到 query string：<span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjk/dG9rZW49JTdCTmV1TiU3RCZhbXA7dmVyc2lvbj0xQTQ5MzhKbDc=">https://lidemy-http-challenge.herokuapp.com/lv9?token={NeuN}&amp;version=1A4938Jl7<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjEwP3Rva2VuPSU3QmR1WkRzRzN0dm9BJTdE">https://lidemy-http-challenge.herokuapp.com/lv10?token={duZDsG3tvoA}<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<h2 id="Lv10"><a href="#Lv10" class="headerlink" title="Lv10"></a>Lv10</h2><ul>
<li><p>了解如何把數字放在 query string，並且用 num 當作 key 傳入，藉由回傳值判斷是否為目標數字。</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9saWRlbXktaHR0cC1jaGFsbGVuZ2UuaGVyb2t1YXBwLmNvbS9sdjEwP3Rva2VuPSU3QmR1WkRzRzN0dm9BJTdEJmFtcDtudW09OTYxMw==">https://lidemy-http-challenge.herokuapp.com/lv10?token={duZDsG3tvoA}&amp;num=9613<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>這題還蠻快就猜到答案了，自己都有點嚇到XD 想說先判斷出四個對的數字之後再調整位置，能夠迅速解開真是太開心了！</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Lidemy</category>
      </categories>
      <tags>
        <tag>Lidemy</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 13] 前端工具之二 - CSS 預處理器、Babel</title>
    <url>/sass-babel/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUyMDE=">[FE201] 前端中階：那些前端會用到的工具們<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用新工具之前，大致會依照下列步驟：</p>
<ol>
<li>安裝工具</li>
<li>閱讀官方文件</li>
<li>更改設定檔</li>
</ol>
<hr>
<h2 id="SASS：CSS-預處理器"><a href="#SASS：CSS-預處理器" class="headerlink" title="SASS：CSS 預處理器"></a>SASS：CSS 預處理器</h2><p>在進入 CSS 預處理器之前，先談談 CSS 在開發上可能遇到哪些問題：</p>
<ul>
<li>全域會互相干擾<ul>
<li>例如：在 index.html 同時引入 main.css 和 normalize.css 可能會互相干擾，不易進行 debug 與維護</li>
</ul>
</li>
<li>沒有變數<ul>
<li>現在有 CSS Variable</li>
</ul>
</li>
<li>沒有辦法組合</li>
</ul>
<p>因此 CSS 預處理器就誕生了，讓我們能夠以寫程式的方式處理樣式，方便進行維護。</p>
<p><img src="https://i.imgur.com/p8sM9vr.png"></p>
<h3 id="什麼是-SASS？"><a href="#什麼是-SASS？" class="headerlink" title="什麼是 SASS？"></a>什麼是 SASS？</h3><h4 id="SASS（Syntactically-Awesome-Stylesheets）-SCSS"><a href="#SASS（Syntactically-Awesome-Stylesheets）-SCSS" class="headerlink" title="SASS（Syntactically Awesome Stylesheets）/ SCSS"></a><span class="exturl" data-url="aHR0cHM6Ly9zYXNzLWxhbmcuY29tL2luc3RhbGw=">SASS（Syntactically Awesome Stylesheets）/ SCSS<i class="fa fa-external-link-alt"></i></span></h4><ul>
<li>是 CSS 預處理器，能更有結構撰寫程式碼，方便後續維護</li>
<li>適合大型專案使用</li>
<li>SASS 無大括號；SCSS 有，因此後者和 CSS 相容</li>
<li>CSS 預處理器需另外編譯成 CSS，瀏覽器才能看得懂<blockquote>
<p>【註】<span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FzLmNvbS96aF90dy9ob21lLmh0bWw=">SAS（Statistical Analysis System） / SPSS<i class="fa fa-external-link-alt"></i></span>：統計分析系統，用來進行數據分析的軟體</p>
</blockquote>
</li>
</ul>
<h3 id="SASS-提供的功能"><a href="#SASS-提供的功能" class="headerlink" title="SASS 提供的功能"></a>SASS 提供的功能</h3><ul>
<li>參數與結構化 CSS<ul>
<li>Nesting：巢狀語法</li>
<li>Variables：變數設定</li>
</ul>
</li>
<li>模組化 CSS<ul>
<li>Import</li>
<li>Extend</li>
<li>Mixin</li>
<li>Functions</li>
</ul>
</li>
<li>自動化 CSS<ul>
<li>Condition</li>
<li>Loop</li>
</ul>
</li>
</ul>
<h3 id="相關語法"><a href="#相關語法" class="headerlink" title="相關語法"></a>相關語法</h3><ul>
<li>安裝 Sass</li>
</ul>
<p><code>npm install -g sass</code>：<code>-g</code> 表示在全域安裝</p>
<ul>
<li>一次性編譯</li>
</ul>
<p><code>sass main.sass main.css</code>：將 main.sass 檔編譯成 main.css</p>
<ul>
<li>watch 模式</li>
</ul>
<p><code>sass --watch main.sass main.css</code>：每次存檔均會自動進行編譯</p>
<ul>
<li>壓縮功能</li>
</ul>
<p><code>sass --style=compressed mais.sass main.css</code>：通常是在開發最後才會執行</p>
<h2 id="Sass-實作補充"><a href="#Sass-實作補充" class="headerlink" title="Sass 實作補充"></a>Sass 實作補充</h2><p>main.css 通常由下列要素組成：</p>
<ol>
<li>utils：整理出常用的 variables（背景顏色等）和 mixins（垂直至中、對齊等樣式功能）</li>
<li>Components：整理跨頁元件</li>
<li>Layouts：獨立的大元件</li>
<li>Pages</li>
<li>其他樣式：themes（dark mode）、vendors（bootstrap css）</li>
</ol>
<h3 id="巢狀與變數"><a href="#巢狀與變數" class="headerlink" title="巢狀與變數"></a>巢狀與變數</h3><ol>
<li>巢狀語法：注意 <code>&amp;</code> 前的空格</li>
</ol>
<pre><code class="sass=">.section
  width: 100%
  height: 50%
  border-bottom: 1px solid #000
  padding: 2rem
  &amp;__title
    text-align: center
  &amp;__wrapper
    display: flex
    justify-content: center
    align-items: center</code></pre>
<p>編譯結果：</p>
<pre><code class="css=">.section &#123;
  width: 100%;
  height: 50%;
  border-bottom: 1px solid #000;
  padding: 2rem;
&#125;
.section__title &#123;
  text-align: center;
&#125;
.section__wrapper &#123;
  display: flex;
  justify-content: center;
  align-items: center;
&#125;

/*# sourceMappingURL=main.css.map */</code></pre>
<ol start="2">
<li>變數設定：使用 <code>$</code> 來命名</li>
</ol>
<pre><code class="sass=">$primary: #0047AB
$secondary: #4D80E6
$warning: #CD5C5C
$text:#CCCCFF
$background: #eeeeee

.color
  width: 50px
  height: 50px
  margin: 10px
  background: #000
  &amp;-primary
    background: $primary
  &amp;-secondary
    background: $secondary
  &amp;-warning
    background: $warning
  &amp;-text
    background: $text
  &amp;-background
    background: $background</code></pre>
<p>編譯結果：</p>
<pre><code class="css=">.color &#123;
  width: 50px;
  height: 50px;
  margin: 10px;
  background: #000;
&#125;
.color-primary &#123;
  background: #0047AB;
&#125;
.color-secondary &#123;
  background: #4D80E6;
&#125;
.color-warning &#123;
  background: #CD5C5C;
&#125;
.color-text &#123;
  background: #CCCCFF;
&#125;
.color-background &#123;
  background: #eeeeee;
&#125;

/*# sourceMappingURL=main.css.map */</code></pre>
<h3 id="模組化-CSS"><a href="#模組化-CSS" class="headerlink" title="模組化 CSS"></a>模組化 CSS</h3><h4 id="import：引入檔案，用來分別進行管理"><a href="#import：引入檔案，用來分別進行管理" class="headerlink" title="@import：引入檔案，用來分別進行管理"></a><code>@import</code>：引入檔案，用來分別進行管理</h4><ul>
<li>例如：將變數放到 <code>_variables.sass</code> 統一管理，然後在 <code>main.sass</code> 加上 <code>@import _variables.sass</code> 即可引入檔案</li>
</ul>
<h4 id="export：繼承，處理共同樣式"><a href="#export：繼承，處理共同樣式" class="headerlink" title="export：繼承，處理共同樣式"></a><code>export</code>：繼承，處理共同樣式</h4><ul>
<li>使用時機：可將所有相同樣式的內容合併，減少重複的行為</li>
<li>例如：<code>&lt;a&gt;</code> 統一去除底線、制定 template<pre><code class="sass=">%btn
padding: 1rem 2rem
color: $background
font-size: 1rem
margin: 1rem
transition: .1s
</code></pre>
</li>
</ul>
<p>.btn<br>  &amp;-primary<br>    @extend %btn<br>  &amp;-secondary<br>    @extend %btn<br>  &amp;-waring<br>    @extend %btn</p>
<pre><code>
編譯結果：

```css=
.btn-waring, .btn-secondary, .btn-primary &#123;
  padding: 1rem 2rem;
  color: #eeeeee;
  font-size: 1rem;
  margin: 1rem;
  transition: 0.1s;
&#125;</code></pre>
<h4 id="mixin：打包常用功能，替換局部變數"><a href="#mixin：打包常用功能，替換局部變數" class="headerlink" title="mixin：打包常用功能，替換局部變數"></a><code>mixin</code>：打包常用功能，替換局部變數</h4><ul>
<li>使用時機：用於需重複使用到的屬性，且可帶入變數，以進行微調</li>
<li>例如：width、height、flex-center 等</li>
</ul>
<pre><code class="sass=">@mixin btn
  padding: 1rem 2rem
  color: $background
  font-size: 1rem
  margin: 1rem
  transition: .1s

.btn
  &amp;-primary
    +btn
  &amp;-secondary
    +btn
  &amp;-waring
    +btn</code></pre>
<p>編譯結果：</p>
<pre><code class="css=">.btn-primary &#123;
  padding: 1rem 2rem;
  color: #eeeeee;
  font-size: 1rem;
  margin: 1rem;
  transition: 0.1s;
&#125;
.btn-secondary &#123;
  padding: 1rem 2rem;
  color: #eeeeee;
  font-size: 1rem;
  margin: 1rem;
  transition: 0.1s;
&#125;
.btn-waring &#123;
  padding: 1rem 2rem;
  color: #eeeeee;
  font-size: 1rem;
  margin: 1rem;
  transition: 0.1s;
&#125;</code></pre>
<h4 id="function：可回傳數值，搭配變數和-mixin-使用"><a href="#function：可回傳數值，搭配變數和-mixin-使用" class="headerlink" title="function：可回傳數值，搭配變數和 mixin 使用"></a><code>function</code>：可回傳數值，搭配變數和 mixin 使用</h4><ul>
<li>與 <code>@mixin</code> 的不同之處，在於 <code>@function</code> 只會回傳一個值，而 <code>@mixin</code> 是回傳一段CSS程式碼</li>
</ul>
<h3 id="Sass-自動化"><a href="#Sass-自動化" class="headerlink" title="Sass 自動化"></a>Sass 自動化</h3><h4 id="loop-迴圈"><a href="#loop-迴圈" class="headerlink" title="loop 迴圈"></a>loop 迴圈</h4><ul>
<li>使用 <code>@each</code> 搭配 array<ul>
<li>以逗號表示 <code>center, start, end</code></li>
</ul>
</li>
</ul>
<pre><code class="sass=">$direction-typs: center, start, end

@each $type in $direction-typs
  .flex-#&#123;$type&#125;
    display: flex
    justify-content: $type
    align-items: center</code></pre>
<p>編譯結果：</p>
<pre><code class="css=">.flex-center &#123;
  display: flex;
  justify-content: center;
  align-items: center;
&#125;

.flex-start &#123;
  display: flex;
  justify-content: start;
  align-items: center;
&#125;

.flex-end &#123;
  display: flex;
  justify-content: end;
  align-items: center;
&#125;</code></pre>
<ul>
<li>使用 <code>@each</code> 搭配 map<ul>
<li>在括號以 <code>參數:值</code> 表示 <code>(center: center, start: flex-start, end: flex-end)</code></li>
</ul>
</li>
</ul>
<pre><code class="sass=">$direction-typs: (center: center, start: flex-start, end: flex-end)

@each $type, $value in $direction-typs
  .flex-#&#123;$type&#125;
    display: flex
    justify-content: $value
    align-items: center</code></pre>
<p>編譯結果：</p>
<pre><code class="css=">.flex-center &#123;
  display: flex;
  justify-content: center;
  align-items: center;
&#125;

.flex-start &#123;
  display: flex;
  justify-content: flex-start;
  align-items: center;
&#125;

.flex-end &#123;
  display: flex;
  justify-content: flex-end;
  align-items: center;
&#125;</code></pre>
<ul>
<li>for 迴圈<ul>
<li>使用時機：用於預先設定，或特效網站需產生密集大小值<pre><code class="sass=">@for $i from 0 through 5
.h#&#123;5 - $i + 1&#125;
    font-size: 1 + 0.2rem * $i</code></pre>
</li>
</ul>
</li>
</ul>
<p>編譯結果：</p>
<pre><code class="css=">.h6 &#123;
  font-size: 1rem;
&#125;

.h5 &#123;
  font-size: 1.2rem;
&#125;

.h4 &#123;
  font-size: 1.4rem;
&#125;

.h3 &#123;
  font-size: 1.6rem;
&#125;

.h2 &#123;
  font-size: 1.8rem;
&#125;

.h1 &#123;
  font-size: 2rem;
&#125;</code></pre>
<h4 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h4><p>有關 Flow Control 可參考<span class="exturl" data-url="aHR0cHM6Ly9zYXNzLWxhbmcuY29tL2RvY3VtZW50YXRpb24vYXQtcnVsZXMvY29udHJvbC9mb3I=">官方文件<i class="fa fa-external-link-alt"></i></span>。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90dy5hbHBoYWNhbXAuY28vYmxvZy9jc3MtcHJlcHJvY2Vzc29yLXNhc3Mtc2Nzcw==">Sass/SCSS 基本語法介紹，搞懂CSS 預處理器<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5lYmFvbW9udGhseS5jb20vd2luZG93L3Bob3RvL2xlc3Nvbi9jb2xvckxpc3QuaHRt">常用色彩表<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pY2d1YW55dS5naXRodWIuaW8vc2Nzcy9zY3NzXzIv">SCSS 筆記(2) - extend、mixin、function<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="重構檔案流程"><a href="#重構檔案流程" class="headerlink" title="重構檔案流程"></a>重構檔案流程</h3><ul>
<li>步驟一：將重複的部分用巢狀方式撰寫</li>
<li>步驟二：將顏色、字體大小，統一使用變數命名 <code>_variables.sass</code></li>
<li>步驟三：抽檔案，把重複的區塊放到 <code>_components.sass</code></li>
<li>步驟四：將分出的區塊以 <code>@import</code> 引入，完成後將所有檔案打包</li>
</ul>
<hr>
<h2 id="BABEL：JS-轉譯器"><a href="#BABEL：JS-轉譯器" class="headerlink" title="BABEL：JS 轉譯器"></a>BABEL：JS 轉譯器</h2><p><span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvLw==">BABEL<i class="fa fa-external-link-alt"></i></span> 是 JavaScript 轉譯器，可將 ES6+ 程式碼轉為等效的 ES5 程式碼。</p>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly9taWNoYWVsY2hlbi50ZWNoL2phdmFzY3JpcHQtcHJvZ3JhbW1pbmcvYmFiZWwv">利用 Babel 支援現代 JavaScript 的特性<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>Front-End</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 14] 網站部署 - 設定 AWS EC2 遠端主機 +  Ubuntu LAMP 環境 + phpMyAdmin</title>
    <url>/backend-aws-ubuntu/</url>
    <content><![CDATA[<p>在練習這週的網站部署時，主要參考下列幾篇筆記：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tdHIwNC1ub3RlLmNvZGVyYnJpZGdlLmlvLzIwMjAvMDkvMTUvLSVFNyVCNCU4MCVFOSU4QyU4NC0lMDgtJUU5JTgzJUE4JUU1JUIxJUFDLWF3cy1lYzItJUU5JTlCJUIyJUU3JUFCJUFGJUU0JUI4JUJCJUU2JUE5JTlGLS8=">[ 紀錄 ] 部屬 AWS EC2 雲端主機 + LAMP Server + phpMyAdmin<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9uaWNvbGFrYWNoYS5jb2RlcmJyaWRnZS5pby8yMDIwLzA5LzE2L2xhdW5jaC13ZWJzaXRlLw==">AWS EC2 佈署網站：卡關記錄 &amp; 心得<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpZGVteS9tZW50b3ItcHJvZ3JhbS0ybmQteXVjaHVuMzMvaXNzdWVzLzE1">部署 AWS EC2 遠端主機 + Ubuntu LAMP 環境 + phpmyadmin<i class="fa fa-external-link-alt"></i></span><a id="more"></a>
</li>
</ul>
<hr>
<h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><p>網站部署大致可分為下列幾個步驟：</p>
<ol>
<li>設定 AWS EC2 主機<ul>
<li>註冊 AWS 會員</li>
<li>架設遠端主機 EC2 </li>
<li>選擇 Ubuntu Server 並完成設定</li>
<li>儲存私鑰後運行主機</li>
<li>以 CLI 輸入指令連線主機</li>
</ul>
</li>
<li>更新 Ubuntu Server</li>
<li>設定 LAMP Server<ul>
<li>安裝 Tasksel</li>
<li>以 Tasksel 套件來安裝 lamp-server</li>
</ul>
</li>
<li>設定 phpMyAdmin<ul>
<li>安裝 phpmyadmin</li>
<li>設定使用者密碼</li>
<li>修改 MySQL 登入設定</li>
<li>設定 MySQL 的 root password</li>
</ul>
</li>
<li>設定域名</li>
<li>部署寫好的程式到 Server<ul>
<li>利用 git clone 上傳檔案</li>
<li>設定 FileZilla 上傳檔案</li>
</ul>
</li>
</ol>
<hr>
<h2 id="設定-AWS-EC2-主機"><a href="#設定-AWS-EC2-主機" class="headerlink" title="設定 AWS EC2 主機"></a>設定 AWS EC2 主機</h2><p><img src="https://i.imgur.com/BY8vzW5.png"></p>
<ol>
<li>註冊 AWS 會員</li>
<li>進入 AWS 管理控制台，右上方的選單可以選擇架設主機的地區（離所在地越近主機速度越快，但相對之下價格也會比較貴）</li>
</ol>
<p><img src="https://i.imgur.com/dKkK0oF.png"></p>
<ol start="3">
<li>啟動虛擬機器 - 使用 EC2</li>
</ol>
<p><img src="https://i.imgur.com/PPo4YVf.png"></p>
<ol start="4">
<li>選擇主機 Image 方案：找到「Ubuntu Server 18.04 LTS (HVM), SSD Volume Type」並點選 Select</li>
</ol>
<blockquote>
<p>Ubuntu 是基於 Debian 的 Linux 發行版，是個免費開源的作業系統。Ubuntu Server 版是為執行伺服端的應用程式而設計的伺服器版本。</p>
</blockquote>
<p><img src="https://i.imgur.com/wFjYN6H.png"></p>
<ol start="5">
<li>選擇主機等級：選有綠色標籤的免費方案，按右下角的 Next，一直到 Step6</li>
</ol>
<p><img src="https://i.imgur.com/p7ylYvJ.png"></p>
<ol start="6">
<li>設定防火牆：也就是允許哪些 IP 連線。點選「Add Rule」新增欄位，共需新增兩個，分別是「HTTP 跟 HTTPS」，後面的資料會自動帶入（例如 port 80 和 port 443）</li>
</ol>
<p><img src="https://i.imgur.com/2rEWA1g.png"></p>
<ol start="7">
<li>接著點選「Review and Launch」，進入下一步</li>
<li>確認設定都沒問題後，點選 Launch</li>
<li>再來是選擇私鑰，第一格選擇「Create a new key pair」，第二格輸入私鑰名稱，填好後點選右下角儲存私鑰檔案</li>
</ol>
<p><img src="https://i.imgur.com/P7bVck5.png"></p>
<ol start="10">
<li>下載後點選「Launch Instances」啟動設置</li>
<li>確認 Server 有在運行，並記下 IPv4 Public IP（公有 IPv4 地址）</li>
</ol>
<p><img src="https://i.imgur.com/3vlSClN.png"></p>
<ol start="12">
<li>接著點選上方的「連線」，會進入以下頁面</li>
</ol>
<p><img src="https://i.imgur.com/nPl6WqE.png"></p>
<ol start="13">
<li>依照說明，在 CLI 輸入下列指令來連線</li>
</ol>
<pre><code class="=">$ chmod 400 &lt;私鑰檔案路徑&gt;

$ ssh -i &quot;&lt;私鑰檔案路徑&gt;&quot; ubuntu@ec2-&lt; IPv4 位置&gt;.us-east-2.compute.amazonaws.com</code></pre>
<hr>
<h2 id="實用指令"><a href="#實用指令" class="headerlink" title="實用指令"></a>實用指令</h2><h3 id="更新-Ubuntu-Server"><a href="#更新-Ubuntu-Server" class="headerlink" title="更新 Ubuntu Server"></a>更新 Ubuntu Server</h3><p>安裝好 Ubuntu Server 後，需要把更新系統版本到最新，避免遇到安全性漏洞以及程式的 BUG。</p>
<p>CLI 指令如下，其中 apt 是用來管理 ubuntu 軟體的程式（可想像成 <code>npm install</code>）：</p>
<pre><code class="=">$ sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt dist-upgrade</code></pre>
<h3 id="top：查看主機即時資訊"><a href="#top：查看主機即時資訊" class="headerlink" title="top：查看主機即時資訊"></a><code>top</code>：查看主機即時資訊</h3><p>會進去下方介面，可查看有哪些 process 在運行、或占用多少 Memory等等。點選 Q 鍵可離開。</p>
<p><img src="https://i.imgur.com/zgZtaUB.png"></p>
<h3 id="exit：結束連線狀態"><a href="#exit：結束連線狀態" class="headerlink" title="exit：結束連線狀態"></a><code>exit</code>：結束連線狀態</h3><p>輸入 <code>exit</code> 後就會直接登出，回到本地端。</p>
<p>這個指令雖然很基本，自己一開始卻沒有想到，反而還會重開 bash 或等它自動斷線XD<br>此外，bash 可以同時開啟多個視窗，所以是可以分別對本機和遠端主機下指令的。</p>
<hr>
<h2 id="設定-LAMP-Server"><a href="#設定-LAMP-Server" class="headerlink" title="設定 LAMP Server"></a>設定 LAMP Server</h2><h3 id="什麼是-LAMP？"><a href="#什麼是-LAMP？" class="headerlink" title="什麼是 LAMP？"></a>什麼是 LAMP？</h3><p>LAMP 是 Linux 系統上的開源架站組合，縮寫分別代表：</p>
<ul>
<li>L：Linux 作業系統</li>
<li>A：Apache 網頁伺服器</li>
<li>M：MySQL 資料庫</li>
<li>P：PHP 程式語言</li>
</ul>
<h3 id="LAMP-設定步驟"><a href="#LAMP-設定步驟" class="headerlink" title="LAMP 設定步驟"></a>LAMP 設定步驟</h3><ol>
<li>安裝 Tasksel 套件：使用 Tasksel 能快速配置 LAMP 環境</li>
</ol>
<pre><code class="=">$ sudo apt install tasksel</code></pre>
<blockquote>
<p>跳出訊息「安裝會佔用 XX 空間，是否繼續安裝？(Y/n)」，輸入 Y。</p>
</blockquote>
<ol start="2">
<li>使用 Tasksel 下載 lamp-server</li>
</ol>
<pre><code class="=">$ sudo tasksel install lamp-server</code></pre>
<p>會進入紫色的下載畫面：</p>
<p><img src="https://i.imgur.com/S5t6yOa.png"></p>
<ol start="3">
<li>接著確認伺服器是否有成功運行，在瀏覽器輸入剛剛記下伺服器的 IPv4 IP 位置，若看到下方預設網頁就代表安裝成功！</li>
</ol>
<p><img src="https://i.imgur.com/ednoBoi.png"></p>
<ul>
<li>也可利用 <code>telnet &lt;IP 位置&gt; &lt;port&gt;</code> 指令，檢視這個埠是否可使用，出現 Connected 就代表成功：</li>
</ul>
<p><img src="https://i.imgur.com/GRUQNVb.png"></p>
<hr>
<h2 id="設定-phpmyadmin"><a href="#設定-phpmyadmin" class="headerlink" title="設定 phpmyadmin"></a>設定 phpmyadmin</h2><p>phpMyAdmin 是以 PHP 為基礎的資料庫管理工具，讓使用者能夠以 Web 介面管理 MySQL 資料庫。</p>
<h3 id="phpmyadmin-設定步驟"><a href="#phpmyadmin-設定步驟" class="headerlink" title="phpmyadmin 設定步驟"></a>phpmyadmin 設定步驟</h3><ol>
<li>安裝 phpmyadmin</li>
</ol>
<pre><code class="=">$ sudo apt install phpmyadmin</code></pre>
<blockquote>
<p>跳出訊息「安裝會佔用 XX 空間，是否繼續安裝？(Y/n)」，輸入 Y。</p>
</blockquote>
<ol start="2">
<li>進入紫色畫面，選擇連接的網頁伺服器。用空白鍵選 apache2，再按 Enter 確定</li>
</ol>
<p><img src="https://i.imgur.com/arKzEgG.png"></p>
<ol start="3">
<li>是否設定 dbconfig-common？選 <code>&lt;Yes&gt;</code></li>
</ol>
<blockquote>
<p>此處將會建立一個帳號來管理 phpMyAdmin 運行時用到的資料表，使用者名稱預設為 phpmyadmin，接著要設定這個使用者密碼。</p>
</blockquote>
<p><img src="https://i.imgur.com/bXr9daY.png"></p>
<ol start="4">
<li>設定使用者密碼，輸入完成後按向下鍵選 <code>&lt;OK&gt;</code></li>
</ol>
<p><img src="https://i.imgur.com/LwCsRoT.png"></p>
<ol start="5">
<li>再確認一次密碼，輸入完選 <code>&lt;OK&gt;</code>，即完成設置</li>
</ol>
<h3 id="修改-MySQL-登入設定"><a href="#修改-MySQL-登入設定" class="headerlink" title="修改 MySQL 登入設定"></a>修改 MySQL 登入設定</h3><p>設置完 phpMyAdmin 之後，接著要設定 MySQL 的 root 使用者，建立超級使用者（Superuser）以便在 phpMyAdmin 中進行管理。</p>
<p>也就是說，使用者必須登入後，才能夠實際對資料庫進行增刪改查等動作，並且也可透過 phpMyAdmin 圖形化介面直接操作資料庫。</p>
<p>由於 MySQL 預設使用 auth_socket 的驗證 plugin，使用者可以透過 sudo 直接登入 root 帳號。但這樣就無法透過 phpMyAdmin 登入圖形化介面，因為 phpMyAdmin 預設需要密碼登入。</p>
<p><img src="https://i.imgur.com/b7jTMwy.png"></p>
<p>我們可按照下列步驟來設定 root 密碼：</p>
<ol>
<li>修改 MySQL 登入設定，改成使用密碼登入</li>
</ol>
<pre><code class="=">$ sudo mysql -u root mysql</code></pre>
<ol start="2">
<li>輸入 mysql 指令，啟用設定密碼</li>
</ol>
<ul>
<li>讓 root 帳號啟用設定密碼的插件</li>
</ul>
<pre><code class="sql=">mysql&gt; UPDATE user SET plugin=&#39;mysql_native_password&#39; WHERE User=&#39;root&#39;;</code></pre>
<ul>
<li>輸入指令重新載入特權表</li>
</ul>
<pre><code class="sql=">mysql&gt; FLUSH PRIVILEGES;</code></pre>
<ul>
<li>退出 mysql 指令</li>
</ul>
<pre><code class="sql=">mysql&gt; exit</code></pre>
<p><img src="https://i.imgur.com/TDNKk10.png"></p>
<ol start="3">
<li>設定 MySQL 的 root password</li>
</ol>
<pre><code class="=">$ sudo mysql_secure_installation</code></pre>
<ol start="4">
<li>是否設定密碼？輸入 <code>$ y</code>，開啟 VALIDATE PASSWORD 插件</li>
<li>選擇密碼強度，除非需要非常注重安全性，這裡可輸入 0</li>
</ol>
<blockquote>
<p>選 1 以上要中英文大小寫 + 符號混用 + 一定長度，複雜性較高。</p>
</blockquote>
<p><img src="https://i.imgur.com/8dkOixk.png"></p>
<ol start="6">
<li>設置密碼，需注意這裡輸入密碼不會顯示，確定設置這個密碼嗎？輸入 <code>y</code></li>
</ol>
<p><img src="https://i.imgur.com/7DXZilL.png"></p>
<ol start="7">
<li>以下詢問皆輸入 <code>y</code></li>
</ol>
<ul>
<li>Remove anonymous users?</li>
<li>Disallow root login remotely?</li>
<li>Remove test database and access to it?</li>
<li>Reload privilege tables now?</li>
</ul>
<ol start="8">
<li>最後出現 All Done! 代表設置完成</li>
</ol>
<p><img src="https://i.imgur.com/QpHqCtN.png"></p>
<ol start="9">
<li>接著在瀏覽器輸入 <code>&lt;IPv4 地址&gt;/phpmyadmin</code>，會看到 phpmyadmin 的登入畫面，輸入帳密確認是否能夠登入</li>
</ol>
<ul>
<li>帳號：root</li>
<li>密碼：<code>&lt;步驟 6 設定的 root 密碼&gt;</code></li>
</ul>
<h3 id="修正-MySQL-錯誤"><a href="#修正-MySQL-錯誤" class="headerlink" title="修正 MySQL 錯誤"></a>修正 MySQL 錯誤</h3><p>順利以 root 帳密登入 phpmyadmin 後，會發現有個問題，當我們想查看任一個資料庫的資料表，或是想要執行匯入匯出功能時，會跳出下列錯誤訊息：</p>
<pre><code class="sql=">Warning in ./libraries/plugin_interface.lib.php#551
 count(): Parameter must be an array or an object that implements Countable</code></pre>
<p><img src="https://i.imgur.com/wqqSslF.png"></p>
<p>原因是在 php 7.2 版本後，<code>count()</code> 在沒有添加參數的情形下，會噴出 Warning 警告訊息。這部分需要我們手動解決。其中有兩個部分需利用 vim 編輯器修改：</p>
<blockquote>
<p>vim 指令：編輯完成後，按 esc 再輸入 <code>:wq</code> 即可儲存後退出 vim 編輯器。</p>
</blockquote>
<ol>
<li>修改 Warning in ./libraries/plugin_interface.lib.php#551：</li>
</ol>
<pre><code class="=">$ sudo vim /usr/share/phpmyadmin/libraries/plugin_interface.lib.php</code></pre>
<p>將第 551 行的 <code>count($options) &gt; 0</code> 去掉，修改後如下：</p>
<blockquote>
<p>小技巧：可使用 PgDn 按鍵快速往下，不用一行一行往下滑XD</p>
</blockquote>
<pre><code class="php=">if ($options != null ) &#123;
    // …
&#125;</code></pre>
<ol start="2">
<li>修改 Warning in ./libraries/sql.lib.php#613：</li>
</ol>
<pre><code class="=">$ sudo vim /usr/share/phpmyadmin/libraries/sql.lib.php</code></pre>
<p>將第 613 行修改成換成下列判斷式：</p>
<pre><code class="php=">|| ((count($analyzed_sql_results[&#39;select_expr&#39;]) == 1)</code></pre>
<p>完成以上步驟後，就可以正常操作 phpmyadmin 了！</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIxNjgxNQ==">Day 03 : 環境架設 part II – MySQL &amp; phpMyAdmin<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYWdpY2xlbi5vcmcvdWJ1bnR1LXNlcnZlci0xOC0wNC8=">如何安裝Ubuntu Server 18.04來架設伺服器？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYWdpY2xlbi5vcmcvbGFtcC8=">安裝 LAMP Server + phpMyAdmin 在 Linux 系統上輕鬆架設網站<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYWdpY2xlbi5vcmcvdWJ1bnR1LXNlcnZlci1teXNxbC1waHAv">使用Ubuntu Server架設MySQL伺服器，並於PHP程式中存取MySQL資料庫<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h3 id="修改-MySQL-帳號設定"><a href="#修改-MySQL-帳號設定" class="headerlink" title="修改 MySQL 帳號設定"></a>修改 MySQL 帳號設定</h3><p>此外，若想要使用 phpmyadmin 以外的圖形化界面操作資料庫（例如：<span class="exturl" data-url="aHR0cHM6Ly93d3cuc2VxdWVscHJvLmNvbS8=">Sequel Pro<i class="fa fa-external-link-alt"></i></span>），可能會有無法連線的問題，因為預設只能從本機登入 MySQL，因此我們需要修改一些設定，步驟如下：</p>
<ol>
<li><p>到 phpmyadmin 使用者帳號的介面，點選 root 帳號的「編輯權限」後，會進入編輯權限介面：</p>
</li>
<li><p>點選上方的「登入資訊」，在修改登入的主機名稱，改成任意主機，符號會變成 <code>&amp;</code></p>
</li>
</ol>
<p><img src="https://i.imgur.com/Kd6FQxB.png"></p>
<ol start="3">
<li>回到帳號介面，會發現多了一組 root 帳號如下，這樣就完成設定了！可使用 phpmyadmin 以外的軟體來連到遠端組機</li>
</ol>
<p><img src="https://i.imgur.com/EzcFjgw.png"></p>
<hr>
<h2 id="設定域名"><a href="#設定域名" class="headerlink" title="設定域名"></a>設定域名</h2><p><img src="https://i.imgur.com/hBbMxyF.png"></p>
<ol>
<li>先在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2FuZGkubmV0L3poLUhhbnQ=">gandi.net<i class="fa fa-external-link-alt"></i></span> 註冊帳號</li>
<li>到電子信箱收驗證信</li>
<li>進入域名頁面，輸入想要的網域名稱後，再按購買</li>
</ol>
<p><img src="https://i.imgur.com/jBsFzWE.png"></p>
<ol start="4">
<li>會跳轉到註冊網域名稱的頁面，下面會有搜尋結果能夠選擇加入購物車</li>
</ol>
<p><img src="https://i.imgur.com/5rjovGd.png"></p>
<ol start="5">
<li>填寫購買資訊，同意相關合約</li>
</ol>
<p><img src="https://i.imgur.com/YDjIGND.png"></p>
<ol start="6">
<li>再結帳前可在步驟 2 最下方填入優惠代碼</li>
<li>購買完成！要記得收取確認信</li>
</ol>
<p><img src="https://i.imgur.com/YJtThnL.png"></p>
<ol start="8">
<li>到域名頁面，點選剛剛註冊好的域名</li>
</ol>
<p><img src="https://i.imgur.com/T0SX6D6.png"></p>
<ol start="9">
<li>點選區域檔記錄，將 A 的值修改成 AWS 主機的 IPv4 地址</li>
</ol>
<p><img src="https://i.imgur.com/NgRKfZN.png"></p>
<ol start="10">
<li>在瀏覽器輸入 <code>&lt;你的域名&gt;</code>，如果有出現和先前一樣的 Apache2 Ubuntu 預設頁面，就代表部署成功！</li>
</ol>
<hr>
<h2 id="部署寫好的程式到-Server"><a href="#部署寫好的程式到-Server" class="headerlink" title="部署寫好的程式到 Server"></a>部署寫好的程式到 Server</h2><ol>
<li>首先確定有連線到 Server，也就是前面提到的這段指令：</li>
</ol>
<pre><code class="=">$ chmod 400 &lt;私鑰檔案路徑&gt;

$ ssh -i &quot;&lt;私鑰檔案路徑&gt;&quot; ubuntu@ec2-&lt; IPv4 位置&gt;.us-east-2.compute.amazonaws.com</code></pre>
<ol start="2">
<li>輸入 <code>cd ..</code> 兩次，回到根目錄底下</li>
<li>輸入 <code>ls</code> 找到 var 資料夾</li>
</ol>
<p><img src="https://i.imgur.com/mErapfq.png"></p>
<ol start="4">
<li>輸入 <code>cd var/www/html</code>，會進到預設的 apache 首頁所在目錄，也就是我們剛才連到的域名頁面</li>
<li>這時若想在該目錄新增檔案，會發現權限不夠</li>
</ol>
<p><img src="https://i.imgur.com/XQh7p9v.png"></p>
<ol start="6">
<li>這時可以輸入 <code>cd ..</code> 回到 <code>/var/www</code> 目錄，再輸入 <code>ls -al</code> 可知目前只有 root 帳號有編輯權限：</li>
</ol>
<p><img src="https://i.imgur.com/MJ6kZw7.png"></p>
<ol start="7">
<li>因此我們要透過 <code>chown</code> 指令來修改 ubuntu 帳號的檔案權限：</li>
</ol>
<blockquote>
<ul>
<li><code>chown（change owner）</code>：改變檔案擁有者 = 定義誰擁有文件。</li>
<li><code>chmod（change mode）</code>：改變檔案的權限 = 定義誰可以做什麽。</li>
</ul>
</blockquote>
<pre><code class="=">$ sudo chown ubuntu /var/www/html</code></pre>
<ol start="8">
<li>修改完成後即可在 <code>var/www/html</code> 目錄新增檔案！這時再以 <code>la -al</code> 檢視，會發現變成 ubuntu 擁有權限：</li>
</ol>
<p><img src="https://i.imgur.com/uG4D3Ee.png"></p>
<h3 id="利用-git-clone-上傳專案"><a href="#利用-git-clone-上傳專案" class="headerlink" title="利用 git clone 上傳專案"></a>利用 git clone 上傳專案</h3><p>以上傳 GitHub repository 為例：</p>
<ol>
<li>在 CLI 輸入 <code>git clone &lt;GitHub 專案網址&gt;</code></li>
<li>到瀏覽器輸入 <code>域名/對應路徑/檔案名稱</code>，確認是否有成功把檔案放上去</li>
</ol>
<h3 id="FileZilla-設定"><a href="#FileZilla-設定" class="headerlink" title="FileZilla 設定"></a>FileZilla 設定</h3><p>除了使用 CLI 操作，我們還可以透過設定 FileZilla，以 key-pairs 登入 AWS EC2 來存取檔案，如此一來即可直接在圖形化界面進行操作。</p>
<p>設定步驟如下：</p>
<ol>
<li>在 FileZilla 新增站台</li>
</ol>
<ul>
<li>選擇 SFTP 協定</li>
<li>主機輸入 AWS 的 IP 位置</li>
<li>登入型式選擇「金鑰檔案」，也就是設定主機時的那個 <code>.pem</code> 檔案</li>
</ul>
<p><img src="https://i.imgur.com/CSlkeAp.png"></p>
<ol start="2">
<li>設定完成後點選連線，會進入 <code>/home/ubuntu</code> 目錄</li>
<li>回到根目錄，進到 <code>var/www/html</code>，會看到 apache 的預設首頁 index.html 檔</li>
</ol>
<p><img src="https://i.imgur.com/MqTnOwv.png"></p>
<ol start="4">
<li>接著就可以放上寫好的程式</li>
<li>在瀏覽器輸入 <code>&lt;網域名稱/路徑&gt;</code>，確認是否有部署成功</li>
</ol>
<h3 id="修改-conn-php"><a href="#修改-conn-php" class="headerlink" title="修改 conn.php"></a>修改 <code>conn.php</code></h3><p>如果是部署動態網站，需要連線到遠端資料庫，那就需要修改 <code>conn.php</code> 連線資料庫需要的資料，也就是修改成剛剛設定的 root 帳密：</p>
<pre><code>$server_name = &#39;localhost&#39;;
$username = &#39;root&#39;;
$password = &#39;&lt;root 密碼&gt;&#39;;
$db_name = &#39;&lt;資料庫名稱&gt;&#39;;</code></pre>
<hr>
<h2 id="部署心得"><a href="#部署心得" class="headerlink" title="部署心得"></a>部署心得</h2><p>終於來到一直很期待的網站部署，想起之前隨意聊就有提過，完成十四週能夠架一個自己的網站，擁有屬於自己的網域，可以帥氣的和朋友分享自己做出的網站了！和助教索取折扣碼的當下，竟然莫名有點感動QQ</p>
<p>發現自己終於走到課程的一半，雖然後面還有一段路要走，但也在過程中體會到，自己很喜歡在寫程式這件事中獲得的成就感。好像有點扯遠了，回到這禮拜的部署心得XD</p>
<p>主要是參考幾位同學的筆記，還有一些網路上的資料，跟著步驟一步步進行部署前的設定。其實筆記中步驟都已經整理得很清楚，自己只是跟隨前人的腳步去操作，也因此少繞了很多遠路，很佩服從零開始摸索的學長姐們，感謝萬分。</p>
<p>但過程中也有遇到一些不懂的部分，還是想要去理解每個步驟的意義是什麼，就花了點時間去查找資料，例如：</p>
<ul>
<li>為什麼選擇用 Ubuntu Server？</li>
</ul>
<p>Ubuntu Server 是為執行伺服端的應用程式而設計的伺服器版本。簡言之，就是專門用來架設伺服器。</p>
<ul>
<li>為什麼要安裝 Tasksel 套件？</li>
</ul>
<p>能夠使用 Tasksel 安裝 LAMP，快速配置 LAMP 環境。</p>
<ul>
<li>什麼是 LAMP Server？</li>
</ul>
<p>是 Linux 系統上的開源架站組合，縮寫代表：Linux + Apache + Mysql + PHP。</p>
<ul>
<li>還有在 phpmyadmin 設定 dbconfig-common 時，會建立一個帳號來管理 phpMyAdmin 運行時用到的資料表，使用者名稱預設為 phpmyadmin。</li>
<li>這和之後設定 MySQL 的 root（超級使用者）其實對象不同，一開始有困惑說為什麼要設定兩次密碼，root 這組帳號可用來登入 phpMyAdmin，能夠在圖形化界面管理資料庫。</li>
</ul>
<h3 id="待解決問題"><a href="#待解決問題" class="headerlink" title="待解決問題"></a>待解決問題</h3><p>上傳 Markdown 檔案時，發現中文部分會有亂碼問題，有查到幾個解決方法，但覺得好像在這花有點多時間，決定之後再參來考方法三來解決：</p>
<ol>
<li>安裝 apache-mod-markdown 套件</li>
</ol>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzI1OTczMTYvc2VydmluZy1tYXJrZG93bi1mcm9tLWFwYWNoZS0yLTQtNy1vbi11YnVudHU=">Serving markdown from Apache 2.4.7 on Ubuntu<i class="fa fa-external-link-alt"></i></span>：安裝完套件後在第二步卡住，不是很明白要怎麼建立模組？</li>
</ul>
<ol start="2">
<li>把 markdown 檔案轉成 html 檔</li>
</ol>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRyZWFkMDEuY29tL2NvbnRlbnQvMTU0Njc4MzkzNy5odG1s">markdown在ubuntu上的使用<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<ol start="3">
<li>安裝 hexo 這個框架，能夠支援 Markdown 語法，感覺這比較符合需求</li>
</ol>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9scnNjeS5naXRodWIuaW8vMjAxNy8xMS8xMC9VYnVudHUtR2l0aHViLWlvLWNvbmZpZy1IZXhvLw==">Ubuntu 16.04下从零起步搭建配置github.io博客——Hexo<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibGFja21hcGxlLm1lL2hleG8tdHV0b3JpYWwv">Hexo+GitHub，新手也可以快速建立部落格<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>Back-End</tag>
        <tag>phpmyadmin</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 17] 後端中階 - Express 中不可或缺的拼圖：淺談 Middleware</title>
    <url>/be201-express-middleware/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvYmUyMDEtZXhwcmVzcy1zZXF1ZWxpemU=">[BE201] 後端中階：Express 與 Sequelize<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<pre><code>學習目標：

 P1 學習如何使用 Express 及其相關套件
 P1 我理解為什麼會需要框架</code></pre>
<a id="more"></a>
<hr>
<h2 id="Middleware-中間介"><a href="#Middleware-中間介" class="headerlink" title="Middleware 中間介"></a>Middleware 中間介</h2><p>在上一篇筆記 <span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWJlMjAxLWV4cHJlc3Mtbm9kZQ==">後端中階 - Node.js + Express 框架：建立一個靜態網頁<i class="fa fa-external-link-alt"></i></span>，我們學到如何透過 Node.js 搭配 Express 框架，來快速建立一個靜態網頁。並瞭解到什麼是 MVC 架構，以及如何串接 MySQL 資料庫。</p>
<p>而 Express 的核心，其實就是由 Routing（路由系統）和 Middleware（中間介）兩個部分所組成。</p>
<p>也就是說，Express 會根據定義不同路由來執行接收到的 request，過程中會透過一連串的 middleware 處理，執行到最後產生 response。</p>
<p><img src="https://i.imgur.com/uvrlRi6.png"></p>
<p>接下來我們會針對 Middleware 的部分做介紹。</p>
<h3 id="什麼是-Middleware？"><a href="#什麼是-Middleware？" class="headerlink" title="什麼是 Middleware？"></a>什麼是 Middleware？</h3><p>在 Express 開發框架中，middleware 扮演資料庫與應用程式之間的溝通橋樑，透過不同類別的 middleware，依照需求對資料進行不同處裡，讓資料傳遞更加便利。</p>
<p>例如先前範例中的 <code>app.get(&#39;/todos&#39;, todoController.getAll)</code>，其實就可以看做是一個 middleware。</p>
<p>我們可透過 middleware function 傳入三個參數，然後輸出想要的資料：</p>
<ul>
<li>第一個參數是 request</li>
<li>第二個參數是 response</li>
<li>再透過第三個參數 next 把控制權轉移到下一個 middleware</li>
</ul>
<p>舉個簡單的例子，在之前實作 todolist 的 index.js 中加入 <code>app.use()</code>，代表整個程式都能使用這個 middleware：</p>
<pre><code class="javascript=">const express = require(&#39;express&#39;);
const db = require(&#39;./db&#39;)
const app = express();
const port = 5002;

const todoController = require(&#39;./controllers/todo&#39;)

app.set(&#39;view engine&#39;, &#39;ejs&#39;)

// app.use(): 代表整個程式都能使用這個 middleware
app.use((req, res) =&gt; &#123;
  console.log(&#39;Time: &#39;, new Date())
  res.end()
&#125;)

app.get(&#39;/todos&#39;, todoController.getAll)
app.get(&#39;/todos/:id&#39;, todoController.get)

app.listen(port, () =&gt; &#123;
  db.connect()
  console.log(`Example app listening at http://localhost:$&#123;port&#125;`)
&#125;) </code></pre>
<p>重整瀏覽器頁面時，會發現畫面什麼東西都沒有：</p>
<p><img src="https://i.imgur.com/N6etIbh.png"></p>
<p>但是在 CLI 介面會印出執行結果，每重整一次畫面就會執行 log 一次：</p>
<p><img src="https://i.imgur.com/J3r3CtM.png"></p>
<p>之所以沒有得到 response，是因為沒有加入第三個參數，也就是呼叫 next 把控制權轉移到下一個 middleware。可以把程式碼修改如下：</p>
<pre><code class="javascript=">app.use((req, res, next) =&gt; &#123;
  console.log(&#39;Time: &#39;, new Date())
  next()  // 呼叫 next 把控制權轉移到下一個 middleware
&#125;)</code></pre>
<p>重整頁面後，就能看到經渲染過的畫面，同時 CLI 介面上也會印出接收 request 的時間：</p>
<p><img src="https://i.imgur.com/9vEZvbU.png"></p>
<p>這其實就是一個簡單的 middleware 應用。那這個機制實際上在 Express 有哪些用處呢？比如說，在 Express 程式中，並沒有內建解析透過 post method 的 request body、管理 session 機制等功能，就必須透過 middleware 來實現。</p>
<p>此外，middleware 處理是有順序性的。以一個簡單的權限管理機制為範例，例如網址列上必須有 <code>admin</code> 才能顯示頁面：</p>
<h4 id="方法一：最直覺的作法"><a href="#方法一：最直覺的作法" class="headerlink" title="方法一：最直覺的作法"></a>方法一：最直覺的作法</h4><p>這個方法是透過 Express 內建的 <code>.query</code> 語法，來拿到網址列上的參數。</p>
<p>直接在兩個 Controllers 都加上 checkPermission() 進行權限驗證：</p>
<pre><code class="javascript=">const todoModel = require(&#39;../models/todo&#39;)

function checkPermission(req) &#123;
  // 利用 .query 能夠拿到網址列上的參數
  return req.query.admin === &#39;1&#39;;
&#125;

const todoController = &#123;
  getAll: (req, res) =&gt; &#123;
    // 如果驗證失敗就結束 request
    if (!checkPermission(req)) return res.end();
    todoModel.getAll((err, results) =&gt; &#123;
      if (err) return console.log(err);
      res.render(&#39;todos&#39;, &#123;
        todos: results
      &#125;)
    &#125;)
  &#125;,

  get: (req, res) =&gt; &#123;
    // 如果驗證失敗就結束 request
    if (!checkPermission(req)) return res.end();
    const id = req.params.id
    todoModel.get(id, (err, results) =&gt; &#123;
      if (err) return console.log(err);
      res.render(&#39;todo&#39;, &#123;
        todo: results[0]
      &#125;)
    &#125;)
  &#125;
&#125;

module.exports = todoController</code></pre>
<p>回到瀏覽器，會發現必須網址列加上 <code>?admin=1</code> 參數才能讀取畫面：</p>
<p><img src="https://i.imgur.com/rJV2764.png"></p>
<p>這樣就完成簡單的權限驗證機制，但這其實不是一個好做法，一旦 function 變多就會不易管理。這種情況就是 middleware 登場的時候了！</p>
<h4 id="方法二：透過-middleware-機制"><a href="#方法二：透過-middleware-機制" class="headerlink" title="方法二：透過 middleware 機制"></a>方法二：透過 middleware 機制</h4><p>在 index.js 加上 app.use()，並傳入 next 參數，若網址列通過驗證就會把控制權傳下去：</p>
<pre><code class="javascript=">app.use((req, res, next) =&gt; &#123;
  // 如果網址列通過驗證，就把控制權傳下去
  if (req.query.admin === &#39;1&#39;) &#123;
    next();
  &#125; else &#123;
    // 不通過的話就顯示 Error
    res.end(&#39;Error&#39;)
  &#125;
&#125;)</code></pre>
<p>執行結果如下：</p>
<p><img src="https://i.imgur.com/WkQUoAq.png"></p>
<p>這其實就是 middleware 的作用，相較於方法一，我們能透過 middleware 來簡化程式碼。</p>
<p>此外，我們也能改寫上述程式碼，獨立出 checkPermission() 這個 function 來進行驗證：</p>
<pre><code class="javascript=">function checkPermission(req, res, next) &#123;
  if (req.query.admin === &#39;1&#39;) &#123;
    next();
  &#125; else &#123;
    res.end(&#39;Error&#39;)
  &#125;
&#125;

app.use(checkPermission)</code></pre>
<p>這種寫法的好處，在於我們可以針對不同路由進行處理。例如加在 <code>/todos</code> 時，就只有這個路由會被影響：</p>
<pre><code class="javascript=">app.get(&#39;/todos&#39;, checkPermission, todoController.getAll)</code></pre>
<p>在 <code>/todos</code> 這個路由，必須加上 <code>?admin=1</code>  才能顯示畫面：</p>
<p><img src="https://i.imgur.com/38VqxUf.png"></p>
<p>但是 <code>/todos/:id</code> 這個路由不會受到影響，因為沒有加上 checkPermission() 這個 middleware：</p>
<p><img src="https://i.imgur.com/wqOkqgg.png"></p>
<p>在上一篇筆記的 todolist 範例中，之所以沒有寫到 next 來轉移控制權，是因為處理完就回傳 response 資料，既然不會用到 next 這個參數，就可省略宣告。</p>
<h2 id="body-parser：用來解析-HTTP-Request"><a href="#body-parser：用來解析-HTTP-Request" class="headerlink" title="body-parser：用來解析 HTTP Request"></a>body-parser：用來解析 HTTP Request</h2><p>接著要來介紹 body-parser 這個很常使用到的 middleware，使用方法可參考 GitHub 上 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V4cHJlc3Nqcy9ib2R5LXBhcnNlciNyZWFkbWU=">expressjs/body-parser<i class="fa fa-external-link-alt"></i></span> 的範例。</p>
<p>body-parser 是一個用來解析解析 HTTP Request 的中間介。前面有提到說，我透過 Express 內建的語法，我們只能拿到 query string，因此只適用於 GET method，但若是 POST method 就必須透過 middleware 才能拿到 request body。</p>
<h3 id="安裝-body-parser"><a href="#安裝-body-parser" class="headerlink" title="安裝 body-parser"></a>安裝 body-parser</h3><pre><code>$ npm install body-parser</code></pre>
<p><img src="https://i.imgur.com/4q8sKI0.png"></p>
<h3 id="body-parser-語法"><a href="#body-parser-語法" class="headerlink" title="body-parser 語法"></a>body-parser 語法</h3><p>body-parser 根據不同語法，能夠處理下列幾種格式資料：</p>
<ul>
<li>bodyParser.urlencoded()<ul>
<li>處理 UTF-8 編碼的資料，常見的表單（form）提交</li>
<li>例如：application/x-www-form-urlencoded</li>
</ul>
</li>
<li>bodyParser.json()<ul>
<li>處理 JSON 格式的資料</li>
<li>例如：application/json</li>
</ul>
</li>
<li>bodyParser.text()<ul>
<li>處理 type 為 text 的資料</li>
<li>例如：text/html, text/css</li>
</ul>
</li>
<li>bodyParser.raw()<ul>
<li>處理 type 為 application 的資料</li>
<li>例如：application/pdf, application/zip</li>
</ul>
</li>
</ul>
<p>程式碼範例如下：</p>
<pre><code class="javascript=">app.use(bodyParser.urlencoded(&#123; extended: false &#125;))
app.use(bodyParser.json())</code></pre>
<h3 id="實作新增-todo-功能"><a href="#實作新增-todo-功能" class="headerlink" title="實作新增 todo 功能"></a>實作新增 todo 功能</h3><p>同樣以之前的 todolist 範例，繼續實作新增 todo 功能：</p>
<ol>
<li>在 index.js 引入 <code>body-parser</code> 套件，就可以使用 bodyParser() 處理 Request。接著在根目錄新增一個處理 addTodo 的路由：</li>
</ol>
<pre><code class="javascript=">const express = require(&#39;express&#39;);
// 記得要引入 body-parser 才能使用
const bodyParser = require(&#39;body-parser&#39;)
const db = require(&#39;./db&#39;)
const app = express();
const port = 5002;

const todoController = require(&#39;./controllers/todo&#39;)

app.set(&#39;view engine&#39;, &#39;ejs&#39;)
// 處理 UTF-8 編碼的資料
app.use(bodyParser.urlencoded(&#123; extended: false &#125;))
// 處理 json 資料
app.use(bodyParser.json())

app.get(&#39;/todos&#39;, todoController.getAll)
app.get(&#39;/todos/:id&#39;, todoController.get)
// 在根目錄新增一個 addTodo 路由
app.get(&#39;/&#39;, todoController.addTodo)

app.listen(port, () =&gt; &#123;
  db.connect()
  console.log(`Example app listening at http://localhost:$&#123;port&#125;`)
&#125;)</code></pre>
<ol start="2">
<li>在 Controllers 新增一個處理 addTodo 的 Controller，須注意這裡只負責 render 渲染頁面，而不是真的處理新增 todo 動作：</li>
</ol>
<pre><code class="javascript=">const todoModel = require(&#39;../models/todo&#39;)

const todoController = &#123;
  getAll: (req, res) =&gt; &#123;
    todoModel.getAll((err, results) =&gt; &#123;
      if (err) return console.log(err);
      res.render(&#39;todos&#39;, &#123;
        todos: results
      &#125;)
    &#125;)
  &#125;,

  get: (req, res) =&gt; &#123;
    const id = req.params.id
    todoModel.get(id, (err, results) =&gt; &#123;
      if (err) return console.log(err);
      res.render(&#39;todo&#39;, &#123;
        todo: results[0]
      &#125;)
    &#125;)
  &#125;

  // 這裡只負責 render 頁面，並不是真的處理新增 todo
  addTodo: (req, res) =&gt; &#123;
    res.render(&#39;addTodo&#39;)
  &#125;
&#125;

module.exports = todoController</code></pre>
<ol start="3">
<li>接著要實作 addTodo 的 view 部分，也就是新增一個 addTodo.ejs 檔：</li>
</ol>
<pre><code class="javascript=">&lt;h1&gt;Add Todo&lt;/h1&gt;

&lt;form method=&quot;POST&quot;&quot; action=&quot;/todos&quot;&gt;
  Content: &lt;input type=&quot;text&quot; name=&quot;content&quot; /&gt;
  &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;</code></pre>
<p>執行後可在瀏覽器確認是否有畫面：</p>
<p><img src="https://i.imgur.com/scuiz9Q.png"></p>
<p>這時如果點選提交，會跳轉到錯誤頁面，這是因為還沒有處理路由：</p>
<p><img src="https://i.imgur.com/9xs6k0Y.png"></p>
<ol start="4">
<li>回到 index.js 新增一個處理 newTodo 的路由：</li>
</ol>
<pre><code class="javascript=">// 新增一個處理 newTodo 的路由
app.post(&#39;/todos&#39;, todoController.newTodo)
app.get(&#39;/todos&#39;, todoController.getAll)
app.get(&#39;/todos/:id&#39;, todoController.get)
// 新增一個處裡 addTodo 的路由
app.get(&#39;/&#39;, todoController.addTodo)</code></pre>
<ol start="5">
<li>接著同樣新增一個處理 newTodo 的 Controller，確認是否有成功拿到表單資料：</li>
</ol>
<pre><code class="javascript=">newTodo: (req, res) =&gt; &#123;
  // 透過 body-parser 解析 resquest body 來拿取 content
  const content = req.body.content
  // 先輸出確認是否有拿到資料
  res.end(content)
&#125;,</code></pre>
<p>在瀏覽器提交表單，確認有拿到資料：</p>
<p><img src="https://i.imgur.com/EQIScXT.png"></p>
<p>之所以能夠拿到表單提交的資料，是透過 body-parser 這個中間介解析 resquest body，才能拿取 content，否則程式會因為無法解析而出現錯誤。</p>
<ol start="6">
<li>接著繼續修改 newTodo Controller，把資料交給 Model 處理：</li>
</ol>
<pre><code class="javascript=">newTodo: (req, res) =&gt; &#123;
  // 透過 body-parser 解析 resquest body 來拿取 content
  const content = req.body.content
  todoModel.add(content, (err) =&gt; &#123;
    if (err) return console.log(err);
    // 重新導回 todos 頁面
    res.redirect(&#39;/todos&#39;);
  &#125;)
&#125;,</code></pre>
<ol start="7">
<li>再來是處理 todoModel.add() 的部分，也就是在 Model 新增一個 add 功能：</li>
</ol>
<pre><code class="javascript=">// 新增 todoModel.add()
add: (content, cb) =&gt; &#123;
  db.query(
    &#39;INSERT INTO todos(content) VALUES(?)&#39;, [content], (err, results) =&gt; &#123;
      if (err) return cb(err);
      cb(null)
    &#125;
  );
&#125;</code></pre>
<p>回到瀏覽器確認是否能夠新增 todo：</p>
<p><img src="https://i.imgur.com/Y9fPgmN.png"></p>
<p>這樣就完成一個簡單的 Back-end 專案了！並且有 MVC 架構，也就是 View 顯示畫面，Model 處理資料，Controller 藉由不同路由接收 requset，會執行相對應的 method；還有透過 body-parser 這個 middleware 處理 POST 表單提交的資料。</p>
<h2 id="express-session：負責管理-session"><a href="#express-session：負責管理-session" class="headerlink" title="express-session：負責管理 session"></a>express-session：負責管理 session</h2><p>再來介紹 Express 框架中，用來管理 session 的中間介：express-session，使用方法可參考 GitHub 的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V4cHJlc3Nqcy9zZXNzaW9u">expressjs/session<i class="fa fa-external-link-alt"></i></span> 頁面。</p>
<h3 id="安裝-express-session"><a href="#安裝-express-session" class="headerlink" title="安裝 express-session"></a>安裝 express-session</h3><pre><code>$ npm install express-session</code></pre>
<p><img src="https://i.imgur.com/jWw5ZYd.png"></p>
<h3 id="實作簡易登入功能"><a href="#實作簡易登入功能" class="headerlink" title="實作簡易登入功能"></a>實作簡易登入功能</h3><p>接著延續前面的 todolist 範例，實作一個簡單的登入功能。</p>
<ol>
<li>在 index.js引入 express-session 套件：</li>
</ol>
<pre><code class="javascript=">// 引入 express-session
const session = require(&#39;express-session&#39;)</code></pre>
<ol start="2">
<li>接著設定 app 載入模組 express-session：</li>
</ol>
<pre><code class="javascript=">// 在 app.js 中設定載入模組 express-session
app.use(session(&#123;
  secret: &#39;keyboard cat&#39;,
  resave: false,
  saveUninitialized: true
&#125;))</code></pre>
<ol start="3">
<li>實作 login、提交表單、logout 的路由，須注意是 req.session，request 才有 session：</li>
</ol>
<pre><code class="javascript=">// 實作 login 路由
app.get(&#39;/login&#39;, (req, res) =&gt; &#123;
  res.render(&#39;login&#39;)
&#125;)
// login 提交表單的路由
app.post(&#39;/login&#39;, (req, res) =&gt; &#123;
  if (req.body.password === &#39;abc&#39;) &#123;
    // 注意是 request 才有 session
    req.session.isLogin = true
    // 成功就導回首頁；失敗則導回上一頁
    res.redirect(&#39;/&#39;)
  &#125; else &#123;
    res.redirect(&#39;/login&#39;)
  &#125;
&#125;)
// 實作 logout 路由
app.get(&#39;/logout&#39;, (req, res) =&gt; &#123;
  req.session.isLogin = false
  res.redirect(&#39;/&#39;)
&#125;)</code></pre>
<ol start="4">
<li>設定 Controller 部分，在 addTo 首頁加上 isLogin 參數，用來判別是否登入：</li>
</ol>
<pre><code class="javascript=">  addTodo: (req, res) =&gt; &#123;
    res.render(&#39;addTodo&#39;, &#123;
      isLogin: req.session.isLogin
    &#125;)
  &#125;</code></pre>
<ol start="5">
<li>設定 view 部分，在 addTodo.ejs 頁面顯示是否登入，增加連結導向 login 頁面或 logout：</li>
</ol>
<pre><code class="javascript=">&lt;h1&gt;Add Todo&lt;/h1&gt;

&lt;% if(isLogin) &#123; %&gt;
  已經登入  &lt;a href=&quot;/logout&quot;&gt;登出&lt;/a&gt;
&lt;% &#125; else &#123; %&gt;
  請先登入  &lt;a href=&quot;/login&quot;&gt;登入&lt;/a&gt;
&lt;% &#125; %&gt;

&lt;form method=&quot;POST&quot;&quot; action=&quot;/todos&quot;&gt;
  Content: &lt;input type=&quot;text&quot; name=&quot;content&quot; /&gt;
  &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;</code></pre>
<ol start="6">
<li>新增 login.ejs 頁面，能夠輸入密碼提交表單：</li>
</ol>
<pre><code class="javascript=">&lt;h1&gt;Login&lt;/h1&gt;

&lt;form method=&quot;POST&quot; action=&quot;/login&quot;&gt;
  Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;
  &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;</code></pre>
<p>執行結果：</p>
<p><img src="https://i.imgur.com/3RZUKgn.png"></p>
<p>這樣就透過 express-session 中間介提供的功能，完成簡單的登入登出功能。</p>
<p>但這種寫法其實會遇到一個問題，也就是每個 render 的頁面都要加上 isLogin 判斷登入狀態，我們再來要介紹的中間介就可以解決這個問題。</p>
<h2 id="connect-flash：顯示錯誤訊息"><a href="#connect-flash：顯示錯誤訊息" class="headerlink" title="connect-flash：顯示錯誤訊息"></a>connect-flash：顯示錯誤訊息</h2><p>藉由 connect-flash 提供的 flash message 功能，我們就能在頁面顯示錯誤訊息等等，其實這背後的機制就是透過 session，能夠和 express-session 搭配使用。</p>
<p>使用方法可參考 GitHub 的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phcmVkaGFuc29uL2Nvbm5lY3QtZmxhc2g=">jaredhanson/connect-flash<i class="fa fa-external-link-alt"></i></span> 頁面。</p>
<h3 id="安裝-connect-flash"><a href="#安裝-connect-flash" class="headerlink" title="安裝 connect-flash"></a>安裝 connect-flash</h3><pre><code>$ npm install connect-flash</code></pre>
<h3 id="實作錯誤顯示功能"><a href="#實作錯誤顯示功能" class="headerlink" title="實作錯誤顯示功能"></a>實作錯誤顯示功能</h3><ol>
<li>在 index.js引入 connect-flash 套件：</li>
</ol>
<pre><code class="javascript=">// 引入 connect-flash
const flash = require(&#39;connect-flash&#39;);</code></pre>
<ol start="2">
<li>設定 app 載入 flash 模組：</li>
</ol>
<pre><code class="javascript=">app.use(flash())</code></pre>
<ol start="3">
<li>在 login 路由使用 flash()，傳入的兩個參數分別代表 key: value：</li>
</ol>
<pre><code class="javascript=">app.get(&#39;/login&#39;, (req, res) =&gt; &#123;
  res.render(&#39;login&#39;, &#123;
    // 從 flash() 中拿取 errorMessage 這個 key 的 value
    errorMessage: req.flash(&#39;errorMessage&#39;)
  &#125;)
&#125;)
app.post(&#39;/login&#39;, (req, res) =&gt; &#123;
  if (req.body.password === &#39;abc&#39;) &#123;
    req.session.isLogin = true
    res.redirect(&#39;/&#39;)
  &#125; else &#123;
    // falsh() 要傳入兩個參數，代表 key: value
    req.flash(&#39;errorMessage&#39;, &#39;Please input the correct password.&#39;)
    res.redirect(&#39;/login&#39;)
  &#125;
&#125;)</code></pre>
<ol start="4">
<li>設定 login.ejs，當登入失敗就會在畫面顯示 errorMessage：</li>
</ol>
<pre><code class="javascript=">&lt;h1&gt;Login&lt;/h1&gt;

&lt;h2&gt;&lt;%= errorMessage %&gt;&lt;/h2&gt;

&lt;form method=&quot;POST&quot; action=&quot;/login&quot;&gt;
  Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;
  &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;</code></pre>
<p>執行結果如下，當提交錯誤時會顯示 errorMessage，重整頁面後就會消失，這就是 flash 的功用：</p>
<p><img src="https://i.imgur.com/OepYfsy.png"></p>
<p>但這種寫法其實還是不夠簡潔，如果要判斷輸出錯誤都還是要向 isLogin 那樣加上 errorMessage。</p>
<h3 id="重構程式碼：透過-res-locals-傳值給-view"><a href="#重構程式碼：透過-res-locals-傳值給-view" class="headerlink" title="重構程式碼：透過 res.locals 傳值給 view"></a>重構程式碼：透過 res.locals 傳值給 view</h3><p>其實在 express 中有個捷徑，我們可以自己新增 middleware。也就是把東西存放在 <code>res.locals</code> ，view 就可以直接從 locals 存取使用，可想像成全域變數的感覺：</p>
<pre><code class="javascript=">// 透過 locals 傳值給 view: session 功能和 errorMessage
app.use((req, res, next) =&gt; &#123;
  res.locals.isLogin = req.session.isLogin
  res.locals.errorMessage = req.flash(&#39;errorMessage&#39;)
  // 記得加上 next() 把控制權轉移到下一個中間介
  next()
&#125;)

// 就不需在路由加上 errorMessage
app.get(&#39;/login&#39;, (req, res) =&gt; &#123;
  res.render(&#39;login&#39;)
&#125;)</code></pre>
<p>addTodo 的 Controller 也可以改回原本的：</p>
<pre><code class="javascript=">addTodo: (req, res) =&gt; &#123;
  res.render(&#39;addTodo&#39;）
&#125;</code></pre>
<p>修改完成之後，同樣能夠執行程式，透過範例整理兩個重點：</p>
<ul>
<li>透過 req.flash() 可實作出 errorMessage</li>
<li>透過 res.locals 可傳值給 view 使用，通常會用在驗證功能或是顯示 errorMessage</li>
</ul>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>透過上述範例，我們能夠得知在使用 Express 框架實作網頁時，大致上會依照下方流程進行：</p>
<ol>
<li>思考產品全貌：網頁外觀、需要哪些功能等等</li>
<li>規劃資料庫結構</li>
<li>載入需要的模組，設定 app 路由部分</li>
<li>依照 MVC 架構撰寫程式碼：<ul>
<li>設定 Controller：針對不同路由進行控制</li>
<li>設定 Model：如何處理資料</li>
<li>設定 View：如何呈現畫面</li>
</ul>
</li>
</ol>
<p>在接下來的課程，我們會綜合之前所學的知識，來實作簡單的會員註冊系統以及留言版功能。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3BpZXJjZXNoaWgvJUU3JUFEJTg2JUU4JUE4JTk4LSVFNCVCRCU5NSVFOCVBQyU4Mi1taWRkbGV3YXJlLSVFNSVBNiU4MiVFNCVCRCU5NSVFNSVCOSVBQiVFNSU4QSVBOSVFNiU4OCU5MSVFNSU4MCU5MSVFNSVCQiVCQSVFNyVBQiU4Qi1leHByZXNzLSVFNyU5QSU4NCVFNiU4NyU4OSVFNyU5NCVBOCVFNyVBOCU4QiVFNSVCQyU4Ri0xOTA4MmIxZDhlMDY=">「筆記」- 何謂 Middleware？如何幫助我們建立 Express 的應用程式<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDQwNzAwOA==">bodyParser中间件的研究<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>Back-End</tag>
        <tag>Express</tag>
        <tag>Middleware</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 17] 後端中階 - 使用 Node.js + Express 框架建立一個靜態網頁</title>
    <url>/express/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvYmUyMDEtZXhwcmVzcy1zZXF1ZWxpemU=">[BE201] 後端中階：Express 與 Sequelize<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<pre><code>學習目標：

 P1 學習如何使用 Express 及其相關套件
 P1 我理解為什麼會需要框架</code></pre>
<a id="more"></a>
<hr>
<h2 id="要學框架，先從不用框架開始"><a href="#要學框架，先從不用框架開始" class="headerlink" title="要學框架，先從不用框架開始"></a>要學框架，先從不用框架開始</h2><p>在講解什麼是 Express 框架以前，先來談談什麼是 Server，其實 Server 也是一種程式，而 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">Node.js<i class="fa fa-external-link-alt"></i></span> 本身就有提供內建 Library，讓我們能透過引入 modeule 來使用 Server 的功能。 </p>
<h3 id="範例：以-Node-js-實作一個-Server"><a href="#範例：以-Node-js-實作一個-Server" class="headerlink" title="範例：以 Node.js 實作一個 Server"></a>範例：以 Node.js 實作一個 Server</h3><p>建立一個 js 檔，並引入 Node.js 內建 http 相關 module，再以 createServer() 建立 server：</p>
<pre><code class="javascript=">// node.js 內建 http 相關 module
const http = require(&#39;http&#39;)
// createServer() 要傳入的參數是 function
const server = http.createServer(handler)

// 兩個參數分別是 request 和 response，這裡使用命名慣例寫法
function handler(req, res) &#123;
  console.log(req.url)  // 印出 req 網址
  res.write(&#39;Hello World!&#39;)   // 指定 respone 回傳內容
  res.end()   // 結束這個 response
&#125;

// 常見為 80 port，測試時使用 5001 port 就不易發生衝突
server.listen(5001)</code></pre>
<p>接著在 CLI 介面執行 js 檔，會發現什麼事也沒發生，但其實我們已經成功運行一個 server，否則程式會直接執行結束：</p>
<p><img src="https://i.imgur.com/2Bv9WKj.png"></p>
<ol start="3">
<li>可以在瀏覽器輸入 <code>http://localhost:5001/</code>，連到本地端的 5001 port，就會看到回傳內容 <code>Hello World!</code>：</li>
</ol>
<p><img src="https://i.imgur.com/ZY79LWh.png"></p>
<p>或者我們也可以根據不同 url，來回傳不同內容：</p>
<pre><code class="javascript=">const http = require(&#39;http&#39;)
const server = http.createServer(handler)

function handler(req, res) &#123;
  console.log(req.url)  // 印出 req 網址
  if (req.url === &#39;/hello&#39;) &#123;
    // 參數分別是 request 的 status code 和內容格式，告訴瀏覽器如何解析網頁
    res.writeHead(200, &#123;            // 200: 請求成功
      &#39;Content-Type&#39;: &#39;text/html&#39;
    &#125;)
    res.write(&#39;&lt;h1&gt;hello!&lt;/h1&gt;&#39;)    // 也可以加上 HTML 標籤
  &#125; else if (req.url === &#39;/bye&#39;) &#123;
    res.write(&#39;bye!&#39;)
  &#125; else &#123;
    res.write(&#39;Invalid url&#39;)
  &#125;
  res.end()   // 結束這個 response
&#125;

server.listen(5001)</code></pre>
<p>在瀏覽器運行結果如下，瀏覽器會根據內容格式（Content-Type）解析網頁：</p>
<p><img src="https://i.imgur.com/LbCRc8S.png"></p>
<p>而當我們切換網址時，CLI 介面也會印出 url 文字，其中 <code>/favicon.ico</code> 代表瀏覽器標籤的 logo：</p>
<p><img src="https://i.imgur.com/t5Gx1JF.png"></p>
<p>我們也可以利用 <code>res.writeHead()</code> 來導向其他網址，如下方範例。這時如果輸入 <code>http://localhost:5001/bye</code>，就會重新導向至 google 首頁：</p>
<pre><code class="javascript=">const http = require(&#39;http&#39;)
const server = http.createServer(handler)

function handler(req, res) &#123;
  console.log(req.url)  // 印出 req 網址
  if (req.url === &#39;/hello&#39;) &#123;
    res.write(&#39;&lt;h1&gt;hello!&lt;/h1&gt;&#39;)
  &#125; else if (req.url === &#39;/bye&#39;) &#123;
    res.writeHead(301, &#123;              // 301: 重新導向
      &#39;Location&#39;: &#39;https://www.google.com.tw/&#39;
    &#125;)
    res.write(&#39;bye!&#39;)
  &#125; else &#123;
    res.write(&#39;Invalid url&#39;)
  &#125;
  res.end()   // 結束這個 response
&#125;

server.listen(5001)</code></pre>
<p>根據上述範例，我們能夠利用 Node.js 提供的模組，來實作出一個簡易的 http server。</p>
<p>其實這不是本單元要討論的重點，只是藉由範例來瞭解，Node.js 的底層就是利用 <code>http.createServer()</code> 來執行，即使不透過 Library 也能夠時做出 server。</p>
<p>瞭解到背後運作的原理後，接下來要介紹另一套 Library，其實就是把上面實作的功能包裝在一起，讓我們能更方便取得資料。</p>
<h2 id="初探-Express"><a href="#初探-Express" class="headerlink" title="初探 Express"></a>初探 Express</h2><p>什麼是 Express？根據<a href="(https://expressjs.com/)">官網</a>介紹：</p>
<blockquote>
<p>Express: Fast, unopinionated, minimalist web framework for Node.js</p>
</blockquote>
<p>簡言之，Express 是 Node.js 環境下提供的一個輕量後端框架，自由度極高，透過豐富的 HTTP 工具，能幫助快速開發後端應用程式。</p>
<p>跟其他有完整 MVC 架構的框架相比，Express 其實鬆散（或者說自由）很多，許多地方並沒有強制規範，都只是按照前人的方法或者是慣例來實踐，十個人可能會有十種不同的寫法。</p>
<h3 id="安裝-Express"><a href="#安裝-Express" class="headerlink" title="安裝 Express"></a>安裝 Express</h3><blockquote>
<p>詳細步驟可參考<span class="exturl" data-url="aHR0cHM6Ly9leHByZXNzanMuY29tL3poLXR3L3N0YXJ0ZXIvaW5zdGFsbGluZy5odG1s">官方文件<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
<h4 id="Step1-初始化-npm，過程都按確定，最後會在資料夾中建立一個-package-json-檔"><a href="#Step1-初始化-npm，過程都按確定，最後會在資料夾中建立一個-package-json-檔" class="headerlink" title="Step1. 初始化 npm，過程都按確定，最後會在資料夾中建立一個 package.json 檔"></a>Step1. 初始化 npm，過程都按確定，最後會在資料夾中建立一個 package.json 檔</h4><pre><code>$ npm init</code></pre>
<p><img src="https://i.imgur.com/Ya0XugX.png"></p>
<h4 id="Step2-安裝-Express"><a href="#Step2-安裝-Express" class="headerlink" title="Step2. 安裝 Express"></a>Step2. 安裝 Express</h4><p>在最新的 npm 版本，可以省略 <code>--save</code>，安裝完成還是會自動存到 package.json：</p>
<pre><code>$ npm install express --save</code></pre>
<p><img src="https://i.imgur.com/qOagjRg.png"></p>
<h4 id="Step3-實作範例：Hello-world"><a href="#Step3-實作範例：Hello-world" class="headerlink" title="Step3. 實作範例：Hello world"></a>Step3. 實作範例：Hello world</h4><p>接著可以跟著<span class="exturl" data-url="aHR0cHM6Ly9leHByZXNzanMuY29tL2VuL3N0YXJ0ZXIvaGVsbG8td29ybGQuaHRtbA==">官方文件<i class="fa fa-external-link-alt"></i></span>來實作一個簡單範例，開啟 index.js 檔並輸入下列程式碼：</p>
<pre><code class="javascript=">// 引入 library
const express = require(&#39;express&#39;);
// express 引入的是一個 function
const app = express();
// 建立一個不易產生衝突的 port 用來測試
const port = 5001;

// 如何處理不同的 request，參數分別為 url 和要執行的 function
app.get(&#39;/&#39;, (req, res) =&gt; &#123;
  res.send(&#39;hello world!&#39;)
&#125;)

app.get(&#39;/bye&#39;, (req, res) =&gt; &#123;
  res.send(&#39;bye!&#39;)
&#125;)

// 運行這個 port，參數分別為 port 和要執行的 function
app.listen(port, () =&gt; &#123;
  console.log(`Example app listening at http://localhost:$&#123;port&#125;`)
&#125;)</code></pre>
<p>在 CLI 介面執行 index.js，出現下方文字代表有成功運行程式：</p>
<p><img src="https://i.imgur.com/VG4okLU.png"></p>
<p>這時在瀏覽器輸入 <code>http://localhost:5001/</code>，就會看到回傳內容：</p>
<p><img src="https://i.imgur.com/NYQmfRF.png"></p>
<p>如果發現修改後，網頁還是會導回先前設定的網址，可透過開發者工具來清除快取（cache），重整頁面就能看到結果：</p>
<p><img src="https://i.imgur.com/6T6umyx.png"></p>
<p>和最一開始的範例做比較的話，其實可以發現到，寫法和使用 Node.js 實作 Server 非常類似。</p>
<p>但是藉由 Express 提供的<span class="exturl" data-url="aHR0cHM6Ly9leHByZXNzanMuY29tL3poLXR3L2d1aWRlL3JvdXRpbmcuaHRtbA==">路由（Routing）<i class="fa fa-external-link-alt"></i></span>系統，會將許多語法包裝好，在執行上也會方便許多。除了 <code>app.get()</code>，還有像是 <code>app.post()</code> 和 <code>app.delete()</code> 等針對不同 method 來進行操作，這部分我們後面會再詳細介紹。</p>
<h3 id="Express-vs-Apache-PHP"><a href="#Express-vs-Apache-PHP" class="headerlink" title="Express vs Apache + PHP"></a>Express vs Apache + PHP</h3><p>在看完上面的範例後，我們可以試著比較 Express 和以前所學的 <span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWJlMTAxLXBocC1hbmQtbXlzcWw=">Apache + PHP<i class="fa fa-external-link-alt"></i></span>，兩者的運作模式有何差別：</p>
<h4 id="Apache-PHP"><a href="#Apache-PHP" class="headerlink" title="Apache + PHP"></a>Apache + PHP</h4><ul>
<li>瀏覽器會發 request 給 Apache Server，再交給 PHP 處理，處理完成後再傳 response 回去</li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLXR3LyVFNiU5NiU4NyVFNCVCQiVCNiVFNyVCMyVCQiVFNyVCQiU5Rg==">檔案系統<i class="fa fa-external-link-alt"></i></span>：預設路徑長什麼樣子，在該資料夾底下就會有對應的 php 檔</li>
</ul>
<p><img src="https://i.imgur.com/EYfvLe0.png"></p>
<h4 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h4><ul>
<li>瀏覽器發 request 給 Express Server，經過處理後會根據 url 回傳 response</li>
<li>和前者的最大差別，就是沒有 PHP 處理器，Express 本身就是一個 Server，透過路由系統決定什麼路徑回傳什麼資料，而不會侷限在檔案系統</li>
</ul>
<p><img src="https://i.imgur.com/zXWH67g.png"></p>
<h2 id="MVC-基本架構"><a href="#MVC-基本架構" class="headerlink" title="MVC 基本架構"></a>MVC 基本架構</h2><p>在課程當中，我們會使用後端框架 Express 和 ORM 工具 Sequelize 來打造 MVC 架構的網站，以下先來談談什麼是 MVC 架構。</p>
<p>MVC（Model–view–controller）：是一種應用程式架構，透過將程式碼拆成分成模型（Model）、視圖（View）和控制器（Controller）三個部分，並透過路由系統，建立整個應用程式的設計模式。</p>
<p>在 MVC 架構中，request 流程大致如下：</p>
<ol>
<li>發出的 request 會由 Controller 來處理</li>
<li>接著 Controller 會和 Model 拿取 data</li>
<li>Controller 再把拿到的資料給 View，由 View 提供的 template</li>
<li>最後 Controller 再結合 data 和 template，回傳 response</li>
</ol>
<p><img src="https://i.imgur.com/aYBYHlx.png"></p>
<p>簡單來說：</p>
<ul>
<li>Model 負責處理資料部分（data），例如在 MySQL 資料庫裡建立 tables，以及所有讀取、寫入資料等</li>
<li>View 負責處理畫面的部分（template），也就是我們看到的網頁內容</li>
<li>Controller 在過程中扮演 Model 和 View 中間的協調者，當不同路由（route）接收到 request 時，會呼叫 Controller 執行相對應的 Method。例如跟 Model 拿取資料，結合 View 提供的模版之後，再回傳 response</li>
</ul>
<p>這和我們之前使用 PHP 寫的網頁相比，在分工上是明確許多的。接下來我們要利用 Nodes.js 來實作一個簡單的 MVC 架構。</p>
<h2 id="在-Node-js-上實作-MVC-架構"><a href="#在-Node-js-上實作-MVC-架構" class="headerlink" title="在 Node.js 上實作 MVC 架構"></a>在 Node.js 上實作 MVC 架構</h2><h3 id="透過-Express-提供的-template-engines-來實作-View"><a href="#透過-Express-提供的-template-engines-來實作-View" class="headerlink" title="透過 Express 提供的 template engines 來實作 View"></a>透過 Express 提供的 <span class="exturl" data-url="aHR0cHM6Ly9leHByZXNzanMuY29tL2VuL2d1aWRlL3VzaW5nLXRlbXBsYXRlLWVuZ2luZXMuaHRtbA==">template engines<i class="fa fa-external-link-alt"></i></span> 來實作 View</h3><ol>
<li>選擇安裝一種 template engines（樣板處理器）使用，這裡以 EJS 做為範例，架構類似於之前學過的 PHP：</li>
</ol>
<pre><code>$ npm install ejs</code></pre>
<p><img src="https://i.imgur.com/DixdfOM.png"></p>
<ul>
<li>EJS 語法是透過 <code>&lt;%  %&gt;</code> 符號，和 PHP 語法其實很類似，語法又可分為三種：</li>
</ul>
<pre><code class="javascript=">&lt;% JavaScript 程式碼 %&gt;

&lt;%-  %&gt; 會經過解析然後印出來，用於引入 HTML 內容

&lt;%=  %&gt; 會直接印出原始碼，用於輸出資料，避免被解析成語法，可視為一種 XSS 防禦

// 可和 PHP 寫法做比較
&lt;?PHP echo   ?&gt; </code></pre>
<ol start="2">
<li>接著回到剛才的 index.js 檔，加上 <code>app.set()</code> 設定要使用的 view engine：</li>
</ol>
<pre><code class="javascript=">// 設定 view engine
app.set(&#39;view engine&#39;, &#39;ejs&#39;)</code></pre>
<ol start="3">
<li><p>預設目錄會是 <code>/views</code>，因此需要新建一個資料夾 views，並在資料夾中建立一個 hello.ejs 檔</p>
</li>
<li><p>記得在 VS Code 等編譯器中安裝 ejs 插件，才能夠解析 ejs 檔：<br><img src="https://i.imgur.com/PVJjWAG.png"></p>
</li>
<li><p>在 hello.ejs 檔中輸入簡單的程式碼進行測試，例如：<code>&lt;h1&gt;hello&lt;/h1&gt;</code></p>
</li>
<li><p>接著調整 index.js 程式碼，告訴 express 去 render views 目錄底下叫做 hello 的檔案：</p>
</li>
</ol>
<pre><code class="javascript=">const express = require(&#39;express&#39;);
const app = express();
const port = 5001;

// 設定 view engine
app.set(&#39;view engine&#39;, &#39;ejs&#39;)

app.get(&#39;/&#39;, (req, res) =&gt; &#123;
  res.send(&#39;index&#39;)
&#125;)

app.get(&#39;/hello&#39;, (req, res) =&gt; &#123;
// 叫 express 去 render views 底下叫做 hello 的檔案，副檔名可省略
  res.render(&#39;hello&#39;)
&#125;)

app.listen(port, () =&gt; &#123;
  console.log(`Example app listening at http://localhost:$&#123;port&#125;`)
&#125;)</code></pre>
<ol start="7">
<li>輸入 node index.js 指令運行，在瀏覽器可以看到結果：</li>
</ol>
<p><img src="https://i.imgur.com/G32u0NI.png"></p>
<ol start="8">
<li>如果想要修改 views 中的 template，也就是 ejs 檔的內容，只要重整瀏覽器畫面即可，不需再重新運行 Node.js：</li>
</ol>
<p><img src="https://i.imgur.com/dKhAwTu.png"></p>
<h3 id="實作簡易的-todo-list-API"><a href="#實作簡易的-todo-list-API" class="headerlink" title="實作簡易的 todo list API"></a>實作簡易的 todo list API</h3><ol>
<li>首先在 index.js 建立 todos，並設定 app.get() 傳入資料：</li>
</ol>
<pre><code class="javascript=">const express = require(&#39;express&#39;);
const app = express();
const port = 5001;

// 設定 view engine
app.set(&#39;view engine&#39;, &#39;ejs&#39;)

// 建立 todos data
const todos = [
  &#39;first todo&#39;, &#39;second todo&#39;, &#39;third todo&#39;
]

app.get(&#39;/todos&#39;, (req, res) =&gt; &#123;
  // 第二個參數可傳入資料
  res.render(&#39;todos&#39;, &#123;
    todos     // todos: todos 一樣的話可省略寫法
  &#125;)
&#125;)

app.get(&#39;/hello&#39;, (req, res) =&gt; &#123;
  res.render(&#39;hello&#39;)
&#125;)

app.listen(port, () =&gt; &#123;
  console.log(`Example app listening at http://localhost:$&#123;port&#125;`)
&#125;)</code></pre>
<ol start="2">
<li>接著編輯 todos.ejs 檔的內容，也就是 todos 的 view 部分。要輸出內容的語法是 <code>&lt;%= code %&gt;</code>，而不是用 console.log()，或是 PHP 的 echo：</li>
</ol>
<pre><code class="javascript=">&lt;h1&gt;Todos&lt;/h1&gt;

&lt;ul&gt;
&lt;% for(let i = 0; i &lt; todos.length; i++) &#123; %&gt;
  &lt;li&gt;&lt;%= todos[i]%&gt;&lt;/li&gt;    // 加上等於代表後面的東西要輸出
&lt;% &#125; %&gt;
&lt;/ul&gt;</code></pre>
<ol start="3">
<li>在瀏覽器運行，這樣能根據之前設立的 data 輸出 todos：</li>
</ol>
<p><img src="https://i.imgur.com/zGLAWIT.png"></p>
<ol start="4">
<li>接著回到 index.js 檔，用同樣的方式，根據不同 id 來拿取對應的 todo：</li>
</ol>
<pre><code class="javascript=">// 加上 :id 代表不確定的參數
app.get(&#39;/todos/:id&#39;, (req, res) =&gt; &#123;
  // params: 可拿到網址列上指定的參數
  const id = req.params.id
  const todo = todos[id]
  res.render(&#39;todo&#39;, &#123;
    todo
  &#125;)
&#125;)</code></pre>
<ol start="5">
<li>建立 todo.ejs 檔，也就是 todo 的 view 部分：</li>
</ol>
<pre><code class="javascript=">&lt;h1&gt;Todo&lt;/h1&gt;

&lt;h2&gt;&lt;%= todo %&gt;&lt;/h2&gt;</code></pre>
<ol start="6">
<li>透過網址列上的 id，能夠讀取相對應的 todo：</li>
</ol>
<p><img src="https://i.imgur.com/crYUBSj.png"></p>
<p>這樣就透過 Express 結合 view template engine 完成了簡單的範例，也可以再增加 header 或 footer 等來豐富內容。</p>
<h3 id="重構專案：實作-Model-amp-Controller"><a href="#重構專案：實作-Model-amp-Controller" class="headerlink" title="重構專案：實作 Model &amp; Controller"></a>重構專案：實作 Model &amp; Controller</h3><p>接下來要試著重構程式碼，也就是實作 MVC 架構中的 Model 和 Controller 部分。</p>
<h4 id="Model：用來管理-todos-的資料"><a href="#Model：用來管理-todos-的資料" class="headerlink" title="Model：用來管理 todos 的資料"></a>Model：用來管理 todos 的資料</h4><ol>
<li>回到 express 目錄，新增一個 models 資料夾，並在裡面建立 todo.js 檔</li>
<li>在 todo.js 檔案，建立 todoModel，提供存取資料的方法（function），例如 get 或 add 等 method：</li>
</ol>
<pre><code class="javascript=">const todos = [
  &#39;first todo&#39;, &#39;second todo&#39;, &#39;third todo&#39;
]

// 建立一個 todoModel 物件，裡面放存取資料的方法（function）
const todoModel = &#123;
  getAll: () =&gt; &#123;
    return todos
  &#125;,

  get: id =&gt; &#123;
    return todos[id]
  &#125;
&#125;

module.exports = todoModel</code></pre>
<h4 id="Controller：控制器"><a href="#Controller：控制器" class="headerlink" title="Controller：控制器"></a>Controller：控制器</h4><ol>
<li>同樣在 express 目錄，新增一個 controllers 資料夾，並在裡面建立 todo.js 檔</li>
<li>接著重構程式碼：</li>
</ol>
<ul>
<li>從 model 引入資料</li>
<li>建立物件，並透過方法（function）來存取資料，這裡會和一開始中 index.js 的 app.get() 寫法類似</li>
<li>再交由 view engine 進行 render</li>
</ul>
<pre><code class="javascript=">// 先從 model 引入 todos 資料
const todoModel = require(../models/todo)

// 建立一個 todoController 物件，透過方法來存取 model 的資料
const todoController = &#123;
  // 傳入參數 req, res
  getAll: (req, res) =&gt; &#123;
    const todos = todoModel.getAll()
    res.render(&#39;todos&#39;, &#123;
      todos
    &#125;)
  &#125;,

  get: (req, res) =&gt; &#123;
    const id = req.params.id
    const todo = todoModel.get(id)
    res.render(&#39;todo&#39;, &#123;
      todo
    &#125;)
  &#125;
&#125;

module.exports = todoController</code></pre>
<ol start="3">
<li>回到根目錄的 index.js 檔，修改路由，透過引入 controller 的 todo.js，程式碼就可以更簡潔：</li>
</ol>
<pre><code class="javascript=">const express = require(&#39;express&#39;);
const app = express();
const port = 5001;

// 引入 controller
const todoController = require(&#39;./controllers/todo&#39;)

app.set(&#39;view engine&#39;, &#39;ejs&#39;)

const todos = [
  &#39;first todo&#39;, &#39;second todo&#39;, &#39;third todo&#39;
]

// 可直接使用 controller 的方法拿取資料和進行 render
app.get(&#39;/todos&#39;, todoController.getAll)

app.get(&#39;/todos/:id&#39;,</code></pre>
<p>這樣就完成了有 MCV 架構的程式：</p>
<ul>
<li>express 目錄的 index.js：提供路由</li>
<li>views 目錄的 todo.ejs 和 todos.ejs：提供模版</li>
<li>models 目錄的 todo.js：提供資料</li>
<li>controllers 目錄的 todo.js：結合 model 和 view，根據路由回傳 Response</li>
</ul>
<p>假如是大型專案，可以更進一步簡化程式碼，例如把 index.js 中的 app 部分再獨立到專門管理路由的檔案，這部分我們之後會再介紹到。</p>
<h2 id="串接-Node-js-與-MySQL"><a href="#串接-Node-js-與-MySQL" class="headerlink" title="串接 Node.js 與 MySQL"></a>串接 Node.js 與 MySQL</h2><p>在瞭解到基本的 Express 架構之後，再來我們要試著把  todo 資料存在資料庫。這是因為在實際專案中，後端會把資料存放在資料庫，因此我們要來學習如何透過 Node.js 和 MySQL 溝通。</p>
<blockquote>
<p>注意不是用 Express 和 MySQL 溝通！我們要操作的是 Nodes.js，Express 提供的是框架！</p>
</blockquote>
<h3 id="Step1-安裝-MySQL"><a href="#Step1-安裝-MySQL" class="headerlink" title="Step1. 安裝 MySQL"></a>Step1. 安裝 MySQL</h3><p>在使用 Node.js 操作 MySQL 資料庫時，必須先安裝 MySQL 模組。搜尋 node.js mysql 會找到 GitHub 有個叫做 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL215c3FsanMvbXlzcWw=">mysqljs 的 Library<i class="fa fa-external-link-alt"></i></span>，執行安裝指令：</p>
<pre><code>$ npm install mysql</code></pre>
<p><img src="https://i.imgur.com/tR8kezb.png"></p>
<p>引入 MySQL 模組後，接著就可以進行資料庫的連線和其他操作了。</p>
<h3 id="Step2-新增-app-資料庫-amp-todos-資料表"><a href="#Step2-新增-app-資料庫-amp-todos-資料表" class="headerlink" title="Step2. 新增 app 資料庫 &amp;  todos 資料表"></a>Step2. 新增 app 資料庫 &amp;  todos 資料表</h3><p>之前在<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWJlMTAxLXBocC1hbmQtbXlzcWw=">第九週學到如何使用 MySQL 資料庫<i class="fa fa-external-link-alt"></i></span>，這一次我們同樣可以透過 phpmyadmin 這個 GUI 介面來進行資料庫 CURD，步驟如下：</p>
<ol>
<li>開啟 XAMPP 連線 MySQL，其實這樣就已經啟動資料庫了，但如果要使用 phpmyadmin 介面操作，就必須同時運行 Apache Server 才能使用：</li>
</ol>
<p><img src="https://i.imgur.com/kCpCApB.png"></p>
<ol start="2">
<li>接著建立一個 app database，並在裡面新增一個 todos table</li>
</ol>
<p><img src="https://i.imgur.com/Flh0kkx.png"></p>
<ol start="3">
<li>在 todos table 新增幾筆資料</li>
</ol>
<p><img src="https://i.imgur.com/Bd9TEJB.png"></p>
<h3 id="Step3-串接-MySQL-資料庫"><a href="#Step3-串接-MySQL-資料庫" class="headerlink" title="Step3. 串接 MySQL 資料庫"></a>Step3. 串接 MySQL 資料庫</h3><p>確認本地端已經安裝資料庫並正常啟動，接著就可以新增一個 db.js 檔來進行連線，程式碼可<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL215c3FsanMvbXlzcWwjaW50cm9kdWN0aW9u">參考範例<i class="fa fa-external-link-alt"></i></span>：</p>
<blockquote>
<p>要等待回傳一定是使用 callback，好處就是從同步變成非同步。</p>
</blockquote>
<pre><code class="javascript=">// 引入 mysql 模組
var mysql = require(&#39;mysql&#39;);
// 建立連線
var connection = mysql.createConnection(&#123;
  host: &#39;localhost&#39;,
  user: &#39;root&#39;,
  password: &#39;root&#39;,
  database: &#39;app&#39;
&#125;);

connection.connect();
// 使用 callback 來接收訊息: 連線成功就印出 todos 所有欄位
connection.query(&#39;SELECT * from todos&#39;, function (error, results, fields) &#123;
  if (error) throw error;
  console.log(results);
&#125;);

connection.end();</code></pre>
<p>接著在 CLI 介面執行 <code>node db.js</code>，如果有輸出資料就代表連線成功！</p>
<p><img src="https://i.imgur.com/UKf0NJ7.png"></p>
<p>其中 RowDataPacket 是一種自訂的資料格式，如果把 <code>console.log(results);</code> 改成：</p>
<pre><code class="javascript=">console.log(results[0].content);</code></pre>
<p>就會達到拿到第一個 todo 的內容：</p>
<p><img src="https://i.imgur.com/M9sO5ZS.png"></p>
<h3 id="補充：權限不足問題"><a href="#補充：權限不足問題" class="headerlink" title="補充：權限不足問題"></a>補充：權限不足問題</h3><p>其實自己當初在嘗試連線資料庫時，有出現權限錯誤的訊息：</p>
<pre><code>Error: ER_ACCESS_DENIED_ERROR: Access denied for user &#39;root&#39;@&#39;localhost&#39; (using passwo
rd: YES)</code></pre>
<p>後來是在使用者帳號頁面發現，root 這組帳號當初設定不用密碼就可以登入了，真是烏龍一場XD</p>
<p><img src="https://i.imgur.com/KGhvnqv.png"></p>
<h3 id="Step4-重構程式碼"><a href="#Step4-重構程式碼" class="headerlink" title="Step4. 重構程式碼"></a>Step4. 重構程式碼</h3><ol>
<li>將 db.js 簡化，獨立成串聯資料庫時需要的資料，方便其他部分要連線時引入：</li>
</ol>
<pre><code class="javascript=">var mysql = require(&#39;mysql&#39;);
var connection = mysql.createConnection(&#123;
  host: &#39;localhost&#39;,
  user: &#39;root&#39;,
  password: &#39;root&#39;,
  database: &#39;app&#39;
&#125;);

module.exports = connection;</code></pre>
<ol start="2">
<li>接著在 index.js 引入 db，也就是 mysql 模組以及連線資料，加上 <code>db.connect()</code> 指令來連線：</li>
</ol>
<pre><code class="javascript=">const express = require(&#39;express&#39;);
// 引入 db 資料庫: mysql 模組 &amp; 連線資料
const db = require(&#39;./db&#39;)
const app = express();
const port = 5001;

const todoController = require(&#39;./controllers/todo&#39;)

app.set(&#39;view engine&#39;, &#39;ejs&#39;)

app.get(&#39;/todos&#39;, todoController.getAll)
app.get(&#39;/todos/:id&#39;, todoController.get)

app.listen(port, () =&gt; &#123;
  // 連線資料庫
  db.connect()
  console.log(`Example app listening at http://localhost:$&#123;port&#125;`)
&#125;)</code></pre>
<ol start="3">
<li>再來是修改 Models，MVC 架構的好處就是能像這樣明確分工：</li>
</ol>
<blockquote>
<p>在使用 SQL 指令時須注意，字串拼接可能會有 SQL injection 的風險，可透過 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL215c3FsanMvbXlzcWwjcHJlcGFyaW5nLXF1ZXJpZXM=">Preparing Queries<i class="fa fa-external-link-alt"></i></span> 來避免，方法和 Prepared Statements 其實很類似。</p>
</blockquote>
<pre><code class="javascript=">// 引入 db，也就是 connection
const db = require(&#39;../db&#39;)

const todoModel = &#123;
  // 這裡要用 callback 來拿取資料
  getAll: (cb) =&gt; &#123;
    db.query(
      &#39;SELECT * FROM todos&#39;, (err, results) =&gt; &#123;
      if (err) return cb(err);
      // cb: 第一個參數為是否有錯誤，沒有的話就是 null，第二個才是結果
      cb(null, results)
    &#125;);
  &#125;,

  get: (id, cb) =&gt; &#123;
    db.query(
      &#39;SELECT * FROM todos WHERE id = ?&#39;, [id], (err, results) =&gt; &#123;
        if (err) return cb(err);
        cb(null, results)
      &#125;);
  &#125;
&#125;

module.exports = todoModel</code></pre>
<ol start="4">
<li>因為 Models 從同步改成非同步操作，也要修改 Controllers 的部分：</li>
</ol>
<pre><code class="javascript=">// 先從 model 引入 todos 資料
const todoModel = require(&#39;../models/todo&#39;)

const todoController = &#123;
  getAll: (req, res) =&gt; &#123;
    // 改成 callback 非同步操作
    todoModel.getAll((err, results) =&gt; &#123;
      // 如果有 err 就印出錯誤訊息
      if (err) return console.log(err);
      // 不然就把 todos 傳給 view
      res.render(&#39;todos&#39;, &#123;
        todos: results
      &#125;)
    &#125;)
  &#125;,

  get: (req, res) =&gt; &#123;
    const id = req.params.id
    todoModel.get(id, (err, results) =&gt; &#123;
      if (err) return console.log(err);
      res.render(&#39;todos&#39;, &#123;
        // 注意回傳的結果 array，必須取 results[0] 才會是一個 todo
        todos: results[0]
      &#125;)
    &#125;)
  &#125;
&#125;

module.exports = todoController</code></pre>
<ol start="5">
<li>再來是修改 Views 部分，Todos 部分有兩種寫法：</li>
</ol>
<ul>
<li>第一種：分開寫</li>
</ul>
<pre><code class="javascript=">&lt;h1&gt;Todos&lt;/h1&gt;

&lt;ul&gt;
&lt;% for(let i = 0; i &lt; todos.length; i++) &#123; %&gt;
  &lt;li&gt;&lt;%= todos[i].id %&gt;: &lt;%= todos[i].content %&gt;&lt;/li&gt;
&lt;% &#125; %&gt;
&lt;/ul&gt;</code></pre>
<ul>
<li>第二種：寫在一起，用字串拼接方式</li>
</ul>
<pre><code class="javascript=">&lt;h1&gt;Todos&lt;/h1&gt;

&lt;ul&gt;
&lt;% for(let i = 0; i &lt; todos.length; i++) &#123; %&gt;
  &lt;li&gt;&lt;%= todos[i].id + &#39;: &#39; + todos[i].content %&gt;&lt;/li&gt;
&lt;% &#125; %&gt;
&lt;/ul&gt;</code></pre>
<p>執行 <code>node index.js</code> 之後，回到瀏覽器確認程式是否有成功運行：</p>
<blockquote>
<p>這裡 port 之所以變成 5002，是因為前面在嘗試修改連線時，不知在哪個環節佔用了 5001，因此先改成另一個沒有使用的 port</p>
</blockquote>
<p><img src="https://i.imgur.com/aSpv3e4.png"></p>
<p>接著是 Todo，會發現輸出結果是 Object。這是因為 <code>&lt;%= %&gt;</code> 語法會直接印出字串，當我們想要把一個 Object 轉成字串時，就會發生下列情形：</p>
<p><img src="https://i.imgur.com/WMopGth.png"></p>
<p>只要將 Todo 部分修改成輸出 <code>todo.content</code>：</p>
<pre><code class="javascript=">&lt;h1&gt;Todo&lt;/h1&gt;

&lt;h2&gt;&lt;%= todo.content %&gt;&lt;/h2&gt;</code></pre>
<p>結果就會是相對應的 todo：</p>
<p><img src="https://i.imgur.com/02Wnbnb.png"></p>
<p>如果對資料庫操作 CURD，重整頁面也會動態更新：</p>
<p><img src="https://i.imgur.com/NZ0Hzj3.png"></p>
<p>學到目前為止，透過上面這些範例，我們其實已經能寫出一些簡單的網頁程式了，並且有 MVC 架構，能夠簡化程式碼且便於維護。</p>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>其實官網上的教學都已經蠻清楚了，但還是想跟著課程影片一步一步操作，一方面透過實作，發現可能會遇到哪些問題，一方面也能加深印象，讓自己更快去熟悉 Express 這套新工具。</p>
<p>也透過實作來複習之前講解過的 MVC 框架，透過將程式碼分成 Model、View 和 Controller 三個部分，再搭配不同 Route 分別進行處理，不但能夠簡化程式碼，也能透過分工便於後續維護。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jeXRoaWx5YS5naXRodWIuaW8vMjAxNC8xMS8yMy9ub2RlanMtZXhwcmVzcy1taWNyb2Jsb2cv">使用 Node.js + Express 建構一個簡單的微博網站<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9uaWNvbGFrYWNoYS5jb2RlcmJyaWRnZS5pby8yMDIwLzEwLzI1L2V4cHJlc3MtbXZjLXByYWN0aWNlLTEv">用 Express &amp; Sequelize 打造 MVC 餐廳網站（上）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>Back-End</tag>
        <tag>Express</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 16] JavaScript 進階 - 什麼是閉包？探討 Closure &amp; Scope Chain</title>
    <url>/javascript-closure/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvanMyMDEtamF2YXNjcmlwdA==">[JS201] 進階 JavaScript：那些你一直搞不懂的地方<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<a id="more"></a>

<p>在上一篇筆記 <span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWpzMjAxLXNjb3BlLWhvaXN0aW5n">[week 16] JavaScript 進階 - 初探 Hoisting &amp; Execution Context<i class="fa fa-external-link-alt"></i></span> 中，我們談到 Hoisting（提升）、Execution Context（執行環境）等相關概念。</p>
<p>瞭解到每一個 function 會有一個對應的執行環境，裡面負責存放該環境需要用到的各種資料，由這些參數組成 Variable Object（變數物件）。</p>
<p>包括之前談過的 VO，每個執行環境會有下列三個屬性：</p>
<ul>
<li>作用域鏈（Scope Chain）</li>
<li>變數物件（Variable Object）</li>
<li>‘this’ 變數（‘this’ Variable）</li>
</ul>
<p>而當中的作用域鏈（Scope Chain）其實就和本篇所要探討的 Closure（閉包）有關，因此下面會先從 Scope（作用域）開始講起。</p>
<pre><code>學習目標：

 P1 你知道什麼是作用域（Scope）
 P1 你知道 Closure（閉包）是什麼
 P1 你能夠舉出一個運用 Closure 的例子</code></pre>
<hr>
<h2 id="Scope-作用域"><a href="#Scope-作用域" class="headerlink" title="Scope 作用域"></a>Scope 作用域</h2><p>什麼是 Scope（作用域）？簡言之，就是「一個變數的生存範圍」，一旦出了這個範圍，就會無法存取到這個變數。</p>
<p>舉個簡單的例子，如果在 test() 中以 var 宣告變數 a，在 function 作用域之外會無法存取該變數：</p>
<pre><code class="javascript=">function test()&#123;
  var a = 10
&#125;
console.log(a)
// Uncaught ReferenceError: a is not defined</code></pre>
<p>在 ES6 以前，唯一產生作用域的方法就是宣告 function，每一個 function 都有自己的作用域，在作用域外就存取不到這個 function 內部所定義的變數。</p>
<p>在 ES6 出現以後，作用域的概念有些改變，也就是引入 let 跟 const 的宣告，可用大括號 <code>&#123;...&#125;</code> 來定義 block（區塊）作用域。</p>
<p>因此 JavaScript 的作用域其實可分為三個層級：</p>
<ul>
<li>Global Level Scope：全域作用域</li>
<li>Function Level Scope：函式作用域</li>
<li>Block Level Scope（ES6）：區塊作用域</li>
</ul>
<p>也就是說，變數作用域的範圍，其實就取決於這個變數的宣告方式，以及在哪進行宣告。</p>
<p>而根據變數是在哪宣告，又可分為全域變數和區域變數：</p>
<ul>
<li>全域變數（Global Variable）<ul>
<li>在 function 外宣告的變數</li>
<li>任何地方皆能存取到</li>
</ul>
</li>
<li>區域變數（Local Variable）<ul>
<li>在 function 內宣告的變數</li>
<li>只在該作用域內有效，也就是 function 本身及其內部</li>
</ul>
</li>
</ul>
<h3 id="Function-Scope-可能發生的問題"><a href="#Function-Scope-可能發生的問題" class="headerlink" title="Function Scope 可能發生的問題"></a>Function Scope 可能發生的問題</h3><p>接著要來談談 function 作用域中可能遇到的狀況，這可能會導致結果和想像的不同。</p>
<h4 id="狀況一：變數的值被覆蓋"><a href="#狀況一：變數的值被覆蓋" class="headerlink" title="狀況一：變數的值被覆蓋"></a>狀況一：變數的值被覆蓋</h4><p>若 var 變數不是宣告在 function 作用域內，而是在迴圈或是判斷式，這個變數可能就會覆蓋到外面的全域函數，造成變數汙染。</p>
<p>在下面的程式碼中，if 判斷式裡面的變數 str，會覆蓋外面的變數 str，因此結果是印出 Local：</p>
<pre><code class="javascript=">var str = &#39;Global&#39;;
if (true) &#123;
  var str = &#39;Local&#39;;
&#125;

console.log(str);
// Local</code></pre>
<h4 id="狀況二：迴圈變數可能會向外覆蓋全域變數"><a href="#狀況二：迴圈變數可能會向外覆蓋全域變數" class="headerlink" title="狀況二：迴圈變數可能會向外覆蓋全域變數"></a>狀況二：迴圈變數可能會向外覆蓋全域變數</h4><p>當 for 迴圈中的變數 i 循環結束時，會蓋過外面的全域變數 i，因此 function 外面的 i 會被重新賦值為 3：</p>
<pre><code class="javascript=">var str = &#39;cat&#39;;
var i = 1;
for (var i = 0; i &lt; str.length; i++) &#123;
    console.log(str[i]);      // 向外覆蓋全域變數
&#125;

console.log(i);
// c
// a
// t
// 3</code></pre>
<h3 id="E6-以後的作用域：Block-Scope"><a href="#E6-以後的作用域：Block-Scope" class="headerlink" title="E6 以後的作用域：Block Scope"></a>E6 以後的作用域：Block Scope</h3><p>接著再回到 ES6，新增了區塊作用域（block scope）的概念，也就是以 let 和 const 來宣告變數。</p>
<p>在第三週的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMC90aGlzLWlzLWNvZGVkaWFyeS9ibG9iL21hc3Rlci93ZWVrM19FUzYlMjBucG0lMjBKZXN0Lm1kI2VzNi0lRTYlOTYlQjAlRTglQUElOUUlRTYlQjMlOTU=">ES6 部份<i class="fa fa-external-link-alt"></i></span>我們也曾提到，以 let、const 或 var 方式來宣告變數，最大的差別在於變數的作用域範圍不同：</p>
<ul>
<li>var：作用於整個函數範圍中（function scope）</li>
<li>let 與 const：均為區塊作用域（block scope），如此可避免污染到大括號 <code>&#123;...&#125;</code> 外的變數</li>
</ul>
<p>而 let 和 const 最大的區別，在於該變數是否能被重新賦值：</p>
<ul>
<li>const（constant）：常數宣告後就不能再重新賦值，並且在宣告時就必須賦值</li>
<li>let：可重新賦值，也可先進行宣告但不賦值</li>
</ul>
<p>以下面程式碼為例，說明以 var 和 let 宣告變數會有什麼差別：</p>
<h4 id="用-var-在-for-迴圈宣告變數-i"><a href="#用-var-在-for-迴圈宣告變數-i" class="headerlink" title="用 var 在 for 迴圈宣告變數 i"></a>用 var 在 for 迴圈宣告變數 i</h4><p>先以 var 來宣告變數 i，for 迴圈結束後，外面的 log 結果是 3：</p>
<pre><code class="javascript=">function test() &#123;
  for(var i = 0; i &lt; 3; i++) &#123;
    console.log(&#39;i:&#39;, i);
  &#125;
  console.log(&#39;final value&#39;, i);
&#125;

test()
// i: 0
// i: 1
// i: 2
// final value 3</code></pre>
<h4 id="用-let-在-for-迴圈宣告變數-i"><a href="#用-let-在-for-迴圈宣告變數-i" class="headerlink" title="用 let 在 for 迴圈宣告變數 i"></a>用 let 在 for 迴圈宣告變數 i</h4><p>若改用 let 在 for 迴圈宣告變數，則會出現錯誤 <code>i is not defined</code>：</p>
<pre><code class="javascript=">function test() &#123;
  for(let i = 0; i &lt; 3; i++) &#123;
    console.log(&#39;i:&#39;, i);        // 
  &#125;
  console.log(&#39;final value&#39;, i);
&#125;

test();
// ReferenceError: i is not defined</code></pre>
<p>這是因為以 let 進行宣告，變數 i 的作用域就僅限於 for 迴圈這個 block 區塊，所以大括號外面就無法存取到變數 i。</p>
<h3 id="作用域會往外層找"><a href="#作用域會往外層找" class="headerlink" title="作用域會往外層找"></a>作用域會往外層找</h3><p>記住這個重點：「作用與會往外層找」。也就是說，在 function 外面會存取不到裡面，但內層可以存取到外層的東西。</p>
<p>舉下面幾個程式碼作為範例。</p>
<h4 id="範例一：從-function-外往內存取變數"><a href="#範例一：從-function-外往內存取變數" class="headerlink" title="範例一：從 function 外往內存取變數"></a>範例一：從 function 外往內存取變數</h4><p>結果會出現錯誤 <code>a is not defined</code>：</p>
<pre><code class="javascript=">function test() &#123;
  var a = 10;
  console.log(a);
&#125;

test();
console.log(a);
// ReferenceError: a is not defined`</code></pre>
<p>這是因為在 function 外面沒辦法存取內部的變數 a，所以會出現錯誤。</p>
<h4 id="範例二：存取-function-以及-global-變數"><a href="#範例二：存取-function-以及-global-變數" class="headerlink" title="範例二：存取 function 以及 global 變數"></a>範例二：存取 function 以及 global 變數</h4><p>若分別宣告全域變數和區域變數，log 結果不會互相干擾：</p>
<pre><code class="javascript=">var a = 20          // global variable
function test() &#123;
  var a = 10;       // function variable 
  console.log(a);    // 10
&#125;

test();
console.log(a);      // 20</code></pre>
<h4 id="範例三：直接在-function-內部賦值"><a href="#範例三：直接在-function-內部賦值" class="headerlink" title="範例三：直接在 function 內部賦值"></a>範例三：直接在 function 內部賦值</h4><p>結果全域和區域的兩個 a，其 log 結果會相同：</p>
<pre><code class="javascript=">var a = 20;          // global variable
function test() &#123;
  a = 10;
  console.log(a);    // 10，function -&gt; global
&#125;

test();
console.log(a);      // 10</code></pre>
<p>原因在於，即使 function 內沒有宣告變數，仍會「往外」找到已經被宣告的全域變數 <code>var a</code>，然後再回到內部賦值 <code>a = 10</code>。</p>
<p>變數會先在自己的作用域找，若找不到會繼續再往外找，一層一層直到找到為止。而這一連串的行為，就稱作 Scope Chain（作用域鏈），詳細內容稍後會再進行說明。</p>
<h4 id="範例四：function-內外都沒有宣告變數"><a href="#範例四：function-內外都沒有宣告變數" class="headerlink" title="範例四：function 內外都沒有宣告變數"></a>範例四：function 內外都沒有宣告變數</h4><p>結果仍會和上述範例相同！</p>
<pre><code class="javascript=">function test() &#123;
  a = 10;
  console.log(a);    // 10，test -&gt; global
&#125;

test();
console.log(a);      // 10</code></pre>
<p>這是因為，在 function 中如果 a 找不到值，就會往外層找，如果全域也找不到，就會自動宣告全域變數 <code>var a</code>。</p>
<p>這會和前一個例子寫法產生相同結果，但這種情況其實會產生一些 bug，也就是和預期行為不同，甚至可能產生衝突。</p>
<h2 id="Scope-Chain-作用域鏈"><a href="#Scope-Chain-作用域鏈" class="headerlink" title="Scope Chain 作用域鏈"></a>Scope Chain 作用域鏈</h2><p>在說明之前，先來看以下範例：</p>
<pre><code class="javascript=">function test() &#123;
  var a = 100
  function inner() &#123;
    console.log(a) // 100
  &#125;
  inner()
&#125;
test()</code></pre>
<p>在 inner() 中，a 並非該函式中的變數，而這種不在該 function 作用域中，也不是作為參數傳進來的變數，就被稱為 Free Variable（自由變數）。</p>
<p>對 inner() 來說，a 是一個自由變數。因為在 inner() 的作用域中找不到 a，就會往外層 test() 找，如果還是找不到會再往外直到找到為止。</p>
<p>這其實就構成一個 Scope Chain（作用域鏈）：inner function scope -&gt; test function scope -&gt; global scope，如果直到全域作用域還是找不到，就會拋出錯誤。</p>
<p>還記得我們在開頭提到，每個執行環境物件會有下列三個屬性：</p>
<ul>
<li>作用域鏈（Scope Chain）</li>
<li>變數物件（Variable Object）</li>
<li>‘this’ 變數（‘this’ Variable）</li>
</ul>
<p>而 Scope Chain 這個屬性，其實就是負責記錄「包含自己的 VO + 所有上層執行環境的 VO」的集合。藉由該屬性，函式內部就可以存取到外部的變數。　</p>
<p>聽起來有點抽像，我們舉個簡單的例子：</p>
<pre><code class="javascript=">function one() &#123;
  var a = 1;
  two();
  function two() &#123;
    var b = 2;
    three();
    function three() &#123;
      var c = 3;
      console.log(a + b + c);   // 6
    &#125;
  &#125;
&#125;

one();</code></pre>
<p>從 Global Context 呼叫 one()，one() 再呼叫 two()，接著再呼叫 three()，最後在 function three 執行 console.log()。下圖在建立階段的堆疊示意圖：</p>
<p><img src="https://i.imgur.com/RtkT8LP.png"></p>
<p>當 JavaScript 要執行 <code>console.log(a + b + c)</code> 這行程式，會不斷往 Scope Chain 去尋找。</p>
<p>就像前面所說的，一開始會先在自己的 VO 找，找不到在換下一個，一直到 global 為止，如果找不到就會拋出錯誤。過程如下圖：</p>
<p><img src="https://i.imgur.com/9ROutJb.png"></p>
<p>（圖片來源：<span class="exturl" data-url="aHR0cHM6Ly9hbmR5eW91LmdpdGh1Yi5pby8yMDE1LzA0LzIwL3VuZGVyc3RhbmQtY2xvc3VyZXMtYW5kLXNjb3BlLWNoYWluLw==">https://andyyou.github.io/2015/04/20/understand-closures-and-scope-chain/<i class="fa fa-external-link-alt"></i></span> ）</p>
<h3 id="ECMAScript-中的作用域"><a href="#ECMAScript-中的作用域" class="headerlink" title="ECMAScript 中的作用域"></a>ECMAScript 中的作用域</h3><p>每個執行環境都有一個 Scope Chain。也就是說，一旦進入該執行環境，就會建立 Scope Chain 並進行初始化。</p>
<p>以 global 執行環境來說，初始化後會把 VO 放進 Scope Chain 內，可表示為：</p>
<pre><code class="javascript=">scopeChain = [globalEC.VO]</code></pre>
<p>此外，每個函式都有一個 [[Scope]] 屬性，當 global 執行環境遇到函式時，會將它初始化為 global 執行環境的 Scope Chain：</p>
<pre><code class="javascript=">function.[[Scope]] = globalEC.scopeChain</code></pre>
<p>當函式被呼叫時，會建立 local 執行環境，也會建立 VO，在函式中會稱作 Activation Object（AO），並且除了 AO 之外，外面傳進來的參數也會被加到該 local 執行環境的 Scope Chain：</p>
<pre><code class="javascript=">function.scopeChain = [function.AO, function.[[Scope]]]</code></pre>
<h3 id="模擬-JS-實際流程"><a href="#模擬-JS-實際流程" class="headerlink" title="模擬 JS 實際流程"></a>模擬 JS 實際流程</h3><p>舉個簡單的範例：</p>
<pre><code class="javascript=">var a = 1;
function test() &#123;
  var b = 2;
  function inner() &#123;
    var c = 3;
    console.log(c);   
    console.log(b);
    console.log(a);
  &#125;
  inner();
&#125;

test();</code></pre>
<h4 id="第一步：進入-Global-執行環境"><a href="#第一步：進入-Global-執行環境" class="headerlink" title="第一步：進入 Global 執行環境"></a>第一步：進入 Global 執行環境</h4><p>首先進入 Global EC，並初始化 VO 以及 scope chain。前面提到 scope chain = activation object + [[Scope]]，但因為這不是一個 function，所以沒有[[Scope]] 和 AO，會直接以 VO 來用：</p>
<pre><code class="javascript=">global EC &#123;
  VO: &#123;
    a: undefined,
    test: function
  &#125;,
  scopeChain: [globalEC.VO]
&#125;

test.[[Scope]] = globalEC.scopeChain</code></pre>
<p>此外也需設置 function 的 [[Scope]]，所以 test() 的[[Scope]] 就會是 globalEC.scopeChain，也就是 globalEC.VO。</p>
<h4 id="第二步：建立-test-執行環境"><a href="#第二步：建立-test-執行環境" class="headerlink" title="第二步：建立 test 執行環境"></a>第二步：建立 test 執行環境</h4><p>執行完 <code>var a = 1</code> 後，將 global EC 的 VO 初始為 1。</p>
<p>接著準備進入 test()，在進入之前會先建立 test EC 並初始化 AO 以及 scope chain ：</p>
<pre><code class="javascript=">testEC: &#123;
  AO: &#123;
    b: undefined,
    inner: function
  &#125;
    scopeChain: [testEC.AO, test[[Scope]]]
    =&gt; [testEC.AO, globalEC.VO]
&#125;

inner.[[Scope]] = testEC.scopeChain
= [testEC.AO, test[[Scope]]]

======

global EC &#123;
  VO: &#123;
    a: 1,
    test: function
  &#125;,
  scopeChain: [globalEC.VO]
&#125;

test.[[Scope]] = globalEC.scopeChain
= [globalEC.VO]</code></pre>
<p>同裡，需設置 function inner() 的 [[Scope]]，可表示為 testEC.scopeChain，又等同於 [testEC.AO, test[[Scope]]]。</p>
<h4 id="第三步：建立-inner-執行環境"><a href="#第三步：建立-inner-執行環境" class="headerlink" title="第三步：建立 inner 執行環境"></a>第三步：建立 inner 執行環境</h4><p>執行完 <code>var b = 2</code> 後，將 test EC 的 AO 初始為 2。</p>
<p>接著進入 inner() 時同樣會建立 inner EC 跟 AO 建立，然後執行完 <code>var c = 3</code> 後，將 inner EC 的 AO 初始為 3：</p>
<pre><code class="javascript=">innerEC: &#123;
  AO: &#123;
    c: 3
  &#125;,
  scopeChain: [innerEC.AO, inner[[Scope]]]
    =&gt; [inner.AO, testEC.scopeChain]
    =&gt; [inner.AO, testEC.AO, globalEC.VO]
&#125;

testEC: &#123;
  AO: &#123;
    b: 2,
    inner: function
  &#125;
    scopeChain: [testEC.AO, test[[Scope]]]
    =&gt; [testEC.AO, globalEC.VO]
&#125;

inner.[[Scope]] = testEC.scopeChain
= [testEC.AO, test[[Scope]]]

======

global EC &#123;
  VO: &#123;
    a: 1,
    test: function
  &#125;,
  scopeChain: [globalEC.VO]
&#125;

test.[[Scope]] = globalEC.scopeChain
= [globalEC.VO]</code></pre>
<h4 id="第四部：執行程式碼"><a href="#第四部：執行程式碼" class="headerlink" title="第四部：執行程式碼"></a>第四部：執行程式碼</h4><ul>
<li>執行到 <code>console.log(c)</code><ul>
<li>在 <code>innerEC.AO</code> 裡面找到 c = 3</li>
</ul>
</li>
<li>執行到 <code>console.log(b)</code><ul>
<li>在 <code>innerEC.AO</code> 裡找不到</li>
<li>沿著 scopeChain 往上找到 <code>testEC.AO</code> 裡面 b = 2</li>
</ul>
</li>
<li>執行到 <code>console.log(a)</code><ul>
<li>在 <code>innerEC.AO</code> 裡找不到</li>
<li>沿著 scopeChain 往上找到 <code>globalEC.AO</code> 裡面 a = 3</li>
</ul>
</li>
</ul>
<pre><code class="javascript=">var a = 1;
function test() &#123;
  var b = 2;
  function inner() &#123;
    var c = 3;
    console.log(c);  // 3
    console.log(b);  // 2
    console.log(a);  // 1
  &#125;
  inner();
&#125;

test();</code></pre>
<p>如同前面所說，其實 Scope Chain 就是 VO/AO 的組合，是負責記錄「包含自己的 VO + 所有上層執行環境的 VO」的集合。</p>
<p>藉由編譯完成時的 EC 模型，我們可瞭解程式在執行時，是如何在 AO 或 VO 裡面找到宣告過的變數，若在該作用域找不到，就會沿著 scopeChain 不斷會往上一層找。</p>
<p>這其實能夠解釋之前提過的 Hoisting（提升），還有接下來要探討的 Closure（提升）是如何發生。</p>
<h3 id="Lexical-Scope-vs-Dynamic-Scope"><a href="#Lexical-Scope-vs-Dynamic-Scope" class="headerlink" title="Lexical Scope vs Dynamic Scope"></a>Lexical Scope vs Dynamic Scope</h3><p>有了基本概念後，再來看下列範例，其中 a 的 log 值會是多少呢？</p>
<pre><code class="javascript=">var a = 100
function echo() &#123;
  console.log(a) // 100 or 200?
&#125;

function test() &#123;
  var a = 200
  echo()
&#125;

test()</code></pre>
<p>結果會是 100，echo() 裡面的 a 就是 global 的 a，和 test() 裡面的 a 一點關係都沒有。</p>
<p>這和程式語言是如何決定「作用域」這件事有關，可分為靜態作用域和動態作用域：</p>
<ul>
<li>Static Scope 靜態作用域<ul>
<li>又可稱為 Lexical Scope 語法作用域、語彙範疇</li>
<li>變數的作用域在語法解析時，就已經確定作用域，且不會改變</li>
</ul>
</li>
<li>Dynamic Scope 動態作用域<ul>
<li>變數的作用域在函式調用時才決定</li>
<li>若是採用動態作用域的程式語言，那最後 log 出來的值就會是 200 而不是 100</li>
</ul>
</li>
</ul>
<p>而 JavaScript 採用的是靜態作用域，在分析程式碼的結構就可以知道作用域的長相。但需特別注意的是，JavaScript 中的 <code>this</code>，其原理和動態作用域非常類似，this 的值會在程式執行時才被動態決定。</p>
<p>建立一些有關作用域的觀念後，再來我們要來談談本篇核心：Closure（閉包）。</p>
<hr>
<h2 id="Closure-閉包"><a href="#Closure-閉包" class="headerlink" title="Closure 閉包"></a>Closure 閉包</h2><p>在 JavaScript 中，Closure（閉包）和作用域的關係密不可分，透過 Scope Chain 的機制，我們能夠進一步理解 Closure 產生的原因。</p>
<p>可先來看看下方這個例子：</p>
<pre><code class="javascript=">function test() &#123;
  var a = 10;
  function inner() &#123;
    a++;
    console.log(a)
  &#125;
  return inner // 不加括號，只 return 這個 function
&#125;
var func = test()
func() // 11 =&gt; 等同於 inner()
func() // 12 =&gt; 等同於 inner()
func() // 13 =&gt; 等同於 inner()</code></pre>
<p>透過在 function 中回傳另一個 function 的寫法，就可以把 a 這個變數鎖在這個 function 裡面，隨時能夠拿出來使用。</p>
<p>一般而言，當 function 被執行完之後，資源就會被釋放掉，但是通過這種寫法，我們就可以把 function 內部變數的值給保存起來。</p>
<p>再根據 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9DbG9zdXJlcw==">MDN<i class="fa fa-external-link-alt"></i></span> 說明，其實閉包就是一個特殊的物件，具有下列兩個含義：</p>
<ul>
<li>它是一個 function</li>
<li>它產生了一個 context 執行環境，負責記錄上層 VO</li>
</ul>
<p>再舉個有關 Closure 的例子：</p>
<pre><code class="javascript=">function factory() &#123;
  var brand = &quot;BMW&quot;;

  return function car() &#123;
    console.log(&quot;This is a &quot; + brand + &quot; car&quot;);
  &#125;
&#125;

var carMaker = factory();
carMaker();  //  &quot;This is a BMW car</code></pre>
<p>上述程式碼建立的 EC 模型：</p>
<pre><code class="javascript=">// Global Context
global.VO = &#123;
  factory: pointer to factory(),
  carMaker: 是 global.VO.factory 的回傳值
  scopeChain: [global.VO]
&#125;

// Factory 執行環境
factory.VO = &#123;
  car: pointer to car(),
  brand: &#39;BMW&#39;,
  scopeChain: [factory.VO, global.VO]
&#125;

// car 執行環境
car.VO = &#123;
  scopeChain = [car.VO, factory.VO, global.VO]
&#125;</code></pre>
<p>以 JS 運作過程來說， function factory 執行結束後就會從 Call Stack 移除，但是因為 VO 還會被 car VO 參考，所以不會將其移除。</p>
<p>這其實就是前面所提到的 Scope Chain 與 Closure 之間的關係。</p>
<h3 id="操作-Closure-可能遇到的作用域陷阱"><a href="#操作-Closure-可能遇到的作用域陷阱" class="headerlink" title="操作 Closure 可能遇到的作用域陷阱"></a>操作 Closure 可能遇到的作用域陷阱</h3><p>由以下範例，可發現執行 <code>arr[0]()</code> 時，結果會是 5：</p>
<pre><code class="javascript=">var arr = [];
for (var i = 0; i &lt; 5; i++) &#123;
  arr[i] = function() &#123;
      console.log(i);
  &#125;
&#125;

arr[0]();  // 5</code></pre>
<p>當執行 <code>arr[0]()</code> 時，其實會長這樣：</p>
<pre><code class="javascript=">arr[0] = function() &#123;
  console.log(i);
&#125;</code></pre>
<p>因為 function EC 中沒有宣告變數 i，因此會往上一層作用域找，找到 global EC 的 i，又因為 for 迴圈執行結束，此時的 i = 5，所以會印出 5。</p>
<p>可使用下列方法改寫上述程式碼：</p>
<h4 id="1-使用閉包：在-function-中-return-function"><a href="#1-使用閉包：在-function-中-return-function" class="headerlink" title="1. 使用閉包：在 function 中 return function"></a>1. 使用閉包：在 function 中 return function</h4><pre><code class="javascript=">var arr = [];
for (var i = 0; i &lt; 5; i++) &#123;
  arr[i] = logN(i);
&#125;

function logN(n) &#123;
  return function() &#123;
      console.log(n);
  &#125;
&#125;

arr[0]();  // 0</code></pre>
<h4 id="2-IIFE：立即呼叫函式"><a href="#2-IIFE：立即呼叫函式" class="headerlink" title="2. IIFE：立即呼叫函式"></a>2. IIFE：立即呼叫函式</h4><ul>
<li>IIFE：Immediately Invoked Function Expression，是一個在宣告的當下就會馬上被執行的函數。語法如下：</li>
</ul>
<pre><code class="javascript=">(function () &#123;
  console.log(&#39;hello&#39;)
&#125;)()
// hello</code></pre>
<p>因此範例程式碼可修改成，這樣就不用再另外宣告 function，但缺點是可讀性較差：</p>
<pre><code class="javascript=">var arr = [];
for (var i = 0; i &lt; 5; i++) &#123;
  arr[i] = (function(n) &#123;
    return function() &#123;
      console.log(n);
    &#125;;
  &#125;)(i)
&#125;
arr[0]();  // 0</code></pre>
<h4 id="3-使用-let-宣告：限定變數的作用域"><a href="#3-使用-let-宣告：限定變數的作用域" class="headerlink" title="3. 使用 let 宣告：限定變數的作用域"></a>3. 使用 let 宣告：限定變數的作用域</h4><pre><code class="javascript=">var arr = [];
for (let i = 0; i &lt; 5; i++) &#123;
  arr[i] = function() &#123;
    console.log(i);
  &#125;
&#125;

arr[0]();  // 0</code></pre>
<p>執行 <code>arr[0]()</code> 時可以表示成：</p>
<pre><code class="javascript=">var arr = [];
&#123;
  let i = 0;
  arr[0] = function() &#123;
    console.log(i);
  &#125;
&#125;

arr[0]();  // 0</code></pre>
<h2 id="Closure-實際應用"><a href="#Closure-實際應用" class="headerlink" title="Closure 實際應用"></a>Closure 實際應用</h2><p>那我們通常會在什麼情況下使用 Closure 呢？像是在計算量很大的時候，或是需要隱藏一些內部資訊。方法如下：</p>
<h3 id="1-封裝"><a href="#1-封裝" class="headerlink" title="1. 封裝"></a>1. 封裝</h3><p>可將一些不想外露的細節封裝在執行環境中，只露出想要 public 部分。</p>
<p>以下方與金源有關的程式碼為例：</p>
<pre><code class="javascript=">var money = 99
function add(num) &#123;
  money += num
&#125;
function deduct(num) &#123;
  if (num &gt;= 10) &#123;
    money -= 10;
  &#125;
&#125;
add(1)
deduct(100)
console.log(money)</code></pre>
<p>在這種情況之下，任何人都能夠變動 global 中變數 money 的值。</p>
<p>如果改成使用閉包，就能夠把變數給隱藏起來，無法從外部更改 function 內部資料：</p>
<pre><code class="javascript=">function createWallet(initMoney) &#123;
  var money = initMoney;
  return &#123;
    add: function(num) &#123;
      money += num;
    &#125;,
    deduct: function(num) &#123;
      if (num &gt;= 10) &#123;
        money -= 10;
      &#125; else &#123;
        money -= num
      &#125;
    &#125;,
    getMoney() &#123;
      return money;
    &#125;
  &#125;
&#125;
var myWallet = createWallet(99);
myWallet.add(1);
myWallet.deduct(100);
console.log(myWallet.getMoney()); // 90</code></pre>
<h3 id="2-Callbacks-回呼"><a href="#2-Callbacks-回呼" class="headerlink" title="2. Callbacks 回呼"></a>2. Callbacks 回呼</h3><p>callback funtcion 就是一種常見的閉包。先前提到像 JavaScript 就是採用單執行緒與 Event Loop 機制，一次只能處理一件事情。</p>
<p>但以 callback 能讓我們能夠延遲函式的調用，實現非同步操作。例如呼叫一個 AJAX 的 XMLHttpRequest，通常就會使用 callback 來處理伺服器的回應，因此等待時其他程式還是能照常運作。</p>
<h2 id="何時不該使用-Clousre？"><a href="#何時不該使用-Clousre？" class="headerlink" title="何時不該使用 Clousre？"></a>何時不該使用 Clousre？</h2><p>雖然 Closure 提供非常便利的功能，但因為系統效能的因素，還是必須謹慎使用：</p>
<h3 id="1-過多的作用域"><a href="#1-過多的作用域" class="headerlink" title="1. 過多的作用域"></a>1. 過多的作用域</h3><p>需注意每當需要取得一個變數時，Scope Chain 會一層一層檢索，直到找到該物件或值，因此越多層會導致需時越長，例如多個巢狀 function。</p>
<h3 id="2-記憶體回收"><a href="#2-記憶體回收" class="headerlink" title="2. 記憶體回收"></a>2. 記憶體回收</h3><p>記憶體回收（Garbage Collection）機制，簡單來說，就是當物件不再被參考時，就會被記憶體回收處理。</p>
<p>但如果是在不正確使用閉包的情況下，就可能導致記憶體洩漏（Memory Leak），造成程式未能釋放已經不再使用的記憶體，並產生效能問題。</p>
<p>以下方的程式碼為例：</p>
<pre><code class="javascript=">function leakyFn() &#123;
  leak = 100
&#125;
leakyFn()
console.log(leak)  // 100</code></pre>
<p>若在非 strict 模式下執行，JavaScript 會自動宣告一個全域變數 <code>var leak</code>，因此就算函數執行完畢，leak 還是會繼續存留在 全域環境中，因此也就不會被回收掉。</p>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>在學到 Closure（閉包）時，發現到花了很多時間在瞭解有關 Scope（作用域）的概念。也是在這一單元瞭解到，原來之前在課程學到的非同步操作，當中的 callback 其實就和閉包有關，有關 callback 的觀念真的非常重要！</p>
<p>此外也瞭解到，閉包在框架中很常會使用到，透過閉包的方式，就能夠避免汙染全域變數或是記憶體洩漏等問題。</p>
<p>一開始之所以沒辦法很快理解，或許就是沒有把這些觀念融會貫通，都是一個環節接著另一個環節，和 Scope Chain 一樣，會需要往上一層去找出需要的拼圖。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmh1bGkudHcvMjAxOC8xMi8wOC9qYXZhc2NyaXB0LWNsb3N1cmUv">所有的函式都是閉包：談 JS 中的作用域與 Closure<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hbmR5eW91LmdpdGh1Yi5pby8yMDE1LzA0LzIwL3VuZGVyc3RhbmQtY2xvc3VyZXMtYW5kLXNjb3BlLWNoYWluLw==">參透Javascript閉包與Scope Chain<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9odWdoLXByb2dyYW0tbGVhcm5pbmctZGlhcnktanMubWVkaXVtLmNvbS8lRTUlODklOEQlRTclQUIlQUYlRTQlQjglQUQlRTklOUElOEUtanMlRTQlQkIlQTQlRTQlQkElQkElRTYlOTAlOUUlRTQlQjglOEQlRTYlODclODIlRTclOUElODQlRTUlOUMlQjAlRTYlOTYlQjktY2xvc3VyZS0lRTklOTYlODklRTUlOEMlODUtY2JiOWM2YTQxODVj">前端中階：JS令人搞不懂的地方-Closure(閉包)<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Closure</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 16] JavaScript 進階 - 初探 Hoisting &amp; Execution Context</title>
    <url>/javascript-hoisting/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvanMyMDEtamF2YXNjcmlwdA==">[JS201] 進階 JavaScript：那些你一直搞不懂的地方<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<pre><code>學習目標：

  你知道 Hoisting（提升）是什麼
  你知道 Hoisting 的原理為何
  你知道 Hoisting 只會提升宣告而非賦值
  你知道 function 宣告、function 的參數以及一般變數宣告同時出現時的提升優先順序
  你知道 let 跟 const 其實也有 Hoisting，只是表現形式不太相同</code></pre>
<a id="more"></a>

<hr>
<h2 id="什麼是-Hoisting？"><a href="#什麼是-Hoisting？" class="headerlink" title="什麼是 Hoisting？"></a>什麼是 Hoisting？</h2><p>如果我們試圖在 JavaScript 中，對一個尚未宣告的變數取值，會出現 <code>a is not defined</code> 的錯誤訊息：</p>
<pre><code class="javascript=">console.log(a)
// ReferenceError: a is not defined</code></pre>
<p>但如果在下面加上一行 <code>var a = 10</code>，也就是宣告變數 a，神奇的事就發生了：</p>
<pre><code class="javascript=">console.log(a);
var a = 10;
// undefined

=== 經過 Hoisting ===

var a;
console.log(a);
a = 10;
// undefined</code></pre>
<p>我們知道，在 JavaScript 中程式是一行一行執行的。但是在上方程式碼的情況下，console.log() 的變數 a 卻能夠先被宣告，然後輸出 undefined，可以想成下方的程式碼。</p>
<p>這種現象就叫做 Hoisting（提升），會發生在變數宣告。也就是說，當我們宣告一個變數時，宣告本身會被提升至程式碼最上面，而賦值則留在原處，因此也就不會出現 <code>a is not defined</code> 的錯誤。</p>
<p>或是以我們熟悉的宣告 function 為例，就算在宣告以前就先呼叫它，還是能夠順利執行：</p>
<pre><code class="javascript=">test();

function test() &#123;
  console.log(123);
&#125;
// 123

=== 經過 Hoisting ===

function test() &#123;
  console.log(123);
&#125;

test();
// 123</code></pre>
<p>因為整段 function 會被提升到上面，所以不管在哪呼叫 function 都能夠執行。</p>
<p>這在有些程式語言其實是做不到的，但在 JavaScript 進行宣告能夠做到提升，也使程式碼撰寫更加方便。</p>
<h3 id="只有宣告會提升，賦值不會提升"><a href="#只有宣告會提升，賦值不會提升" class="headerlink" title="只有宣告會提升，賦值不會提升"></a>只有宣告會提升，賦值不會提升</h3><p>但需注意的是，只有「宣告」會被提升到最上方，但「賦值」不會。</p>
<p>若宣告一個變數，並賦值為 function 時，以下方程式碼為例：</p>
<ol>
<li>若把呼叫改寫在 function 後面，能夠順利執行：</li>
</ol>
<pre><code class="javascript=">var test = function() &#123;
  console.log(123);
&#125;

test();
// 123</code></pre>
<ol start="2">
<li>若把呼叫改寫在 function 前面，則會出現「test 不是 function」的錯誤：</li>
</ol>
<pre><code class="javascript=">test();

var test = function() &#123;
  console.log(123);
&#125;
// TypeError: test is not a function

=== 經過 Hoisting ===

var test;
test();

test = function() &#123;
  console.log(123);
&#125;
</code></pre>
<p>之所以會出現錯誤，是因為即使經過提升先宣告變數 <code>var = test</code>，卻無法先賦值。因此呼叫的 <code>test()</code> 其實是 undefined 而非 function，所以執行就會顯示錯誤。</p>
<h2 id="Hoisting-的順序"><a href="#Hoisting-的順序" class="headerlink" title="Hoisting 的順序"></a>Hoisting 的順序</h2><h3 id="情境一：同時宣告函式與變數"><a href="#情境一：同時宣告函式與變數" class="headerlink" title="情境一：同時宣告函式與變數"></a>情境一：同時宣告函式與變數</h3><p>那如果同時宣告一個 function 和變數呢？</p>
<p>以下列程式碼為例：</p>
<pre><code class="javascript=">console.log(a);   // [Function: a]
var a = &#39;global&#39;;

function a() &#123;
  var a = &#39;local&#39;;
&#125;</code></pre>
<p>會發現答案既不是 global 也非 local，而是輸出 function。</p>
<p>這是因為除了宣告變數以外，function 的宣告也會提升，而且「<strong>function 的提升會優先於變數的提升</strong>」。</p>
<h3 id="情境二：重複的函式"><a href="#情境二：重複的函式" class="headerlink" title="情境二：重複的函式"></a>情境二：重複的函式</h3><p>如果有兩個相同的 function，則會依照順序，提升比較後面宣告的 function：</p>
<pre><code class="javascript=">function test() &#123;
  a();
  function a() &#123;
    console.log(1);
  &#125;;
  function a() &#123;
    console.log(2);
  &#125;;
&#125;

test();
// 2

=== 經過 Hoisting ===

function test() &#123;
  /* 會優先提升後面的函式
  function a() &#123;
    console.log(1);
  &#125;;
  */ 
  function a() &#123;
    console.log(2);
  &#125;
  a();
&#125;

test();
// 2</code></pre>
<h3 id="情境三：傳入參數到-function"><a href="#情境三：傳入參數到-function" class="headerlink" title="情境三：傳入參數到 function"></a>情境三：傳入參數到 function</h3><p>在探討參數之前，先來複習參數和引數的區別：</p>
<ul>
<li>參數（Parameter）：是方法的宣告</li>
<li>引數（Argument）：用於呼叫函式</li>
</ul>
<blockquote>
<p>可參考：<span class="exturl" data-url="aHR0cHM6Ly9ub3RmYWxzZS5uZXQvNi9hcmctdnMtcGFyYW0=">引數(Argument) vs. 參數(Parameter) - NotFalse 技術客<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>因此，當我們傳入參數到 function 時，其實指的就是引數（argument），而 argument 的宣告會優先於被提升的變數宣告。</p>
<p>以下方傳入參數的程式碼為例：</p>
<pre><code class="javascript=">function test(a) &#123;
  console.log(a)
  var a = 456
&#125;

test(123)
// 123

=== 經過 Hoisting ===

function test(a) &#123;
  var a;      // 宣告變數就沒用了QQ
  console.log(a);
  a = 456;
&#125;

test(123)    // argument 的宣告優先度較高
// 123</code></pre>
<p>那如果同時宣告 function 和 argument 呢？宣告 function 會優先於 argument 的宣告：</p>
<pre><code class="javascript=">function test(a) &#123;
  console.log(a);
  function a() &#123;
  &#125;;
&#125;

test(123);
// [Function a]

=== 經過 Hoisting ===

function test(a) &#123;
    function a () &#123;  // 函式的宣告優先度較高
    &#125;;
    console.log(a);
&#125;

test(123);  // 參數寫多少都沒用QQ
// [Function a]</code></pre>
<h3 id="情境四：宣告變數並賦值"><a href="#情境四：宣告變數並賦值" class="headerlink" title="情境四：宣告變數並賦值"></a>情境四：宣告變數並賦值</h3><p>但如果是在函式內「宣告變數並賦值」的話，結果就不相同了：</p>
<pre><code class="javascript=">function test(a) &#123;
  console.log(a);
  var a = &#39;hello&#39;
  console.log(a);

  function a () &#123;
    console.log(2);
  &#125;;
&#125;

test(123)

=== 經過 Hoisting ===

function test(a) &#123;
  function a () &#123;     // 函式宣告提升
    console.log(2);
  &#125;
  console.log(a);    // [Function: a] 

  var a = &#39;hello&#39;;    // 賦值
  console.log(a);     // hello
&#125;

test(123);        // 參數還是沒用QQ</code></pre>
<p>綜合上述幾個例子，可整理出有關 Hoisting 的幾個重點：</p>
<ul>
<li>Hoisting 的優先順序為：</li>
</ul>
<ol>
<li>函式宣告（function）</li>
<li>傳進函式的參數（argument）</li>
<li>變數宣告（variable）</li>
</ol>
<ul>
<li>只有宣告會提升，賦值不會提升</li>
</ul>
<h3 id="小試身手"><a href="#小試身手" class="headerlink" title="小試身手"></a>小試身手</h3><p>最後再來進行這個小測驗，判斷 log 值依序是什麼：</p>
<pre><code class="javascript=">var a = 1;
function test()&#123;
  console.log(&#39;1.&#39;, a);
  var a = 7;
  console.log(&#39;2.&#39;, a);
  a++;
  var a;
  inner();
  console.log(&#39;4.&#39;, a);
  function inner()&#123;
    console.log(&#39;3.&#39;, a);
    a = 30;
    b = 200;
  &#125;
&#125;
test();
console.log(&#39;5.&#39;, a);
a = 70;
console.log(&#39;6.&#39;, a);
console.log(&#39;7.&#39;, b);</code></pre>
<p>思考方式：</p>
<ul>
<li><code>console.log(&#39;1.&#39;, a)</code></li>
</ul>
<p>先看執行函式 test()，因為函式內有宣告變數，所以會提升，得到 a = undefined。</p>
<ul>
<li><code>console.log(&#39;2.&#39;, a);</code></li>
</ul>
<p>在函式 test()，賦值 a = 7。</p>
<ul>
<li><code>console.log(&#39;3.&#39;, a);</code></li>
</ul>
<p>進入函式 inner()，函式內沒有宣告 a，所以會往上層 test() 宣告過 <code>var a = 7</code>，經過 a++ 得到 a = 8。</p>
<p>又因為外層沒有宣告過 b ，在呼叫函式 inner() 的同時，會宣告一個全域變數 b 並賦值為 200。</p>
<ul>
<li><code>console.log(&#39;4.&#39;, a);</code></li>
</ul>
<p>前面呼叫 inner() 時，重新賦值變數 a 為 30，因此這時外層的 a = 30。</p>
<ul>
<li><code>console.log(&#39;5.&#39;, a);</code></li>
</ul>
<p>看全域變數的 <code>var a = 1</code>，因此 a = 1。</p>
<ul>
<li><code>console.log(&#39;6.&#39;, a);</code></li>
</ul>
<p>經過賦值 a = 70。</p>
<ul>
<li><code>console.log(&#39;7.&#39;, a);</code></li>
</ul>
<p>前面提到在函式中，宣告了一個全域變數 b 並賦值為 200，因此 b = 200</p>
<hr>
<h2 id="所以為什麼需要-Hoisting？"><a href="#所以為什麼需要-Hoisting？" class="headerlink" title="所以為什麼需要 Hoisting？"></a>所以為什麼需要 Hoisting？</h2><p>至於我們為什麼會需要 Hoisting 呢？這個問題其實可以倒過來思考：「假如沒有 Hoisting 會怎麼樣？」</p>
<ul>
<li>一定要先宣告變數才能使用</li>
</ul>
<p>養成宣告的好習慣！這樣就不會汙染變數了，感覺還不賴？</p>
<ul>
<li>一定要先宣告函示才能使用</li>
</ul>
<p>這點其實會造成很大的不便，因為這樣在每個檔案都必須把 function 宣告放在最上面，才能保證底下的程式碼都可以呼叫這些 function。</p>
<ul>
<li>無法達成 function 互相呼叫</li>
</ul>
<p>什麼意思？舉個下面的例子：</p>
<pre><code class="javascript=">function loop(n)&#123;
  if (n &gt; 1) &#123;
    logEvenOrOdd(--n);
  &#125;
&#125;

function logEvenOrOdd(n) &#123;
  console.log(n, n % 2 ? &#39;Odd&#39; : &#39;Even&#39;);
  loop(n);
&#125;

loop(10);</code></pre>
<p>因為有 Hoisting，我們才能在 loop() 函式中呼叫 logEvenOrOdd()，然後也在 logEvenOrOdd() 函式中呼叫 loop()。</p>
<p>如果沒有 Hoisting，那以上的程式碼就不可能達成，因為這牽涉到順序問題，不可能同時做到 A 在 B 上面而 B 又在 A 上面。</p>
<p>為了解決上述問題，所以我們需要 Hoisting。</p>
<p>延伸閱讀：</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL2RtaXRyeXNvc2huaWtvdi5jb20vbm90ZXMvbm90ZS00LXR3by13b3Jkcy1hYm91dC1ob2lzdGluZy8=">Note 4. Two words about “hoisting”.<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGl1aGU2ODgvcC81ODkxMjczLmh0bWw=">JavaScript系列文章：变量提升和函数提升<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="Hoisting-的運作原理"><a href="#Hoisting-的運作原理" class="headerlink" title="Hoisting 的運作原理"></a>Hoisting 的運作原理</h2><p>在瞭解什麼是 Hoisting，還有我們為什麼需要 Hoisting 之後，接著就來探討：「Hoisting 究竟是如何運作的？」</p>
<p>這部分可參考 JavaScript 所遵循的標準 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvRUNNQVNjcmlwdA==">ECMAScript<i class="fa fa-external-link-alt"></i></span> 規格書，因為後期版本規格眾多，這裡以 <span class="exturl" data-url="aHR0cHM6Ly93d3ctYXJjaGl2ZS5tb3ppbGxhLm9yZy9qcy9sYW5ndWFnZS9FMjYyLTMucGRm">ES3 規格書<i class="fa fa-external-link-alt"></i></span>當作範例。</p>
<p>其實在 ES3 的規則中，並出現沒有 Hoisting 這個詞，與此現象有關的段落出現在第十章：Execution Contexts（執行環境，以下部分內容簡稱 EC）。</p>
<h3 id="什麼是-Execution-Context？"><a href="#什麼是-Execution-Context？" class="headerlink" title="什麼是 Execution Context？"></a>什麼是 Execution Context？</h3><p>在 JavaScript 中，可執行的 JS 程式碼可分成三種型別：</p>
<ol>
<li>Global Code：全域性的，不在任何函式裡面的程式碼</li>
<li>Function Code：在自定義函式中的程式碼</li>
<li>Eval Code：使用 eval() 函式動態執行的程式碼，但因為有兼容性與安全問題，JavaScript 並不推薦使用，這裡先不討論</li>
</ol>
<p>當 JavaScript 開始執行時，根據執行的程式碼型別，程式碼必須被執行在這三種環境之一，也就是 Execution Context（執行環境）。</p>
<p>以下要來探討的是全域執行環境和函式執行環境：</p>
<ul>
<li>全域執行環境（Global Execution Context）<ul>
<li>當執行 JavaScript 時，會先建立的第一層執行環境</li>
<li>位在最外圍的執行環境，且只會有一個</li>
<li>其他執行環境都可存取全域的資料</li>
</ul>
</li>
<li>函式執行環境（Function Execution Context）<ul>
<li>又稱為區域性執行環境（Local Execution Context）</li>
<li>每個 function 都有自己的執行環境</li>
<li>裡面儲存該 function 的相關資料，例如變數和函式定義</li>
<li>每當呼叫一個 function 時，都會建立一個新的 local EC，並且被放到執行堆疊（Call Stack）最上面</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/BeuXQfQ.png"><br>（參考來源：<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tLyVFOSVBRCU5NCVFOSVBQyVCQyVFOCU5NyU4RiVFNSU5QyVBOCVFNyVBOCU4QiVFNSVCQyU4RiVFNyVCNCVCMCVFNyVBRiU4MCVFOCVBMyVBMS8lRTYlQjclQkElRTglQUIlODctamF2YXNjcmlwdC0lRTUlOUYlQjclRTglQTElOEMlRTclOTIlQjAlRTUlQTIlODMtMjk3NmIzZWFmMjQ4JUVGJUJDJTg5">https://medium.com/%E9%AD%94%E9%AC%BC%E8%97%8F%E5%9C%A8%E7%A8%8B%E5%BC%8F%E7%B4%B0%E7%AF%80%E8%A3%A1/%E6%B7%BA%E8%AB%87-javascript-%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83-2976b3eaf248）<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="呼叫-amp-執行堆疊（Call-Stack）"><a href="#呼叫-amp-執行堆疊（Call-Stack）" class="headerlink" title="呼叫 &amp; 執行堆疊（Call Stack）"></a>呼叫 &amp; 執行堆疊（Call Stack）</h3><p>因為 JavaScript 是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJBJUJGJUU3JUE4JThC">單執行緒<i class="fa fa-external-link-alt"></i></span>的程式語言，用白話文解釋就是「JavaScript 一次只能做一件事情」，因此 JS 中等待執行的任務會被放入 Call Stack。</p>
<p>JavaScript 在調用一個執行環境時，其實會經過兩個階段：</p>
<ol>
<li>建立階段：呼叫堆疊（Call Stack）</li>
</ol>
<p>前面有提到，當開始執行 JavaScript 時，會先進入 Global EC。直到我們呼叫一個 function 時，才會建立一個新的執行環境繼續往 Global EC 的上層依序堆疊。</p>
<p>這些過程都發生在開始執行內部程式碼之前，也就是建立階段。對 JS 引擎來說，屬於執行前的編譯階段，而 hoisting 就是在此階段進行處理。</p>
<ol start="2">
<li>執行階段：執行堆疊（Execution Stack）</li>
</ol>
<p>接著 JavaScript 會優先處理執行堆疊中最上面的執行環境。一旦執行完該 function 後，該執行環境就會從最上面被移除（pop off），同時儲存在該 function 中的資訊也會被銷毀，然後再回到之前的執行環境，直到回到 Global EC 為止。</p>
<p>可參考下方的執行環境流程示意圖：</p>
<p><img src="https://i.imgur.com/gEIWBNG.png"><br>（參考來源：<span class="exturl" data-url="aHR0cHM6Ly9kZXYudG8vYWhtZWR0YWhpci93aGF0LWlzLXRoZS1leGVjdXRpb24tY29udGV4dC1leGVjdXRpb24tc3RhY2stc2NvcGUtY2hhaW4taW4tanMtMjZuYyVFRiVCQyU4OQ==">https://dev.to/ahmedtahir/what-is-the-execution-context-execution-stack-scope-chain-in-js-26nc）<i class="fa fa-external-link-alt"></i></span></p>
<p>最後整理關於執行環境的幾個重點：</p>
<ul>
<li>JavavaScript 是單執行緒的語言</li>
<li>且為同步執行：一次一個指令，而且有一定的順序</li>
<li>Global Context 只會有一個</li>
<li>Function Context 則沒有限制</li>
<li>就算是自己呼叫自己，只要有呼叫 function 就會建立執行環境</li>
</ul>
<hr>
<h2 id="Execution-Context-Object-執行環境物件"><a href="#Execution-Context-Object-執行環境物件" class="headerlink" title="Execution Context Object 執行環境物件"></a>Execution Context Object 執行環境物件</h2><p>前面也曾提到，執行環境負責存放該環境需要用到的各種資料，我們可以把執行環境想像成一個物件，又被稱作執行環境物件（Execution Context Object）。</p>
<p>而每個執行環境物件會有下列三個屬性：</p>
<ul>
<li>作用域鏈（Scope Chain）</li>
<li>變數物件（Variable Object）</li>
<li>‘this’ 變數（’this’ Variable）</li>
</ul>
<p>若以 Object 型態表示會如下：</p>
<pre><code class="javascript=">executionContextObject = &#123;
  scopeChain: &#123; 
    // 變數物件 + 所有父代執行環境物件的變數物件
  &#125;,
  variableObject: &#123; 
    // 函式的參數、內部的變數和函式
  &#125;,
  this: &#123;
    //
  &#125;
&#125;</code></pre>
<h2 id="Variable-Object-變數物件（VO）"><a href="#Variable-Object-變數物件（VO）" class="headerlink" title="Variable Object 變數物件（VO）"></a>Variable Object 變數物件（VO）</h2><p>以下是 ECMA <span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9hcmNoaXZlL2VjbWFzY3JpcHQvMTk5OS9UQzM5V0cvOTkwMjIwLWVzMl9mdW5jLnBkZg==">10.1.3 Variable Instantiation<i class="fa fa-external-link-alt"></i></span> 對於 Variable Object 的解釋：</p>
<blockquote>
<p>Every execution context has associated with it a variable object. Variables and functions declared in the source text are added as properties of the variable object. For function, anonymous, and implementation-supplied code, parameters are added as properties of the variable object.</p>
</blockquote>
<p>意思是說，每一個執行環境都會有一個相對應的變數物件（Variable Object），這個物件負責記錄執行環境中定義的變數和函式。</p>
<p>而執行 function 所創造的執行環境中，則會把參數（parameters）也加進去變數物件中，也就是活化成執行物件（Activation Object），這部分我們後面章節會再提到。</p>
<p>那麼，Variable Object 實際上是如何運作的呢？我們可從 JavaScript 執行流程談起。</p>
<p>從呼叫 function 到執行程式碼，這段過程中其實發生很多事情，流程大致如下：</p>
<ol>
<li>尋找呼叫 function </li>
<li>在執行 function 之前先建立執行環境</li>
<li>進入建立階段<ul>
<li>初始化 Scope Chain</li>
<li>建立 Variable Object</li>
<li>判斷決定 this 的值</li>
</ul>
</li>
<li>執行階段<ul>
<li>一行一行執行程式碼，賦值 </li>
</ul>
</li>
</ol>
<p>其中，在建立 Variable Object 時，則會進行下列三件事：</p>
<ul>
<li>建立 Argument Object：檢查執行環境的參數，初始化參數的名稱與值，若沒有值就初始為undefined</li>
<li>掃描 Function 宣告：為每一個 function 建立一個新屬性，其值指向該 function 在記憶體中的位置。如果已經有同名的就取代之</li>
<li>掃描變數宣告：為每一個變數宣告建立一個新屬性，並將該屬性的值初始為 undefined。如果已經有同名的就略過</li>
</ul>
<p>以下舉簡單的範例進行說明。</p>
<h3 id="範例：宣告變數-var-a-123"><a href="#範例：宣告變數-var-a-123" class="headerlink" title="範例：宣告變數 var a = 123"></a>範例：宣告變數 <code>var a = 123</code></h3><p>這句會分成兩部分：</p>
<ol>
<li><code>var a</code>：如果 VO 裡沒有屬性 a，就會新增 a 並初始化成 undefined</li>
<li><code>a = 10</code>：在 VO 裡找到叫做 a 的屬性，並設定為 10</li>
</ol>
<p>VO 模型：</p>
<pre><code class="javascript=">VO: &#123;
  a: 123,   // 把變數放進 VO，初始化成 123
&#125;</code></pre>
<blockquote>
<p>至於 VO 是如何找到屬性 a，則是會透過透 Scope chain 不斷往上層找，如果每一層都找不到就會出現錯誤訊息。這過程中涉及的部分較廣，因此我們先不進行討論。</p>
</blockquote>
<h3 id="範例：在-function-傳入一個參數-123"><a href="#範例：在-function-傳入一個參數-123" class="headerlink" title="範例：在 function 傳入一個參數 123"></a>範例：在 function 傳入一個參數 123</h3><p>程式碼如下：</p>
<pre><code class="javascript=">function test(a, b) &#123;
  console.log(a, b);
&#125;
test(123);
// 123, undefined</code></pre>
<ol>
<li>把參數放到 VO，並初始化成 123</li>
<li>若參數沒有值，就會被初始化成 undefined</li>
</ol>
<p>VO 模型如下：</p>
<pre><code class="javascript=">VO: &#123;
  a: 123,   // 把參數放進 VO，初始化成 123
  b: undefined,   // 把變數放進 VO，初始化成 undefined
&#125;</code></pre>
<h3 id="範例：-在-function-中宣告一個-function"><a href="#範例：-在-function-中宣告一個-function" class="headerlink" title="範例： 在 function 中宣告一個 function"></a>範例： 在 function 中宣告一個 function</h3><p>程式碼如下：</p>
<pre><code class="javascript=">function test(a, b)&#123;
  function b()&#123;
  &#125;
  var c = 30;
&#125;
test(123);</code></pre>
<ol>
<li>宣告 function 一樣會在 VO 裡面新增一個屬性</li>
<li>但如果 VO 裡面已經有同名的屬性，就會取代之。因此 function b 會取代傳入的參數 b</li>
</ol>
<p>VO 模型如下：</p>
<pre><code class="javascript=">VO: &#123;
    a: 123,   // 把參數放進 VO，初始化成 123
    b: function b, // 把 funcion b 放進 VO
    c: undefined // 把變數放進 VO，初始化成 undefined
&#125;</code></pre>
<p>對於宣告變數，則會在 VO 裡面新增一個屬性並且把值設為 undefined，如上述範例中的 <code>var c</code> 但如果 VO 已經有這個屬性時，值不會被改變。</p>
<h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>由上方幾個範例可知，當我們進入一個 EC，但還沒開始執行 function 以前，會先建立 Variable Object，並按照順序進行以下三件事：</p>
<ol>
<li>把參數放到 VO 裡面並設定傳進來的值，沒有值的設成 undefined</li>
<li>把 function 宣告放到 VO 裡，如果已經有同名的就取代之</li>
<li>把變數宣告放到 VO 裡，如果已經有同名的則忽略</li>
</ol>
<h3 id="最後再來個牛刀小試"><a href="#最後再來個牛刀小試" class="headerlink" title="最後再來個牛刀小試"></a>最後再來個牛刀小試</h3><pre><code class="javascript=">function test(v)&#123;
  console.log(v);      // 10
  var v = 3;
  console.log(v);      // 3
&#125;
test(10);</code></pre>
<p>思考方式：</p>
<ol>
<li>在執行 function 前，因為 test() 有傳參數進去，所以把 v 放到 VO 並設定為 10</li>
<li>接著開始執行 functon 內容程式碼，第二行印出 10</li>
<li>執行到第三行，把變數 v 的值換成 3</li>
<li>執行到第四行，印出 3</li>
</ol>
<hr>
<h2 id="TDZ：Temporal-Dend-Zone-暫時死區"><a href="#TDZ：Temporal-Dend-Zone-暫時死區" class="headerlink" title="TDZ：Temporal Dend Zone 暫時死區"></a>TDZ：Temporal Dend Zone 暫時死區</h2><p>接著再回到 let 和 const，其實以 let 和 const 宣告變數同樣會有 Hoisting 的情形，只是執行方式不太相同。</p>
<p>先以下列程式碼為例，和文章最一開始的 <code>var a</code> 不同，結果出現 <code>a is not defined</code> 的錯誤：</p>
<pre><code class="javascript=">console.log(a); // ReferenceError: a is not defined
let a;</code></pre>
<p>這樣是不是代表 let 和 const 沒有變數提升呢？否則宣告經過提升後應該不會出現 Error 才對？</p>
<p>事實上，let 與 const 確實有 Hoisting，與 var 的差別在於提升之後，var 宣告的變數會被初始化為 undefined；而 let 與 const 的宣告則不會被初始化為 undefined，如果在「賦值之前」就存取它，會拋出錯誤訊息。</p>
<p>簡單來說，如果是在「提升之後」以及「賦值之前」這段期間存取變數就會拋出錯誤，而這段期間就稱作 TDZ（Temporal Dend Zone），中文為「暫行性死去」或「暫時死區」，是為了解釋 let 與 const 的 Hoisting 行為所提出的一個名詞。</p>
<p>再來看以下範例：</p>
<pre><code class="javascript=">var a = 10;
function test() &#123;
  console.log(a);
  let a = 30;
&#125;
test();
// ReferenceError: Cannot access &#39;a&#39; before initialization

=== 經過 Hoisting ===

var a = 10;
function test() &#123;
  let a;           // 宣告變數 a 經過提升之後
  console.log(a);  // 在賦值之前不能存取 a
  a = 30;
&#125;
test();</code></pre>
<p>同理可證，假如 let 沒有 Hoisting，結果應該會印出 10 才會，因為 log 那一行會存取全域變數的 <code>var a = 10</code>，但是卻印出 <code>錯誤：無法在初始化之前存取變數 a</code>。這是因為 let 的確有提升，只是沒有初始為 undefined。</p>
<p>總結上述例子：</p>
<ul>
<li>let 與 const 宣告確實也有 Hoisting 行為，但沒有像 var 宣告初始化為 undefined</li>
<li>如果在提升之後，賦值之前這段期間，存取該值會發生錯誤</li>
<li>這段期間稱為 Temporal Dend Zone（暫時死區）</li>
</ul>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>從理解什麼是 Hoisting（提升），瞭解我們為什麼需要提升，再延伸到運作原理。過程中建立的 Execution Contexts（執行環境）、與之對應的 Variable Object（變數物件）等等，其實涉及到有關 JavaScript 的知識範圍非常廣。</p>
<p>除了課堂影片提到的內容，自己也上網查了許多有關執行環境、執行堆疊的資料，雖然花費不少時間，卻也藉由瞭解 JavaScript 的編譯與執行過程，從建立到執行階段，加深對整個架構的理解。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRlY2hicmlkZ2UuY2MvMjAxOC8xMS8xMC9qYXZhc2NyaXB0LWhvaXN0aW5nLw==">我知道你懂 hoisting，可是你了解到多深？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9uaWNvbGFrYWNoYS5jb2RlcmJyaWRnZS5pby8yMDIwLzA5LzI5L2phdmFzY3JpcHQtc2NvcGUtaG9pc3Rpbmcv">JavaScript: Scope &amp; Hoisting<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hbmR5eW91LmdpdGh1Yi5pby8yMDE1LzA0LzE4L3doYXQtaXMtdGhlLWV4ZWN1dGlvbi1jb250ZXh0LWluLWphdmFzY3JpcHQv">理解 Javascript 執行環境<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlcnR3LmNvbS8lRTUlODklOEQlRTclQUIlQUYlRTklOTYlOEIlRTclOTklQkMvMjY3MzQyLw==">javascript執行環境及作用域詳解<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tLyVFOSVBRCU5NCVFOSVBQyVCQyVFOCU5NyU4RiVFNSU5QyVBOCVFNyVBOCU4QiVFNSVCQyU4RiVFNyVCNCVCMCVFNyVBRiU4MCVFOCVBMyVBMS8lRTYlQjclQkElRTglQUIlODctamF2YXNjcmlwdC0lRTUlOUYlQjclRTglQTElOEMlRTclOTIlQjAlRTUlQTIlODMtMjk3NmIzZWFmMjQ4">秒懂！JavaSript 執行環境與堆疊<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zaGF3bmxpbjAyMDEuZ2l0aHViLmlvL0phdmFTY3JpcHQvSmF2YVNjcmlwdC1WYXJpYWJsZS1PYmplY3QtYW5kLUFjdGl2YXRpb24tT2JqZWN0Lw==">JavaScript 深入淺出 Variable Object &amp; Activation Object<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Hoisting</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 16] JavaScript 進階 - 物件導向 &amp; Prototype</title>
    <url>/javascript-oop-prototype/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvanMyMDEtamF2YXNjcmlwdA==">[JS201] 進階 JavaScript：那些你一直搞不懂的地方<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<pre><code>學習目標：

 P1 你知道 Prototype 在 JavaScript 裡是什麼
 P1 你知道大部分情況下 this 的值是什麼
 P2 你知道物件導向的基本概念（類別、實體、繼承、封裝）</code></pre>
<a id="more"></a>
<hr>
<h2 id="什麼是物件導向？"><a href="#什麼是物件導向？" class="headerlink" title="什麼是物件導向？"></a>什麼是物件導向？</h2><p>其實我們在上一篇 <span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWpzMjAxLWNsb3N1cmU=">Closure &amp; Scope Chain 筆記<i class="fa fa-external-link-alt"></i></span>中，就有稍微提到物件導向的相關觀念：</p>
<pre><code class="javascript=">function createWallet(initMoney) &#123;
  var money = initMoney;
  return &#123;
    add: function(num) &#123;
      money += num;
    &#125;,
    deduct: function(num) &#123;
      if (num &gt;= 10) &#123;
        money -= 10;
      &#125; else &#123;
        money -= num
      &#125;
    &#125;,
    getMoney() &#123;
      return money;
    &#125;
  &#125;
&#125;
var myWallet = createWallet(99);
myWallet.add(1);
myWallet.deduct(100);
console.log(myWallet.getMoney()); // 90</code></pre>
<p>在物件導向的世界，我們以呼叫 function 的方式進行操作，會比較像是在使用物件的形式。例如 myWallet.add() 這句的意思，就像是對 myWallet 這個物件做一些操作。</p>
<p>像這樣透過塑造物件，就可以不需一直 Call function，也會使程式更模組化一些，並且能夠隱藏內部資訊。</p>
<h3 id="建立物件實體（Object-instance）"><a href="#建立物件實體（Object-instance）" class="headerlink" title="建立物件實體（Object instance）"></a>建立物件實體（Object instance）</h3><p>根據 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9MZWFybi9KYXZhU2NyaXB0L09iamVjdHMvT2JqZWN0LW9yaWVudGVkX0pT">MDN<i class="fa fa-external-link-alt"></i></span> 說明，其實物件導向（Object-oriented）的基本概念就是：「採用物件（Objects）來模塑真實的實物世界」。</p>
<p>也就是說，我們可以在程式中透過 Objects（物件）來塑造其模型，而物件能夠存放其相關資料與程式碼，並且能使用方式（Method）來進行存取。</p>
<p>舉個簡單的例子，以一隻狗來說，可能會有許多基本資訊，像是毛色、身高、名字、性別等，透過這些抽象概念或特質，我們能夠建立一個「Dog」範本，作為代表狗的物件類別（class）。</p>
<p>接著我們可以從這個類別建立物件實體（Object instance），也就是該透過執行類別的「建構子函式（Constructor Function）」建立物件，而這段過程就稱為實體化（Instantiation）。</p>
<pre><code>// 透過類別中的建構子將物件實體化
class -&gt; Constructor -&gt; Object instance</code></pre>
<h3 id="Constructor-Function-amp-new"><a href="#Constructor-Function-amp-new" class="headerlink" title="Constructor Function &amp; new"></a>Constructor Function &amp; new</h3><p>前面我們提到，JavaScript 是使用類別（class）中的建構子函式（Constructor Function）來定義物件與功能。</p>
<p>但實際上，JavaScript 程式本身並沒有 class 可以使用，是到了 ES6 以後才出現。簡單來說，class 其實是 ES6 提供的語法糖，底層機制仍然是 JavaScript 的原型（prototype）。</p>
<p>接著同樣以建立 Dog 物件類別為例：</p>
<ul>
<li>class 後面要接名稱，表示要「建立 Dog 這個 class」，第一個字必須為大寫</li>
<li>接著透過 <code>new</code> 指令來實體化，建立出物件實體（Object instance）</li>
<li>class 中的 <code>constructor</code> 用來定義物件，也就是在建立時會呼叫 <code>constructor</code> 來執行內部的程式碼，目的是初始化 instance</li>
<li>透過 instance 傳入參數，再由 <code>constructor</code> 接收，可設定 Dog 的屬性 <code>name</code></li>
</ul>
<pre><code class="javascript=">class Dog &#123;
  constructor(name) &#123;
    this.name = name;
    console.log(this);
    console.log(this.name);
  &#125;
&#125;

var a = new Dog(&#39;dog A&#39;);
var b = new Dog(&#39;dog B&#39;);

// Dog &#123;name: &quot;dog A&quot;&#125;
// dog A
// Dog &#123;name: &quot;dog B&quot;&#125;
// dog B</code></pre>
<ul>
<li>constructor 也可用透過呼叫 function 來定義物件的方法<ul>
<li>在 constructor 中，有設定就會有取得。例如：setName 會被稱為 setter，getName 則是 getter</li>
<li>透過這種形式，就不需直接操作 class 內部的值</li>
</ul>
</li>
<li>this 在 class 的用途：誰呼叫它就指向呼叫它的<ul>
<li>例如 <code>a.sayHello();</code>：代表 a 透過 sayHello 呼叫 this，所以這個 this 是 a</li>
</ul>
</li>
</ul>
<pre><code class="javascript=">class Dog &#123;
  constructor(name) &#123;
    // setter
    setName(name) &#123;
      this.name = name;
    &#125;
    // getter
    getName() &#123;
      return this.name;
    &#125;
    sayHello() &#123;
      console.log(&#39;hello&#39;);
  &#125;
&#125;

var a = new Dog(&#39;dog A&#39;);
console.log(a.name)    // dog A
a.sayHello();      // hello

var b = new Dog(&#39;dog B&#39;);
console.log(b.name)    // dog B
b.sayHello();      // hello</code></pre>
<p>此外，藉由 new 指令建立出 a 和 b 兩個物件，這兩個物件是完全獨立的物件，且都事先具備 Dog 這個 class 的所有屬性。</p>
<p>這其實和物件導向的三大特性有關，這部分我們後面會再提到：</p>
<ul>
<li>封裝（Encapsulation）</li>
<li>繼承（Inheritance）</li>
<li>多型（Polymorphism）</li>
</ul>
<h2 id="Prototype-Chain-原型鍊"><a href="#Prototype-Chain-原型鍊" class="headerlink" title="Prototype Chain 原型鍊"></a>Prototype Chain 原型鍊</h2><p>在建立物件實體（Object instance）之後，接著需透過原型（Prototype）機制來相互繼承功能。</p>
<p>前面有提到，class 其實是 ES6 提供的語法糖，底層機制仍然是 JavaScript 的原型（prototype）。因此，即使是在不使用 class 的情況下，我們一樣可以透過 function 和 prototype 來做到 class（類別）的功能。</p>
<h3 id="ES5-寫法"><a href="#ES5-寫法" class="headerlink" title="ES5 寫法"></a>ES5 寫法</h3><p>若將前面的範例改成 ES5 寫法，也就是替換掉 constructor 和 new，如下方程式碼：</p>
<pre><code class="javascript=">function Dog(name) &#123;
  var myName = name;
  return &#123;
    getName: function () &#123;
      return myName
    &#125;,
    sayHello: function () &#123;
      console.log(&#39;say hello!&#39;)
    &#125;
  &#125;
&#125;

var a = Dog(&#39;dog A&#39;);   // say hello!
a.sayHello();
var b = Dog(&#39;dog B&#39;);   // say hello!
b.sayHello();
console.log(a.sayHello === b.sayHello);   // false</code></pre>
<p>會發現 a.sayHello 和 b.sayHello 兩個同樣的 function 卻不是一樣的東西，代表程式在背後其實儲存了兩次。原因在於 class 中是不同的 instance，造成 this 指向不同。</p>
<p>但這其實會產生一個問題，如果今天有一萬隻狗，就會儲存一萬次 function，明明都是在處理同樣的事情，應該改成使用同一個 function 去跑不同的 instance 即可。</p>
<h3 id="以-prototype-連結-function"><a href="#以-prototype-連結-function" class="headerlink" title="以 .prototype 連結 function"></a>以 <code>.prototype</code> 連結 function</h3><p>在 JavaScript 機制中，有個 <code>.prototype</code> 語法能夠連結 function，如下方程式碼：</p>
<ul>
<li>使用 <code>Dog.prototype.sayHello</code> 將建構 function 新增一個 sayHello 的屬性</li>
<li>new 出來的物件皆可存取 sayHello 這個屬性</li>
</ul>
<pre><code class="javascript=">function Dog(name) &#123;    // 等於 constructor
  this.name = name;
&#125;

Dog.prototype.getName = function () &#123;
  return this.name;
&#125;

Dog.prototype.sayHello = function () &#123;
  console.log(&#39;say hello!&#39;);
&#125;

var a = new Dog(&#39;dog A&#39;);
var b = new Dog(&#39;dog B&#39;);
console.log(a.sayHello === b.sayHello);  // true</code></pre>
<p>兩個 function 就會是相同的，因為 a 和 b 都是 prototype 上面的 function。如此一來，我們就可以使用同一個 function 去跑不同的 instance，透過這個方式實作 JavaScript 的物件導向。</p>
<h3 id="proto-amp-prototype"><a href="#proto-amp-prototype" class="headerlink" title="__proto__ &amp; prototype"></a><code>__proto__</code> &amp; <code>prototype</code></h3><p>所以 prototype 是什麼？在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10ZXJtcy1hbmQtZGVmaW5pdGlvbnMtcHJvdG90eXBl">ECMA5.1<i class="fa fa-external-link-alt"></i></span> 標準中，定義原型（prototype）是為其他對象提供共享屬性的對象：</p>
<blockquote>
<p>object that provides shared properties for other objects</p>
</blockquote>
<p>也就是說，原型（prototype）的本質，就是能夠分享自己的屬性給其他物件使用，而所有的物件都有原型（prototype）屬性。</p>
<p>接著舉一個簡單的物件為例：</p>
<pre><code class="javascript=">const obj = &#123; name: &quot;Dog&quot; &#125;;
console.log(obj);</code></pre>
<p>可以看到 obj 物件的原型物件，具有的 <code>__proto__</code>、<code>constructor</code> 等特性，這些都是由原型物件分享給 obj 物件使用的特性：</p>
<p><img src="https://i.imgur.com/jwWgnE9.png"></p>
<p>接著來說明 <code>prototype</code> 和 <code>__proto__</code> 之間的差異：</p>
<h4 id="prototype（顯性原型）"><a href="#prototype（顯性原型）" class="headerlink" title="prototype（顯性原型）"></a><code>prototype</code>（顯性原型）</h4><ul>
<li>用來實現基於原型的繼承與屬性的共享</li>
<li>例如：用來指定屬性或 function<h4 id="proto-（隱性原型）"><a href="#proto-（隱性原型）" class="headerlink" title="__proto__（隱性原型）"></a><code>__proto__</code>（隱性原型）</h4></li>
<li>構成原型鏈，同樣用於實現基於原型的繼承</li>
<li>例如：繼承資料</li>
<li>由 new 指令建立的物件，<code>__proto__</code> 屬性會指向該原型物件的 <code>prototype</code></li>
<li>也就是說，當我們想找 obj 物件中的 X 屬性時，如果在 obj 中找不到，就會繼續沿著 <code>__proto__</code> 往下一層查找</li>
</ul>
<p>參考資料：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM0MTgzNzQ2">js中__proto__和prototype的區別和關係？<i class="fa fa-external-link-alt"></i></span></p>
<p>接著繼續沿用剛才的 Dog 範例：</p>
<pre><code class="javascript=">function Dog(name) &#123;    // 等於 constructor
  this.name = name;
&#125;

Dog.prototype.getName = function () &#123;
  return this.name;
&#125;

Dog.prototype.sayHello = function () &#123;
  console.log(&#39;say hello!&#39;);
&#125;

var a = new Dog(&#39;dog A&#39;);
var b = new Dog(&#39;dog B&#39;);
console.log(a.__proto__);
console.log(b.__proto__);
// Dog &#123; getName: [Function], sayHello: [Function] &#125;
// Dog &#123; getName: [Function], sayHello: [Function] &#125;</code></pre>
<p>會發現 <code>a.__proto__</code> 和 <code>b.__proto__</code> 其實就代表 Dog.prototype，會得到相同結果：</p>
<pre><code class="javascript=">console.log(a.__proto__ === Dog.prototype)
// true</code></pre>
<p>也映證我們前面所說，class 底層其實還是 prototype（原型）這件事，只是寫法不同。</p>
<p>而當我們執行 <code>a.sayHello()</code> 的時候，程式會沿著原型鏈尋找 sayHello 屬性，參考過程如下：</p>
<pre><code class="javascript=">a.sayHello()

1. a　有沒有 sayHello
2. a.__proto__　有沒有 sayHello
3. a.__proto__.__proto__　有沒有 sayHello
4. a.__proto__.__proto__.__proto__　有沒有 sayHello
5. 找到最後剩下 null，也就是最頂層

a.__proto__ = Dog.prototype
a.__proto__.__proto__ = Dog.prototype.__proto__ = Object.prototype
a.__proto__.__proto__.__proto__ = null</code></pre>
<p>像這樣透過 <code>__proto__</code> 不斷串起來的鏈，就稱作原型鏈（Prototype Chain），其實概念類似於之前提過的 Scope Chain。透過這條原型鏈，就可以引用或繼承自己物件沒有的屬性。</p>
<pre><code class="javascript=">// Prototype Chain
a --&gt; Dog.prototype --&gt; Object.prototype --&gt; null
// 等同於
a -&gt; a.__proto__ --&gt; a.__proto__.__proto__ --&gt; a.__proto__.__proto__.__proto__</code></pre>
<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h3><ul>
<li>用來判斷某個物件是否含有指定的自身屬性</li>
<li>以 Dog 例子來說，可用 <code>a.hasOwnProperty(&#39;sayHello&#39;)</code> 來判斷 sayHello 是存在於 instance 還是該原型鏈中</li>
</ul>
<pre><code class="javascript=">console.log(a.__proto__.hasOwnProperty(&#39;sayHello&#39;));
// true
console.log(a.hasOwnProperty(&#39;sayHello&#39;));
// false</code></pre>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul>
<li>用來判斷 A 物件是否為 B 的實例，比較的是原型（prototype）：</li>
</ul>
<pre><code class="javascript=">console.log(a instanceof Dog);  // true</code></pre>
<h4 id="比較：instanceof-vs-typeof"><a href="#比較：instanceof-vs-typeof" class="headerlink" title="比較：instanceof vs typeof"></a>比較：instanceof vs typeof</h4><ul>
<li>typeof：用來判斷參數是什麼型別，回傳值是 data type</li>
</ul>
<pre><code class="javascript=">console.log(typeof 123)  // number</code></pre>
<h2 id="new-扮演的角色"><a href="#new-扮演的角色" class="headerlink" title="new 扮演的角色"></a>new 扮演的角色</h2><p>在理解 new 在背後做了什麼是之前，先來看這個例子：</p>
<pre><code class="javascript=">function test() &#123;
  console.log(this)
&#125;
test();</code></pre>
<p>會發現 this 其實是非常大的值，裡面包含許多東西：</p>
<p><img src="https://i.imgur.com/kqTUu5D.png"></p>
<h3 id="call-：另一種呼叫-function-的方式"><a href="#call-：另一種呼叫-function-的方式" class="headerlink" title=".call()：另一種呼叫 function 的方式"></a><code>.call()</code>：另一種呼叫 function 的方式</h3><p>此外，function 還有一種呼叫方式叫做 <code>.call()</code>，如果我們 call 來呼叫 test，並在括號內帶入值，將會改變 function 結果：</p>
<pre><code class="javascript=">function test() &#123;
  console.log(this)
&#125;

test.call(&#39;123&#39;);  // [String: &#39;123&#39;]
test.call(&#123;&#125;);     // &#123;&#125;</code></pre>
<p>也就是說，若使用 <code>.call()</code> 呼叫 function，會將傳入的東西設定為 this 的值。</p>
<p>接著我們可以透過「<code>.call()</code> 第一個參數代表 this 指向」這個概念，試著自己建立一個 new 的模型：</p>
<pre><code class="javascript=">function Dog(name) &#123;
  this.name = name;
&#125;

Dog.prototype.getName = function () &#123;
  return this.name;
&#125;

Dog.prototype.sayHello = function () &#123;
  console.log(&#39;hello&#39;, this.name);
&#125;

// 使用 new 方法
var a = new Dog(&#39;dog a&#39;);

// 透過 function 實作 new 方法
var b = newDog(&#39;dog b&#39;)

function newDog(name) &#123;
  var obj = &#123;&#125;;                 // 先建立一個空物件 obj
  Dog.call(obj, name);          // 呼叫 constructor，this 會指向這個物件
  obj.__proto__ = Dog.prototype;  // 建立物件的原型鏈
  return obj;                   // 回傳完成的物件 obj
&#125;

a.sayHello();   // hello dog a
b.sayHello();   // hello dog b</code></pre>
<p>透過 function 實作 new 方法，上述的程式碼步驟如下：</p>
<ol>
<li>先建立一個空物件 obj</li>
<li>呼叫 constructor，然後把 Dog 利用 <code>.call()</code> 帶入空物件，並設定參數：<code>Dog.call(obj, name)</code>，第一個參數代表 this 指向 obj，第二個參數代表要帶入的值</li>
<li>接著設定方法：建立物件的原型鏈，針對 obj 的 <code>.__proto__</code> 等同於 Dog 的 <code>.prototype</code> 即可完成關聯</li>
<li>回傳完成的物件 obj</li>
</ol>
<hr>
<h2 id="物件導向的繼承：Inheritance"><a href="#物件導向的繼承：Inheritance" class="headerlink" title="物件導向的繼承：Inheritance"></a>物件導向的繼承：Inheritance</h2><p>當其他類別需要用到共同屬性時，不需再重新建立 class 的各種屬性，可以利用繼承的方法，來直接存取父層的屬性。</p>
<p>例如狗本身有名字有動作，有自己的屬性與方法。而黑狗也屬於一種狗，黑狗也有同樣的屬性與方法，只是會有些微差異，這種情況我們可以透過繼承，也就是讓黑狗 class 直接使用狗 class，就不需再另外建立。</p>
<p>如下方的範例：</p>
<pre><code class="javascript=">class Dog &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;
  sayHello() &#123;
    console.log(this.name);
  &#125;
&#125;
// 繼承 Dog class
class BlackDog extends Dog &#123;
  test() &#123;
    console.log(&#39;test&#39;, this.name);
  &#125;
&#125;

const black = new BlackDog(&#39;hello&#39;);
black.sayHello();   // hello</code></pre>
<h3 id="修改子層-class-的-constructor"><a href="#修改子層-class-的-constructor" class="headerlink" title="修改子層 class 的 constructor"></a>修改子層 class 的 constructor</h3><p>如果想要在子層的 class 更改 constructor 屬性時，必須先呼叫 <code>super()</code>，並把父層 class constructor 需要的參數傳進去。否則就只會初始化子層的 constructor，不會有繼承的作用。</p>
<p>透過 <code>super()</code> 來呼叫父層 class 的 constructor，才能連同父層的 constructor 一併初始化，並接收初始化的值：</p>
<pre><code class="javascript=">class Dog &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;
  getName() &#123;
    return this.name;
  &#125;
  sayHello() &#123;
    console.log(&#39;Hello, &#39; + this.name);
  &#125;
&#125;

class BlackDog extends Dog &#123;    // 繼承
  constructor(name) &#123;
    super(name);      // 繼承後在 constructor 一定要使用 super 接收資料
    this.sayHello();  // 當 BlackDog 被建立時，就打招呼
  &#125;
  test() &#123;
    console.log(&#39;test!&#39;, this.name);
  &#125;
&#125;

const a = new Dog(&#39;dog a&#39;);
a.sayHello();
// Hello, dog a.

const black = new BlackDog(&#39;I am black dog&#39;); 
// Hello, I am black dog</code></pre>
<p>透過子層繼承父層類別可延伸多種型態，也就是同樣的方法名稱會有多種行為，使用上也增加彈性，這其實就是物件導向的特性之一：多型（Polymorphism）。</p>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>在學習 JavsScript 之前，一直以為物件導向和 this 是能夠畫上等號的（三個的那種）。直到實際學到物件導向以後，才瞭解到物件導向中有許多觀念，其實和在之前學到的 Hoisting、Closure 有很大的關聯。此外，物件導向其實應用在許多現代的程式語言，以物件導向的方式進行開發。</p>
<p>物件導向程式的寫法，基本上可分為三部分：</p>
<ol>
<li>定義物件類別（class）。例如：<code>class Dog</code></li>
<li>定義物件類別中的屬性與方法。例如：可使用 <code>dog.name</code> 存取屬性，使用 <code>dog.sayHello()</code> 存取方法</li>
<li>定義物件之間的行為，也就是主程式</li>
</ol>
<p>之所以需要物件導向，最重要的目的就是把資料（屬性）與函式（方法）結合在一起，定義出物件模型，這麼做有幾個優點：</p>
<ul>
<li>便於重複使用程式碼</li>
<li>能夠隱藏程式內部資訊</li>
<li>透過模組化來簡化主程式邏輯</li>
</ul>
<p>而這些概念，其實也就是先前談到有關物件導向的三大特性，並且三者具有次序性，沒有封裝就不可能有繼承、沒有繼承就不可能有多型：</p>
<ul>
<li>封裝（Encapsulation）：<ul>
<li>藉由把程式包成類別，能夠隱藏物件內容</li>
<li>避免程式間互相干擾，也利於後續維護</li>
</ul>
</li>
<li>繼承（Inheritance）：<ul>
<li>子層能夠繼承使用父層的屬性和方法，並且加以微調</li>
<li>能夠重複使用程式碼</li>
</ul>
</li>
<li>多型（Polymorphism）：<ul>
<li>父層可透過子層衍伸成多種型態，接著子層可藉由覆寫父層的方法來達到多型</li>
<li>可增加程式架構的彈性與維護性</li>
</ul>
</li>
</ul>
<p>藉由瞭解什麼是物件導向，為什麼需要物件導向以後，對整體架構似乎又更加清楚一些。過程中也查了許多資料，在碰到新的名詞時總會感到慌張，像是 constructor（建構子）、prototype（原型）、instance（實例）等等，其實只要能夠先瞭解定義是什麼，就不難繼續理解整體架構。</p>
<p>最後，在找相關資料的時候，有在這篇<span class="exturl" data-url="aHR0cHM6Ly9pZ291aXN0LmdpdGh1Yi5pby9wb3N0LzIwMjAvMDcvb28tNS1wb2x5bW9ycGhpc20v">網誌<i class="fa fa-external-link-alt"></i></span>中，看到使用泡麵的例子來比喻物件導向，因為還蠻喜歡的也記錄在這裡：</p>
<ol>
<li>由泡麵工廠製作麵和醬包，並包裝在一起，我們可以直接買來享用</li>
<li>我們可以在泡麵中自己加料，或是不用泡的改用炒的</li>
<li>同樣都是泡麵，卻能夠實作出不同的口味</li>
</ol>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmh1bGkudHcvMjAxNy8wOC8yNy90aGUtamF2YXNjcmlwdHMtcHJvdG90eXBlLWNoYWluLw==">該來理解 JavaScript 的原型鍊了<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9odWdoLXByb2dyYW0tbGVhcm5pbmctZGlhcnktanMubWVkaXVtLmNvbS8lRTUlODklOEQlRTclQUIlQUYlRTQlQjglQUQlRTklOUElOEUtanMlRTQlQkIlQTQlRTQlQkElQkElRTYlOTAlOUUlRTQlQjglOEQlRTYlODclODIlRTclOUElODQlRTUlOUMlQjAlRTYlOTYlQjktJUU3JTg5JUE5JUU0JUJCJUI2JUU1JUIwJThFJUU1JTkwJTkxLWNkZWEwZTMyNjZlZQ==">[week 16] JavaScript 進階 - 淺談物件導向 &amp; this<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9uaWNvbGFrYWNoYS5jb2RlcmJyaWRnZS5pby8yMDIwLzEwLzAxL29vcC1wcm90b3R5cGUtdGhpcy8=">JavaScript: Object-oriented JavaScript, Prototype Chain &amp; This<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 16] JavaScript 進階 - 作業練習</title>
    <url>/js201-hw/</url>
    <content><![CDATA[<ul>
<li>hw1：Event Loop</li>
<li>hw2：Event Loop + Scope</li>
<li>hw3：Hoisting</li>
<li>hw4：What is this?<a id="more"></a>

</li>
</ul>
<h2 id="hw1：Event-Loop"><a href="#hw1：Event-Loop" class="headerlink" title="hw1：Event Loop"></a>hw1：Event Loop</h2><p>在 JavaScript 裡面，一個很重要的概念就是 Event Loop，是 JavaScript 底層在執行程式碼時的運作方式。請你說明以下程式碼會輸出什麼，以及盡可能詳細地解釋原因。</p>
<pre><code>console.log(1)
setTimeout(() =&gt; &#123;
  console.log(2)
&#125;, 0)
console.log(3)
setTimeout(() =&gt; &#123;
  console.log(4)
&#125;, 0)
console.log(5)</code></pre>
<h3 id="輸出結果"><a href="#輸出結果" class="headerlink" title="輸出結果"></a>輸出結果</h3><pre><code class="js">1
3
5
2
4</code></pre>
<h3 id="執行流程"><a href="#執行流程" class="headerlink" title="執行流程"></a>執行流程</h3><ol>
<li>將 <code>console.log(1)</code> 放入 Call Stack 並直接執行，印出 1，執行結束後移除</li>
<li>將 <code>setTimeout(() =&gt; &#123; console.log(2) &#125;, 0)</code> 放入 Call Stack，透過 Web API，在瀏覽器設定計時器為 0，直到倒數結束，將 <code>() =&gt; &#123; console.log(2) &#125;</code> 放到 Callback Queue 等待執行，setTimeout 執行結束後從 Call Stack 移除</li>
<li>將 <code>console.log(3)</code> 放入 Call Stack 並直接執行，印出 3，執行結束後移除</li>
<li>將 <code>setTimeout(() =&gt; &#123; console.log(4) &#125;, 0)</code> 放入 Call Stack，透過 Web API，在瀏覽器設定計時器為 0，直到倒數結束，將 <code>() =&gt; &#123; console.log(4) &#125;</code> 放到 Callback Queue 等待執行，setTimeout 執行結束後從 Call Stack 移除</li>
<li>將 <code>console.log(5)</code> 放入 Call Stack 並直接執行，印出 5，執行結束後移除</li>
<li>當 Event Loop 偵測到 call stack 為空時，依序將 Callback Queue 的任務丟到 Call Stack 執行</li>
<li>執行 <code>() =&gt; &#123; console.log(2) &#125;</code>，再執行 <code>console.log(2)</code>，印出 2，執行結束後移除</li>
<li>接著執行 <code>() =&gt; &#123; console.log(4) &#125;</code>，再執行 <code>console.log(4)</code>，印出 4，執行結束後移除</li>
</ol>
<hr>
<h2 id="hw2：Event-Loop-Scope"><a href="#hw2：Event-Loop-Scope" class="headerlink" title="hw2：Event Loop + Scope"></a>hw2：Event Loop + Scope</h2><p>請說明以下程式碼會輸出什麼，以及盡可能詳細地解釋原因。</p>
<pre><code class="js">for(var i=0; i&lt;5; i++) &#123;
  console.log(&#39;i: &#39; + i)
  setTimeout(() =&gt; &#123;
    console.log(i)
  &#125;, i * 1000)
&#125;</code></pre>
<h3 id="輸出結果-1"><a href="#輸出結果-1" class="headerlink" title="輸出結果"></a>輸出結果</h3><pre><code class="js">i: 0
i: 1
i: 2
i: 3
i: 4
5
5
5
5
5</code></pre>
<h3 id="執行流程-1"><a href="#執行流程-1" class="headerlink" title="執行流程"></a>執行流程</h3><ol>
<li>將 for 迴圈放入 Call Stack 並開始執行，宣告變數 i = 0，判斷 i 是否小於 5，是，進入第一圈迴圈</li>
<li>將 <code>console.log(&#39;i: &#39; + 0)</code> 放入 Call Stack 並直接執行，印出 i: 0</li>
<li>將 <code>setTimeout(() =&gt; &#123; console.log(0) &#125;, 0 * 1000)</code> 放入 Call Stack，透過 Web API，在瀏覽器設定計時器為 0 ms，直到倒數結束，將 <code>() =&gt; &#123; console.log(0) &#125;</code> 放到 Callback Queue 等待執行，setTimeout 執行結束後從 Call Stack 移除</li>
<li>第一圈迴圈結束，將 i + 1</li>
<li>i = 1，判斷 i 是否小於 5，是，進入第二圈迴圈</li>
<li>將 <code>console.log(&#39;i: &#39; + 1)</code> 放入 Call Stack 並直接執行，印出 i: 1</li>
<li>將 <code>setTimeout(() =&gt; &#123; console.log(i) &#125;, 1 * 1000)</code> 放入 Call Stack，透過 Web API，在瀏覽器設定計時器為 1000 ms ，直到倒數結束，將 <code>() =&gt; &#123; console.log(i) &#125;</code> 放到 Callback Queue 等待執行，setTimeout 執行結束後從 Call Stack 移除</li>
<li>第二圈迴圈結束，將 i + 1</li>
<li>i = 2，判斷 i 是否小於 5，是，進入第二圈迴圈</li>
<li>將 <code>console.log(&#39;i: &#39; + 2)</code> 放入 Call Stack 並直接執行，印出 i: 2</li>
<li>將 <code>setTimeout(() =&gt; &#123; console.log(i) &#125;, 2 * 1000)</code> 放入 Call Stack，透過 Web API，在瀏覽器設定計時器為 2000 ms ，直到倒數結束，將 <code>() =&gt; &#123; console.log(i) &#125;</code> 放到 Callback Queue 等待執行，setTimeout 執行結束後從 Call Stack 移除</li>
<li>第二圈迴圈結束，將 i + 1</li>
<li>i = 3，判斷 i 是否小於 5，是，進入第三圈迴圈</li>
<li>將 <code>console.log(&#39;i: &#39; + 3)</code> 放入 Call Stack 並直接執行，印出 i: 3</li>
<li>將 <code>setTimeout(() =&gt; &#123; console.log(i) &#125;, 3 * 1000)</code> 放入 Call Stack，透過 Web API，在瀏覽器設定計時器為 3000 ms ，直到倒數結束，將 <code>() =&gt; &#123; console.log(i) &#125;</code> 放到 Callback Queue 等待執行，setTimeout 執行結束後從 Call Stack 移除</li>
<li>第三圈迴圈結束，將 i + 1</li>
<li>i = 4，判斷 i 是否小於 5，是，進入第四圈迴圈</li>
<li>將 <code>console.log(&#39;i: &#39; + 4)</code> 放入 Call Stack 並直接執行，印出 i: 4</li>
<li>將 <code>setTimeout(() =&gt; &#123; console.log(i) &#125;, 4 * 1000)</code> 放入 Call Stack，透過 Web API，在瀏覽器設定計時器為 4000 ms ，直到倒數結束，將 <code>() =&gt; &#123; console.log(i) &#125;</code> 放到 Callback Queue 等待執行，setTimeout 執行結束後從 Call Stack 移除</li>
<li>第四圈迴圈結束，將 i + 1</li>
<li>i = 5，判斷 i 是否小於 5，否，跳出迴圈，執行結束後從 Call Stack 移除</li>
<li>當 Event Loop 偵測到 call stack 為空時，依序將 Callback Queue 的任務丟到 Call Stack 執行</li>
<li>執行第一個 <code>() =&gt; &#123; console.log(i) &#125;</code>，再執行 <code>console.log(i)</code>，在 function 的 EC 中找不到 i，往上一層 EC 找，找到 i = 5，印出 5，執行結束從 Call Stack 移除</li>
<li>執行第二個 <code>() =&gt; &#123; console.log(i) &#125;</code>，再執行 <code>console.log(i)</code>，在 function 的 EC 中找不到 i，往上一層 EC 找，找到 i = 5，印出 5，執行結束從 Call Stack 移除</li>
<li>執行第三個 <code>() =&gt; &#123; console.log(i) &#125;</code>，再執行 <code>console.log(i)</code>，在 function 的 EC 中找不到 i，往上一層 EC 找，找到 i = 5，印出 5，執行結束從 Call Stack 移除</li>
<li>執行第四個 <code>() =&gt; &#123; console.log(i) &#125;</code>，再執行 <code>console.log(i)</code>，在 function 的 EC 中找不到 i，往上一層 EC 找，找到 i = 5，印出 5，執行結束從 Call Stack 移除</li>
<li>執行第五個 <code>() =&gt; &#123; console.log(i) &#125;</code>，再執行 <code>console.log(i)</code>，在 function 的 EC 中找不到 i，往上一層 EC 找，找到 i = 5，印出 5，執行結束從 Call Stack 移除</li>
</ol>
<hr>
<h2 id="hw3：Hoisting"><a href="#hw3：Hoisting" class="headerlink" title="hw3：Hoisting"></a>hw3：Hoisting</h2><p>請說明以下程式碼會輸出什麼，以及盡可能詳細地解釋原因。</p>
<pre><code class="js">var a = 1
function fn() &#123;
  console.log(a)    // undefined
  var a = 5
  console.log(a)    // 5
  a++　
  var a
  fn2()
  console.log(a)     // 6
  function fn2() &#123;
    console.log(a)     // 20 
    a = 20
    b = 100
  &#125;
&#125;
fn()
console.log(a)     // 1
a = 10
console.log(a)     // 10
console.log(b)     // 100</code></pre>
<h3 id="輸出結果-2"><a href="#輸出結果-2" class="headerlink" title="輸出結果"></a>輸出結果</h3><pre><code class="js">undefined
5
6
20
1
10
100</code></pre>
<h3 id="執行流程-2"><a href="#執行流程-2" class="headerlink" title="執行流程"></a>執行流程</h3><ol>
<li>開始執行程式，建立 global EC 並初始化 VO</li>
</ol>
<pre><code class="js">global EC
  VO &#123;
    fn: function,
    a: undefined
  &#125;
&#125;</code></pre>
<ol start="2">
<li>執行第一行程式碼，宣告變數 a 並賦值為 1</li>
</ol>
<pre><code class="js">global EC &#123;
  VO &#123;
    fn: function,
    a: 1
  &#125;
&#125;</code></pre>
<ol start="3">
<li>呼叫 fn()，建立 fn EC 並初始化 AO，變數宣告會提升 <code>var = a</code></li>
</ol>
<pre><code class="js">fn EC &#123;
  AO &#123;
    fn2: function,
    a: undefined
  &#125;
&#125;</code></pre>
<ol start="4">
<li>進入 function fn 並執行 console.log(a)，找到 fn AO 中 a = undefined，印出 undefined</li>
<li>執行 var a = 5，查看 fn EC 是否有 a，找到 a，將 a 賦值為 5</li>
</ol>
<pre><code class="js">fn EC &#123;
  AO &#123;
    fn2: function,
    a: 5
  &#125;
&#125;</code></pre>
<ol start="6">
<li>執行 console.log(a)，找到 fn AO 中 a = 5，印出 5</li>
<li>執行 a++，查看 fn EC 是否有 a，將 a 賦值為 6</li>
</ol>
<pre><code class="js">fn EC &#123;
  AO &#123;
    fn2: function,
    a: 6
  &#125;
&#125;</code></pre>
<ol start="8">
<li>已經宣告過變數 a，忽略 <code>var a</code> </li>
<li>呼叫 fn2()，建立 fn EC 並初始化 AO</li>
</ol>
<pre><code class="js">fn2 EC &#123;
  AO &#123;
    // 沒有進行任何宣告
  &#125;
&#125;</code></pre>
<ol start="10">
<li>進入 function fn2 並執行 console.log(a)，查看 fn2  AO 沒有找到 a；往上一層 fn AO 找，找到 a = 6，印出 6</li>
<li>執行 a = 20，在 fn2 AO 沒有找到 a；往上一層 fn AO 找，找到 a，並賦值 a 為 20</li>
</ol>
<pre><code class="js">fn EC &#123;
  AO &#123;
    fn2: function,
    a: 20
  &#125;
&#125;</code></pre>
<ol start="12">
<li>執行 b = 100，在 fn2 AO 沒有找到 b；往上一層 fn AO 找，沒有找到 b；再往上一層 global VO 找，沒有找到 b。因為是在非嚴格模式執行程式碼，會在 global VO 宣告變數 b 並賦值為 100</li>
</ol>
<pre><code class="js">global EC
  VO &#123;
    fn: function,
    a: 1
    b: 100
  &#125;
&#125;</code></pre>
<ol start="13">
<li>function fn2 執行結束，移除 fn2 EC，回到 fn EC 執行其餘程式碼</li>
<li>執行 console.log(a)，找到 fn AO 中 a = 20，印出 20</li>
<li>function fn 執行結束，移除 fn EC，回到 global EC 執行其餘程式碼</li>
<li>執行 console.log(a)，找到 global VO 中 a = 1，印出 1</li>
<li>執行 a = 10，查看 global EC 是否有 a，找到 a，將 a 賦值為 10</li>
</ol>
<pre><code class="js">global EC
  VO &#123;
    fn: function,
    a: 10
    b: 100
  &#125;
&#125;</code></pre>
<ol start="18">
<li>執行 console.log(a)，找到 global VO 中 a = 10，印出 10</li>
<li>執行 console.log(b)，找到 global VO 中 b = 100，印出 100</li>
</ol>
<hr>
<h2 id="hw4：What-is-this"><a href="#hw4：What-is-this" class="headerlink" title="hw4：What is this?"></a>hw4：What is this?</h2><p>請說明以下程式碼會輸出什麼，以及盡可能詳細地解釋原因。</p>
<pre><code class="js">const obj = &#123;
  value: 1,
  hello: function() &#123;
    console.log(this.value)
  &#125;,
  inner: &#123;
    value: 2,
    hello: function() &#123;
      console.log(this.value)
    &#125;
  &#125;
&#125;

const obj2 = obj.inner
const hello = obj.inner.hello
obj.inner.hello()    // 2
obj2.hello()    // 2
hello()     // undefined</code></pre>
<h3 id="輸出結果-3"><a href="#輸出結果-3" class="headerlink" title="輸出結果"></a>輸出結果</h3><pre><code class="js">2
2
undefined</code></pre>
<h3 id="執行流程-3"><a href="#執行流程-3" class="headerlink" title="執行流程"></a>執行流程</h3><ol>
<li><code>obj.inner.hello()</code></li>
</ol>
<p>可看成 <code>.call()</code> 的形式：<code>obj.inner.hello.call(obj.inner)</code>，this 會是傳入的參數，也就是 <code>obj.inner</code>，因此 <code>obj.inner.value</code> 得到的結果是 2。</p>
<ol start="2">
<li><code>obj2.hello()</code></li>
</ol>
<p>和上一題相同，可看成 <code>.call()</code> 的形式：<code>obj2.hello.call(obj2)</code>，this 就會是 <code>obj2</code>，又因 <code>obj2 = obj.inner</code>，因此結果同樣會是 2。</p>
<ol start="3">
<li><code>hello()</code></li>
</ol>
<p>在不需要的地方呼叫 this 時，this 會被指定為全域物件。依照執行環境不同，其值也會改變，例如在瀏覽器執行會是 Window，在 node.js 執行則是會是 Global。<br>若是在<code>&#39;use strict&#39;;</code>（嚴格模式）下執行，this 的值會是 undefined。</p>
<h2 id="這週學了一大堆以前搞不懂的東西，你有變得更懂了嗎？請寫下你的心得。"><a href="#這週學了一大堆以前搞不懂的東西，你有變得更懂了嗎？請寫下你的心得。" class="headerlink" title="這週學了一大堆以前搞不懂的東西，你有變得更懂了嗎？請寫下你的心得。"></a>這週學了一大堆以前搞不懂的東西，你有變得更懂了嗎？請寫下你的心得。</h2><h3 id="這週的學習筆記"><a href="#這週的學習筆記" class="headerlink" title="這週的學習筆記"></a>這週的學習筆記</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWpzMjAxLWRhdGEtdHlwZQ==">[week 16] JavaScript 進階 - 關於變數與資料型態<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWpzMjAxLWhvaXN0aW5n">[week 16] JavaScript 進階 - 初探 Hoisting &amp; Execution Context<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWphdmFzY3JpcHQtY2FsbGJhY2s=">[week 16] 淺談 JavaScript：同步與非同步 &amp; Callback Function &amp; Event Loop<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWpzMjAxLWNsb3N1cmU=">[week 16] JavaScript 進階 - 什麼是閉包？探討 Closure &amp; Scope Chain<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWpzMjAxLW9vcC1wcm90b3R5cGU=">[week 16] JavaScript 進階 - 物件導向 &amp; Prototype<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWpzMjAxLXRoaXM=">[week 16] JavaScript 進階 - What is this？<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="學習心得"><a href="#學習心得" class="headerlink" title="學習心得"></a>學習心得</h3><p>這一週的知識量其實蠻大的，從複習 JavaScript 的變數與資料型態，等號賦值與記憶體位置等等，在第二週的課程也有提到相關概念，到了第十六週則是要去瞭解程式背後是如何運作的。</p>
<h4 id="Hoisting-amp-Execution-Contexts-amp-Variable-Object"><a href="#Hoisting-amp-Execution-Contexts-amp-Variable-Object" class="headerlink" title="Hoisting &amp; Execution Contexts &amp; Variable Object"></a>Hoisting &amp; Execution Contexts &amp; Variable Object</h4><p>從理解什麼是 Hoisting（提升），瞭解我們為什麼需要提升，再延伸到運作原理。過程中建立的 Execution Contexts（執行環境）、與之對應的 Variable Object（變數物件）等等，其實涉及到有關 JavaScript 的範圍非常廣。</p>
<p>除了課堂影片提到的內容，自己也上網查了許多有關執行環境、執行堆疊的資料，雖然花費不少時間，卻也藉由瞭解 JavaScript 的編譯與執行過程，從建立到執行階段，加深對整個架構的理解。</p>
<h4 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h4><p>在閱讀完 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmh1bGkudHcvMjAxOS8xMC8wNC9qYXZhc2NyaXB0LWFzeW5jLXN5bmMtYW5kLWNhbGxiYWNrLw==">JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！<i class="fa fa-external-link-alt"></i></span> 這篇文章，原本對 callback 概念薄弱的自己，對同步與非同步又有了新的一層認識。</p>
<p>尤其是才剛接著學完有關 Hoisting 的運作原理，在瞭解什麼是執行環境以後，再回來看 Event Loop 似乎也更能夠理解當中的執行流程。</p>
<p>也想到再次看到 Node.js 是 JavaScript 的 runtime（執行環境）這句話時，會想到 Execution Context 的中文也被翻成執行環境，但其實兩者指的對象不同。前者指的是「執行時系統」（run-time system）；後者指的是 JavaScript 在執行時會建立的環境，又可分為全域與函式執行環境。翻成中文的壞處就是容易撞名混淆，還是讓自己盡量去理解原文的意思。</p>
<h4 id="Closure-amp-Scope"><a href="#Closure-amp-Scope" class="headerlink" title="Closure &amp; Scope"></a>Closure &amp; Scope</h4><p>在學到 Closure（閉包）時，發現其實花了很多時間在瞭解有關 Scope（作用域）的概念。也是在這一單元瞭解到，原來之前在課程中學到的非同步操作，當中的 callback 其實就和閉包有關，有關 callback 的觀念真的非常重要，也難怪這些觀念會不斷在課程中被提到。</p>
<p>此外也瞭解到，閉包在框架中很常會使用到，透過閉包的方式，就能夠避免汙染全域變數或是記憶體洩漏等問題。</p>
<p>一開始之所以沒辦法很快理解，或許就是沒有把這些觀念融會貫通，都是一個環節接著另一個環節，就和 Scope Chain 一樣，會需要往上一層去找出需要的拼圖。</p>
<h4 id="物件導向-amp-prototype"><a href="#物件導向-amp-prototype" class="headerlink" title="物件導向 &amp; prototype"></a>物件導向 &amp; prototype</h4><p>其實在學習 JavsScript 之前，一直以為物件導向和 this 是能夠畫上等號的（三個的那種）。直到實際學到物件導向以後，才瞭解到物件導向中有許多觀念，其實和在之前學到的 Hoisting、Closure 有很大的關聯。此外，物件導向其實應用在許多現代的程式語言，以物件導向的方式進行開發。</p>
<p>物件導向程式的寫法，基本上可分為三部分：</p>
<ol>
<li>定義物件類別（class）。例如：<code>class Dog</code></li>
<li>定義物件類別中的屬性與方法。例如：可使用 <code>dog.name</code> 存取屬性，使用 <code>dog.sayHello()</code> 存取方法</li>
<li>定義物件之間的行為，也就是主程式</li>
</ol>
<p>之所以需要物件導向，最重要的目的就是把資料（屬性）與函式（方法）結合在一起，定義出物件模型，這麼做有幾個優點：</p>
<ul>
<li>便於重複使用程式碼</li>
<li>能夠隱藏程式內部資訊</li>
<li>透過模組化來簡化主程式邏輯</li>
</ul>
<p>而這些概念，其實也就是先前談到有關物件導向的三大特性，並且三者具有次序性，沒有封裝就不可能有繼承、沒有繼承就不可能有多型：</p>
<ul>
<li>封裝（Encapsulation）：<ul>
<li>藉由把程式包成類別，能夠隱藏物件內容</li>
<li>避免程式間互相干擾，也利於後續維護</li>
</ul>
</li>
<li>繼承（Inheritance）：<ul>
<li>子層能夠繼承使用父層的屬性和方法，並且加以微調</li>
<li>能夠重複使用程式碼</li>
</ul>
</li>
<li>多型（Polymorphism）：<ul>
<li>父層可透過子層衍伸成多種型態，接著子層可藉由覆寫父層的方法來達到多型</li>
<li>可增加程式架構的彈性與維護性</li>
</ul>
</li>
</ul>
<p>藉由瞭解什麼是物件導向，為什麼需要物件導向以後，對整體架構似乎又更加清楚一些。過程中也查了許多資料，在碰到新的名詞時總會感到慌張，像是 constructor（建構子）、prototype（原型）、instance（實例）等等，其實只要能夠先瞭解定義是什麼，就不難繼續理解整體架構。</p>
<p>最後，在找相關資料的時候，有在這篇<span class="exturl" data-url="aHR0cHM6Ly9pZ291aXN0LmdpdGh1Yi5pby9wb3N0LzIwMjAvMDcvb28tNS1wb2x5bW9ycGhpc20v">網誌<i class="fa fa-external-link-alt"></i></span>中，看到使用泡麵的例子來比喻物件導向，因為還蠻喜歡的也記錄在這裡：</p>
<ol>
<li>由泡麵工廠製作麵和醬包，並包裝在一起，我們可以直接買來享用</li>
<li>我們可以在泡麵中自己加料，或是不用泡的改用炒的</li>
<li>同樣都是泡麵，卻能夠實作出不同的口味</li>
</ol>
<h4 id="What-is-this？"><a href="#What-is-this？" class="headerlink" title="What is this？"></a>What is this？</h4><p>瞭解到物件導向的相關概念後，接著要理解 this 是什麼就沒那麼困難了。或許是因為在實際學 JacaScript 以前，就預設 this 是很難是高手在用的東西，透過慢慢理解物件導向與 this 的關聯，以及如何判斷 this 的值，似乎也感覺到自己的進化，對於未知的恐懼總是需要克服的。</p>
<p>關於 this 的重點，就是記得 this 的值和程式碼在哪無關，而是和怎麼呼叫有關係。</p>
<p>總結前面提到的觀念，其實 this 大致可分成四種綁定方式：</p>
<ul>
<li>默認綁定</li>
</ul>
<p>在和物件導向無關的情況下，this 會被指定為全域物件。又依照執行環境不同，其值會是 global 或 window，而在嚴格模式下會是 undefined：</p>
<pre><code class="javascript=">function test() &#123;
  console.log(this);     // Window 
&#125;
test();</code></pre>
<ul>
<li>隱式綁定</li>
</ul>
<p>若在 function 中， this 有被某物件指定為屬性並呼叫，this 就是呼叫 function 的物件。以下方範例來說 this 就是 obj：</p>
<pre><code class="javascript=">function func() &#123;
  console.log(this.a);
&#125;

var obj = &#123;
  a: 4,
  test: func
&#125;;

obj.test();  // 4</code></pre>
<ul>
<li>顯示綁定</li>
</ul>
<p>若是透過 <code>.call()</code>、<code>.apply()</code> 或 <code>.bind()</code> 方式指定 this，this 就會是傳入的參數：</p>
<pre><code class="javascript=">var obj = &#123;
  a: 10,
  test: function () &#123;
    console.log(this);
  &#125;
&#125;

obj.test.call(obj)
obj.test.apply(obj)

// 第一種寫法：直接呼叫 function
obj.test.bind(obj)();
// 第二種寫法：先宣告，再呼叫
const bindTest = obj.test.bind(obj);
bindTest();  

// 均印出: &#123; a: 10, test: [Function: test] &#125;</code></pre>
<ul>
<li>new 綁定</li>
</ul>
<p>透過建構函式 new 出一個 instance，this 就會是 instance 物件本身：</p>
<pre><code class="javascript=">class Dog &#123;
  constructor(name) &#123;
    this.name = name;
    console.log(this);       // Dog &#123;name: &quot;dog A&quot;&#125;
    console.log(this.name);  // dog A
  &#125;
&#125;

var a = new Dog(&#39;dog A&#39;);</code></pre>
<ul>
<li>例外：箭頭函式中的 this 是看程式碼定義在哪，和怎麼呼叫沒關係。</li>
</ul>
<h4 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h4><p>終於學到傳說中的物件導向，以及面對 JavaScript 中的大魔王 this。還記得在開始程式導師計畫之前，有在 Udemy 買過 JavaScript: Understanding the Weird Parts（中譯：JavaScript 全攻略：克服 JS 的奇怪部分）這堂課，但其實那時候也沒看多少，現在想想當初連基礎都還沒打穩，難怪會不知道自己在聽什麼XD。上網查過資料會發現蠻多類似的標題，不外乎是「你所不知道的 JS」、「其實 JS 跟你想的不一樣」等等，所以 JavaScript 到底是怪在哪？！在學完 JavaScript 基礎之後，還只是理解這個程式語言的皮毛而已。</p>
<p>把這一週的筆記整理完，寫作業的時候也感覺踏實多了，總算是釐清  Event Loop、Hoisting、Closure、物件導向和 this 等相關概念。或許是因為看到新名詞時總會感到害怕，會忍不住去查定義，查為什麼要這樣用，不這樣用又會有什麼影響等等，好像要先完全掌握這些名詞的意義以後，才能在繼續再下一步前進。</p>
<p>但實際上，在嘗試理解的過程中，有很重要的一點，就是「實作」。與其查了一堆定義和文字一翻兩瞪眼，倒不如跟著課程範例操作，實際在程式跑過一遍，知道會有怎樣的結果以後，才能理解文字的意義，然後再去試著自己變化程式碼，看看結果有沒有和自己想的一樣，到最後就差不多能夠自己寫出簡單的範例來了。</p>
<p>硬是要把提升、閉包、物件導向或是一些方法定義背起來，其實也記不久，看過就忘了，想想這其實也是自己的壞習慣，在還沒理解之前會想著乾脆先記起來，但隨著要學習的東西越深越廣，再用這種方法實在不是長久之計，直接來個範例吧！是最近有關學習的體悟，之後也要謹記這件事情。</p>
<p>總之，終於把 JavaScript 進階的相關觀念都 Run 過一遍，大致瞭解背後是如何運作，也把過去一些錯誤的觀念改正，或是終於瞭解為什麼以前想賦值給某個變數時，沒有辦法改動值等等。不過理解觀念是一回事，重要的還是如何實際應用，之後實作時也要來試著運用物件導向的概念去寫程式。</p>
<p>再來要繼續往下一週邁進了，繼續努力！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【中場心得】半年過去了，我仍在學習程式的路上（下篇）</title>
    <url>/lidemy-learning-2/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/oEOkZDK.jpg"><br>（<span>Photo by <span class="exturl" data-url="aHR0cHM6Ly91bnNwbGFzaC5jb20vQGpsdWVia2U/dXRtX3NvdXJjZT11bnNwbGFzaCZhbXA7dXRtX21lZGl1bT1yZWZlcnJhbCZhbXA7dXRtX2NvbnRlbnQ9Y3JlZGl0Q29weVRleHQ=">Justin Luebke<i class="fa fa-external-link-alt"></i></span> on <span class="exturl" data-url="aHR0cHM6Ly91bnNwbGFzaC5jb20vcy9waG90b3Mvcm9hZD91dG1fc291cmNlPXVuc3BsYXNoJmFtcDt1dG1fbWVkaXVtPXJlZmVycmFsJmFtcDt1dG1fY29udGVudD1jcmVkaXRDb3B5VGV4dA==">Unsplash<i class="fa fa-external-link-alt"></i></span></span>）</p>
<a id="more"></a>
<blockquote>
<p>“Do not, for one repulse, give up the purpose that you resolved to effect.” — William Shakespeare.</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZWlkaS1jb2RpbmcubWVkaXVtLmNvbS8lRTQlQjglQUQlRTUlQTAlQjQlRTUlQkYlODMlRTUlQkUlOTctJUU1JThEJThBJUU1JUI5JUI0JUU5JTgxJThFJUU1JThFJUJCJUU0JUJBJTg2LSVFNiU4OCU5MSVFNCVCQiU4RCVFNSU5QyVBOCVFNSVBRCVCOCVFNyVCRiU5MiVFNyVBOCU4QiVFNSVCQyU4RiVFNyU5QSU4NCVFOCVCNyVBRiVFNCVCOCU4QS0lRTQlQjglOEIlRTclQUYlODctN2ZjODE3MjQ1ZTY=">Medium 連結<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>幾天前分享的<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9hYm91dC1sZWFyaW5nLXBhcnQx">上篇心得<i class="fa fa-external-link-alt"></i></span>有稍微提到，前半段會偏向描寫過去的個人經驗，是有關於在開始學習程式之前的自己。</p>
<p>接下來這篇文章，則是要來談談自己在學習過程中內心的轉變，是什麼因素帶來這樣的影響；以及在參加<span class="exturl" data-url="aHR0cHM6Ly9ib290Y2FtcC5saWRlbXkuY29tLw==">第四期程式導師計畫<i class="fa fa-external-link-alt"></i></span>以前，曾經透過哪些管道自學程式語言；還有在學習過程中，遇到了哪些困難與挫折，而自己又是如何調整心態去面對的。</p>
<p>文章大綱如下，共分為上下兩篇，本篇為後半部分：</p>
<ul>
<li>萬事必有起因</li>
<li>關於那些沒能選擇的過去</li>
<li>如夢似幻的那一年</li>
<li>值得不值得</li>
<li>失而復得的熱情</li>
<li>恐懼的背後什麼都沒有</li>
<li>找到適合自己的學習方式</li>
<li>慢慢變成理想中的樣子</li>
</ul>
<p>那麼，以下是關於開始學習程式之後的一些心路歷程。</p>
<hr>
<h2 id="失而復得的熱情"><a href="#失而復得的熱情" class="headerlink" title="失而復得的熱情"></a>失而復得的熱情</h2><p>在上篇心得中，曾談到自己在求學期間開始學習日文這件事。即使這門語言不是自己的主科，只不過是一門選修課，卻還是習慣每天接觸它，變成像吃飯一樣的日常，意識到這件事情的我，人生也因此產生了一些變化。</p>
<p>或許自己也不是那麼一無是處，還是能夠對某件事情產生熱情。好比說，因為有了喜歡的事物，透過這層媒介，我開始看起了從沒想過會接觸的舞台劇，會去聽喜歡的聲優所主持的廣播節目，刷日文推特追蹤最新消息也成了每日習慣，甚至還會利用空閒時間去做一些日文翻譯。</p>
<p>其實這些是過去的自己從沒想過會做的事情，以前頂多當作興趣，偶爾會看看動畫和日劇，依賴於中文字幕；但到了後來，卻變成能夠主動去吸收知識，遇到不懂的單字就去查，記起來就能變成自己的，不知不覺間，即使沒有字幕也能大概理解意思，只因為自己喜歡日文。</p>
<p>因為喜歡，就會願意花時間去學習，而那些曾付出的時間並不會欺騙自己；因為喜歡，就不會先去想結果會是如何，而是選擇先做再說；因為喜歡，所以能夠不被外在因素影響，只專注在自己喜歡的事物上。</p>
<p>像這樣透過一點一滴的累積，我能夠實際感受到，自己懂的東西也越來越多，只要願意付出時間學習，是能夠讓自己慢慢變得更強大的。在不知不覺之中，我體會到什麼叫做「學習正回饋」，這段過程對我來說非常重要。</p>
<p>簡單來說，就是透過喜歡這份動力，來持續學習這件事：</p>
<pre><code>喜歡某件事 → 產生學習動力 → 全力學習 → 得到正向回饋 → 持續循環</code></pre>
<p>說了這麼多，但怎麼都在講學日文？那學程式呢？</p>
<p>很推薦 Huli 寫的這篇：<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2h1bGlzLWJsb2cvcHJvY3Jhc3RpbmF0aW9uLWJhMTI3NTRhZGE0OQ==">致跟我一樣的拖延症患者：動力是需要刻意創造的<i class="fa fa-external-link-alt"></i></span>。覺得當中有句話說得非常好：</p>
<h3 id="「動力是消耗品，需要補充、需要加值」"><a href="#「動力是消耗品，需要補充、需要加值」" class="headerlink" title="「動力是消耗品，需要補充、需要加值」"></a>「動力是消耗品，需要補充、需要加值」</h3><p>自己在閱讀過程也不斷被戳中。總會在心裡想著今年一定要完成XXX事情，買了課程想學也好、讀完幾本小說也好、要瘦下幾公斤也好，卻每隔一段時間後才驚覺，那份熱情只在開頭燃燒幾天就消退了。明日復明日，明日何其多。</p>
<p>沒辦法補充學習動力的自己，也就因此逐漸脫離正軌，變得想逃避學習這件事；沒辦法從學習中獲得成就感的自己，也因此更恐懼學習新事物，到後來甚至變成一種習慣，從此陷入無窮迴圈。</p>
<p>正因為有學日文這個例子，讓我相信，動力是能夠被創造的，在學習任何事情時，或許也同樣能夠遵循這個道理。回想在過去學習的路上，曾幾何時也遺忘了這件事。或許是害怕無法達成理想中的自己，而被數不盡的藉口以及拖延症給束縛住；又或許是因為太過在意身旁的人們，隨之萌生的不甘心與懊悔，反而掩蓋住學習過程中獲得的快樂。</p>
<blockquote>
<p>如果我不知道自己喜不喜歡，那又該怎麼辦呢？</p>
</blockquote>
<p>這個問題，就好像是聽到有人問說：「你喜歡吃某某食物嗎？」如果我剛好沒吃過，就會理所當然回答：「這我不知道欸！可能要吃吃看才會知道？」</p>
<p>要嘗試接觸新事物也是同樣道理，與其猶豫再三，思考沒有解答的問題，不如直接嘗試看看吧！對於不知道自己是否會「變得喜歡」的事情，就算把問題拋給旁人，即使對方會通靈也沒有辦法肯定你會不會真的喜歡。</p>
<p>如果在實際嘗試之後，發現結果好像和之前想像中的不太一樣，那也沒有關係，因為這還只是在摸索階段，還不需付出太大的成本，只是藉此更加瞭解了自己而已，畢竟自我探索的過程是一輩子的事：</p>
<pre><code>1. 不知道會不會喜歡 → 直接嘗試看看 → 產生學習動力 → 得到正向回饋 → 持續循環
2. 不知道會不會喜歡 → 直接嘗試看看 → 和想像中的不太一樣 → 尋找下一個可能</code></pre>
<p>怎麼說著說著，好像變得有點心靈雞湯的感覺XD 可能是因為剛好前幾天才跟友人聊到類似的話題，覺得深有所感，彷彿看到半年前的自己一樣，即使現在的自己也還同樣身處在摸索階段，在對方的眼中，自己就好像已經找到未來方向似的確定。</p>
<p>而面對朋友拋出的這些問題：「我不知道自己會喜歡什麼、又適合什麼工作…」，對於感情問題，我一率建議直接分…咳、是直接嘗試看看再說，既然不確定答案為何，反之也代表充滿無限的可能性。</p>
<p>再回到為什麼我會開始學習程式這個問題。在思考未來方向的某一天，我想到自己在幾年前，曾在 <span class="exturl" data-url="aHR0cHM6Ly9oYWhvdy5pbi8=">Hahow<i class="fa fa-external-link-alt"></i></span> 買過有關動畫互動設計的課程，回想起當初因為想要記錄在日本的生活，而想要打造屬於自己的網頁的故事。</p>
<p>然後就在不知不覺中，學出一點心得（雖然課程還沒有看完），因為覺得有些課程內容，對於初學的自己來說不是很好理解，就也開始尋找其他網路上的學習資源，邊學邊看許多有關這個領域的文章，像是瞭解前端與後端的差別、和自己一樣<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2h1bGlzLWJsb2cvZnJvbnRlbmQtZW5naW5lZXItZ3VpZGUtMjk3ODIxNTEyZjRl">零基礎的小明系列<i class="fa fa-external-link-alt"></i></span>、和一些給非本科系生想要轉職的建議與心得，也曾去聽過資策會的課程說明會等等。</p>
<p>後來，因為查到一些評論推薦說六角的課程適合初學者入門，就選擇在<span class="exturl" data-url="aHR0cHM6Ly93d3cuaGV4c2Nob29sLmNvbS8=">六角學院<i class="fa fa-external-link-alt"></i></span>繼續學習網頁前端基礎。發現透過不同的教學方式，不同的切入角度，能夠讓自己對程式語言有新的一層認識。</p>
<p>然後經過幾個禮拜，不斷循環練習切版、讓助教改作業、檢討的過程。在上完 HTML &amp; CSS 課程之後，再來應該繼續學習 jQuery 還是 RWD 呢？這段學習過程的確讓我獲得了成就感，但內心似乎又覺得不太踏實，究竟是缺少了什麼？我應該再學些什麼，才能夠讓自己變得更強，直到獲得足以踏入這個領域的入場門票呢？</p>
<p>在思考這些問題的當下，無意間我發現了有關<span class="exturl" data-url="aHR0cHM6Ly9odWxpdHcubWVkaXVtLmNvbS9saWRlbXktbWVudG9yLXByb2dyYW0tNHRoLTM5ZjU4YTAwMDY3Yw==">程式導師實驗計劃<i class="fa fa-external-link-alt"></i></span>的宣傳文章，而且還剛好在報名期間。看過課綱以後，不知為何，我很確信這就是我想尋找的。透過為期六個月的計畫，從程式基礎打起，瞭解前後端語言的差別，接著透過實作來熟悉開發流程等等。</p>
<p>看到那些充實的課程內容，竟然讓自己再次燃起學習熱情，我才明白，原來自己還是渴望學習的。而且和過去的被動學習不一樣了，這次是自己來選擇想要的東西，我想要改變自己。</p>
<h2 id="恐懼的背後什麼都沒有"><a href="#恐懼的背後什麼都沒有" class="headerlink" title="恐懼的背後什麼都沒有"></a>恐懼的背後什麼都沒有</h2><p>其實回想起這一路走來，總是對自己很沒自信，甚至到了會自我懷疑的程度。就好比膝跳反射，一旦要接觸新事物時，第一個反應一定會是「我不行、我辦不到」，悲觀地認為自己沒有那個能耐去勝任。</p>
<p>即使是直到三月左右，或是真正開始自學程式以後，這個現象依然如影隨形，我真的學得好嗎？我會不會太天真了？</p>
<blockquote>
<p>好害怕失敗，害怕新的開始，怕自己學不好，怕即使學完也找不到工作，怕就算順利找到工作結果卻不適合自己，怕……（以下略）。</p>
</blockquote>
<p>阿到底是在怕什麼？怕就能解決問題嗎？靜下來仔細想想，其實害怕並無助於任何事，只會讓自己駐足不前。這些道理我都明白，卻還是會忍不住去擔心害怕。</p>
<h3 id="人之所以會感到害怕，通常來自於對事物的不瞭解、不熟悉，也就是對於未知的恐懼。"><a href="#人之所以會感到害怕，通常來自於對事物的不瞭解、不熟悉，也就是對於未知的恐懼。" class="headerlink" title="人之所以會感到害怕，通常來自於對事物的不瞭解、不熟悉，也就是對於未知的恐懼。"></a>人之所以會感到害怕，通常來自於對事物的不瞭解、不熟悉，也就是對於未知的恐懼。</h3><p>倒不如說，「害怕」這份情緒其實會一直伴隨自己，或許是害怕失敗，又或許是害怕被比較，害怕自己被貼上「劣等」的標籤。</p>
<p>更何況，未來是不可預期的，不同階段或身分其實也存在不同的問題要去煩惱。就好比學生時期，煩惱不要被當和煩惱怎麼拚到書卷獎是完全不同的事；又好比月薪 3 萬和 25 萬要煩惱的事情也不會相同。</p>
<p>這讓我想到，每週在 Limedy 的學習系統上也有談到類似的話題：</p>
<blockquote>
<p>假如我今天想學某樣東西，卻花了兩三天的時間來思考自己究竟學不學得會。<br>假如學得會，就等於浪費掉這兩三天，因為如果不猶豫的話就可以再多兩三天來學習了；假如學不會，那這兩三天也是浪費掉的，因為只光憑想像而不動手，根本不會知道自己是真的學不會，還是只是「我認為自己學不會」。</p>
</blockquote>
<p>與其浪費過多的時間在猶豫不決、或是自我懷疑身上，倒不如直接動手做，這樣才能更快找出真正的答案。</p>
<p>在正式開始程師導師實驗計畫以前，其實有個前置作業，也就是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpZGVteS9tZW50b3ItcHJvZ3JhbS00dGgjJUU3JUFDJUFDJUU5JTlCJUI2JUU5JTgwJUIxJUU1JUJGJTgzJUU2JTg1JThCJUU1JTlGJUI5JUU5JUE0JThB">第零週的心態培養<i class="fa fa-external-link-alt"></i></span>。在學習之前若是能夠先培養好心態，對於之後的學習也會容易許多。</p>
<p>當中有提到下列幾點，有關如何建立心態：</p>
<ol>
<li>不要害怕問問題，每個問題都值得被提出來，你的問題可能也是其他人的問題</li>
<li>問問題前應該先自己動手查詢資料，如果是很難查的也可以直接問</li>
<li>有老師、助教或同學能夠讓你盡量問，反正問就對了</li>
<li>重點是「目的」，而不是「手段」，持續問為什麼為什麼為什麼為什麼</li>
<li>學程式需要換一個思維模式</li>
</ol>
<p>其實最重要的，就是「懂得適時提問」這件事。接受自己有不懂的東西，然後不要害怕問問題；如果自己解決不了，就要趕快尋求他人幫助，如此也能避免自己鑽牛角尖或繞遠路，否則可能結果是浪費時間又沒能找到答案。</p>
<p>然而，如果每個人都能夠像這樣理性思考，或許人生也不會有那麼多煩惱存在了。理智上告訴自己不應該逃避學習，卻又會忍不住倒退三步，本來可以馬上完成的作業不知不覺又拖了兩三天。</p>
<p>老實說，自己也是不擅長主動發問的學生，就是那種在課堂上打死不舉手的那種，除非遇到老師規定每人都要發問，不問就要被扣分數的時候，可能才會很痛苦的擠出一兩個問題來問。</p>
<p>但後來我發現到，如果是私下問問題的話自己還是能辦到的，可能是利用課餘時間找老師或助教，或是透過一些學習系統發問，抑或是乾脆找比較熟的同學問等等。</p>
<p>之所以會在眾人面前發問感到害怕，我想根本原因還是在於「害怕」他人的眼光，如果我問的是笨問題怎麼辦？如果被別人發現我連這麼簡單的東西都不懂怎麼辦？我怎麼知道我的問題別人也可能遇到？像是害怕被發現自已其實是個失敗者似的，結果就成為一個既不敢發問，又害怕犯錯的學生。</p>
<p>也是從開始學習語言以後，才試著努力改掉這個不敢問問題的壞習慣，畢竟有很多時候，是需要仰賴有經驗的人，來幫助自己少繞一點遠路的。但即使是現在，要自己在所有人面前提問還是很有障礙的一件事，但還是會試著把握住能夠提問的學習平台，或是找看看有沒有同學曾和自己有過相同經歷能夠參考等等。</p>
<p>此外，提問也是有技巧的，詳細可以參考這篇文章：<span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIxMzM3Nj9zYz1pVGhvbWVS">第一天上班就該學會的精準提問術<i class="fa fa-external-link-alt"></i></span>。記住個重點，就是提問時要帶著自己的答案找人，才能讓對方知道自己是有嘗試解決，而不是懶得找方法解決的伸手牌。</p>
<p>總之，為了能夠克服內心的恐懼，這些也都是需要慢慢練習的，只要能夠比昨天的自己又往前邁進一步，就是戰勝恐懼的第一步。</p>
<p>以自己在學習程式這段過程來說，在接觸某個新的程式語言或工具之前，總會忍不住在心底吶喊「這看起來也太難了吧！」。像是第四週學習如何串接 API、第八週的同步與非同步、第九週第一次接觸的後端語言 PHP、第十四週架設遠端主機、第十六週的 JavaScript 物件導向等等。</p>
<p>就算學習過程中遭遇滿滿的挫折，自己最終還是順利把作業給完成了。無論那些東西看起來再怎麼困難，只要自己願意花時間去學習它，那麼恐懼也就會隨著理解而慢慢消散。</p>
<p>即使如此，偶爾還是會擔心自己學得不夠扎實，那這也就不是「能不能學會」這個問題，而是「熟練不熟練」的問題才對。就像前面所提到的，每個階段都有每個階段要去煩惱的問題存在，重要的還是專注於當下的自己。</p>
<p>也是直到後來，瞭解到在這世界上，其實多數人都會對生活的未知感到恐懼，像是周遭和自己有類似際遇的人，或者即使是那些看起來很耀眼的人們，還是會害怕自己不夠好、害怕失敗，似乎也就慢慢釋懷「和他人比較」這件事了。</p>
<p>再回到最根本的問題，所以我們應該如何面對恐懼、面對失敗？</p>
<p>節錄 Huli 在<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2h1bGlzLWJsb2cvYmVmb3JlLWxlYXJuaW5nLWI5YjkzM2I2MDc4ZQ==">學程式的第零課：心態調整<i class="fa fa-external-link-alt"></i></span>這篇寫的一段話，一方面也用來提醒自己：</p>
<blockquote>
<p>為什麼要讓別人幫你定義成功或失敗？這一點都不合理。你管他什麼成功跟失敗，知道自己在幹嘛就好了。</p>
</blockquote>
<p>與其把時間浪費在思考不確定的結果，或是害怕自己會不會失敗，不如直接去面對它，試著排除外在的雜音，把重心放在自己身上，然後試著面對問題，並找出適合的方法來解決它。</p>
<p>要記得，就算結果真的失敗了，人生也不會就此畫下句點，這些都只是過程的一部分，而失敗與挫折會化作成功的養分。因為只要我還沒放棄，比賽就還沒有結束，我只是走得比別人慢了一點，但我相信自己最終還是會到達。</p>
<hr>
<h2 id="找到適合自己的學習方式"><a href="#找到適合自己的學習方式" class="headerlink" title="找到適合自己的學習方式"></a>找到適合自己的學習方式</h2><p>在這半年中，我發現比起學習程式本身，更困難的，其實是該如何建立健全的心態來面對學習。</p>
<p>就好比要在一片空地蓋房子，假如地基一開始就沒有打穩，即使有再好的設計圖或工程器具，也沒辦法打造出理想中的樣貌，可能才蓋到一半建築物本身就先垮掉了。</p>
<p>人的內心也是一樣的，其實我並不是一個內心堅強的人，也會擔心自己跟不上進度。所以在真正開始學習程式以前，就先接受「我就爛」的事實，我就是因為什麼都不會，才要從現在開始學啊！</p>
<p><img src="https://i.imgur.com/HiU7ndw.png"></p>
<p>回想起在六月程師導師計畫開始之前，自己有先看過 Huli 的基礎課程：<span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvY3MxMDEtY29kaW5n">[CS101] 初心者的計概與 coding 火球術<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvYWxnMTAxLWxlZXRjb2Rl">[ALG101] 先別急著寫 leetcode <i class="fa fa-external-link-alt"></i></span>，對計概這門課的第一印象其實是在 Hahow 平台的時候，沒想到會在這裡再次相遇。</p>
<p>再加上之前自學 HTML &amp; CSS 打下的基礎，或許就類似於預習的概念，多虧有提前開始奔跑，所以直到第九週以前，自己還是能跟上進度甚至是超前的，但是後來呢？</p>
<p>在計畫剛開始的時候，自己還有在做兼職，一週五天的那種文書工作。因此，要想達成每週四十小時的學習時間，勢必得每天都固定持續學習才能辦到。但，只要是人總會有惰性，尤其自己又不是意志力足夠堅定的類型，等前端基礎告一段落，正式踏入後端基礎課程時，先前儲存的扣打也用得差不多了。</p>
<p>直到課程進入中場，漸漸地發現自己有些負荷不來，為了有更充足的學習時間，兼職也從五天改為三天，直到上個月乾脆辭去，下了決心改為全職學習。但這樣自己是否就能全心全意在學習上了呢？其實並沒有，說來慚愧，自己可能就是那種容易邁向失敗的例子，已經沒辦法像高中時期從早讀到晚，這樣的我，是不是不適合寫程式？難道我要就這樣放棄嗎？</p>
<p>不、絕對不是這樣的，就像上一段提到的，這些都只是過程的一部分。如果一天學不起來，那就再多花一天；如果有一行程式碼寫不出的程式，那就再多寫一行。還沒學會怎麼爬之前，又怎能妄想一夕之間學會如何飛翔？</p>
<h3 id="速度並不代表一切"><a href="#速度並不代表一切" class="headerlink" title="速度並不代表一切"></a>速度並不代表一切</h3><p>永遠要記得「先求有再求好」，有做比沒做好，做好比有做好，總之先做做看就知道了。究竟資質優劣、成效好壞、成功與否，在還沒開始之前都只是空談，重要的是自己如何去面對這件事情。</p>
<p>或許當下我是進度落後了，但我只是跑得比較慢而已，就算資質高低不同、就算起跑點不同又如何呢？我已經盡自己最大的努力了嗎？難道參加這個程式計畫是為了被打擊信心？絕對不只是這樣。</p>
<p>或許我不會是最厲害的那一個，但我可以把握這個機會，學習怎樣寫出「好」的程式碼。與其糾結在「為什麼他可以想出這種解法我卻不行？」，不如換位思考，也許之前的我只是不夠熟悉而已，只要我能理解程式碼的邏輯，日後我也能把這個概念應用在其他專案上。</p>
<p>學習方法是需要不斷去調整適應的，正因為一定會有比自己還要厲害的人存在，透過這些社群互動與同儕刺激，能夠讓自己慢慢瞭解這世界有多大，原來可以用不同的思考邏輯去解決問題，而這些是靠自己單打獨鬥所無法接觸到的。</p>
<p>最後總結幾點自己在學習過程遇到的困難，以及自己如何去面對，或是正在進行式，仍然在摸索的問題：</p>
<blockquote>
<p>「害怕自己學不好，害怕比不上別人，害怕轉職失敗。」</p>
</blockquote>
<ul>
<li>大多情況下，恐懼這份情緒其實是自己想像出來的</li>
<li>與其浪費時間去想東想西，不如直接動手去驗證結果，光是在腦中想像事情並不會有任何進展</li>
<li>每個人學習的起跑點不同，花費的時間與成效也不盡相同，不需要太過在乎身旁的人</li>
</ul>
<blockquote>
<p>「進度落後了怎麼辦？想要加快腳步，卻又擔心學得不夠扎實怎麼辦？」</p>
</blockquote>
<ul>
<li>不需要總是跟其他人比較，學習專注在自己的學習上</li>
<li>一開始就想要學到 100% 需要付出的成本太大，不如先把課程都跑完，學會了以後剩下的就是提高熟練度</li>
<li>雖然說不需太過在乎進度落後這件事，但也需提醒自己落後了多少，做好時間管理同樣重要，真正進入職場後是不可能這樣寬容自己的</li>
</ul>
<blockquote>
<p>「對於學習產生惰性，覺得無法完全理解內容，導致效率低落。」</p>
</blockquote>
<ul>
<li>試著改變學習步調，例如原本預計一天要看完整個章節、要寫完整週的作業、要寫完一篇文章，可以把目標切成一段一段，變成看完一小節、寫第一份作業、寫一行文字。萬事起頭難，先讓自己習慣有個開始</li>
<li>試著改變學習方式，適時跳過也是很重要的技巧，比如幾週前 callback function 學得很頭痛，先跟著範例實作，剛開始不需要到完全理解，有時候多做幾次不知不覺就學會了</li>
<li>試著改變學習環境，例如在家裡無法集中精神，可以到咖啡廳或圖書館學習</li>
<li>讓自己維持規律生活也是個辦法，把學習變成一種習慣</li>
<li>找一些求職訊息，未來應徵自己夢想中的公司可能需要會哪些技能，激發自己產生動力去學習</li>
</ul>
<h2 id="慢慢變成理想中的樣子"><a href="#慢慢變成理想中的樣子" class="headerlink" title="慢慢變成理想中的樣子"></a>慢慢變成理想中的樣子</h2><p>有的時候，會覺得這段日子就像在跑馬拉松一樣，即使有許多人同時開跑，卻也能感受到自己是獨自一人在前行，但同學之間擁有共同目標，老師和助教也適時給予協助，儘管如此，真正去學習程式這件事還是得靠自己。</p>
<p>最近看了一部很喜歡的動畫《強風吹拂》，這是一部以「跑步」作為主題的作品，當中多數人是從沒想過人生中會出現跑步這個選項，當中幾段台詞非常有感：</p>
<blockquote>
<p>「以為只靠努力就能無所不能，其實是一種傲慢。」</p>
</blockquote>
<p>為什麼我這麼努力了，卻還是和前面的人差這麼遙遠？很多時候，我們往往只看到結果，而難以去想像別人背後經過的事情，甚至因此產生相對剝奪感。</p>
<p>卻很少會思考過，也許對方早在幾個月、幾年之前就開始奔跑，又或著對方其實就是萬中選一的天才。不管如何，要記住速度並不代表一切，別人的成功與否，與自己的將來其實是非關聯的，更重要的，是如何專注於自己，專注當下，不斷去思考自己想成為怎樣的人。</p>
<blockquote>
<p>「但是，實際跑起來，我卻發現，比起被強制要求跑步，自願去奔跑要快樂得多。不是因為喜歡，才認真起來，而是因為認真起來，說不定就能……」</p>
</blockquote>
<p>或許在還沒嘗試之前，永遠都不會知道自己會不會喜歡寫程式；也正因為是自己所選擇的路，而不是被強制說一定要這麼做，所以更加確信自己會走到最後，說不定就會喜歡上這條路也說不定。即使最後失敗又如何？至少我還是學會了些什麼，一切並不會歸零，而是會帶著這些經驗值前往下一個遠方。</p>
<p>回到最一開始的問題：「為什麼會想學寫程式？」</p>
<p>想起某一年曾寫過的作文題目《我曾那樣追尋》，那時的我其實不知該如何下筆，很難去想像未來的事，縱使引用了一句句事先背好的名言佳句，對於人生仍充滿迷惘，但是現在，我好像能夠找到答案了。</p>
<p>在學習程式這段過程中，我能夠與自己對話，回想起學習的快樂，然後確信這就是我想尋找的。也因此，打從開始加入程式導師計畫以來，我知道自己會走完這段課程，不管時間拉的多長，不論這路走得有多狼狽，還是想要追尋這個夢想，為了能夠慢慢接近那理想中的自己。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>最後放上我在課程中的學習筆記、GitHub 頁面，個人網誌目前正在架設中，會慢慢把之前寫的筆記或文章搬運過來：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWxpZGVteQ==">Lidemy 程式導師計畫第四期 - 每週學習筆記<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMA==">GitHub<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="https://heidiliu2020.github.io/">Heidi’s Blog</a></li>
</ul>
<p>在總結自己這半年來的學習心得時，發現其實很多道理是當初「第零週心態建立」中就有提及的，結果也引用不少 Huli 說過的話，作為紀錄的同時也用來提醒自己，也很推薦那些跟我一樣迷惘的人去閱讀原文。</p>
<p>也許是還沒有親身體驗就不會懂，如果能早一點瞭解這些道理，或許也就不用浪費那麼多時間和內心的自己打架，或許也就能夠跟上課程進度也說不定；但人生沒有如果，我們能做的，也就是咬緊牙根繼續走下去。不過也不需走得那樣痛苦，試著從中獲得成就感與快樂同樣很重要，如此這條路也才能走得更久更遠。</p>
<p>Happy learning, happy coding!</p>
]]></content>
      <categories>
        <category>Lidemy</category>
      </categories>
      <tags>
        <tag>Lidemy</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 12] 利用 PHP 實作留言板 - API 篇</title>
    <url>/php-api/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvYmUxMDEtcGhwLW15c3Fs">[BE101] 用 PHP 與 MySQL 學習後端基礎<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正。</p>
</blockquote>
<blockquote>
<p>hw1：<span class="exturl" data-url="aHR0cDovL21lbnRvci1wcm9ncmFtLmNvL210cjA0Z3JvdXAyL0hlaWRpL3dlZWsxMi9odzEv">JavaScript 留言板<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<a id="more"></a>

<h4 id="參考筆記"><a href="#參考筆記" class="headerlink" title="參考筆記"></a>參考筆記</h4><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMC9UaGlzLWlzLUNvZGVkaWFyeS9ibG9iL21hc3Rlci93ZWVrNF8lRTclQjYlQjIlRTglQjclQUYlRTUlOUYlQkElRTclQTQlOEUlRTYlQTYlODIlRTglQUIlOTYubWQ=">[week 4] 網路基礎概論 - HTTP 協定、TCP/IP、API<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMC9UaGlzLWlzLUNvZGVkaWFyeS9ibG9iL21hc3Rlci93ZWVrOF8lRTUlODIlQjMlRTklODAlODElRTglQjMlODclRTYlOTYlOTklRTclOUElODQlRTYlOTYlQjklRTUlQkMlOEYlRTMlODAlODElRTclODAlOEYlRTglQTYlQkQlRTUlOTklQTglRTclOUElODQlRTklOTklOTAlRTUlODglQjYubWQ=">[week 8] 傳送資料的方式 &amp; 瀏覽器的限制<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="什麼是-API？"><a href="#什麼是-API？" class="headerlink" title="什麼是 API？"></a>什麼是 API？</h2><p>API 就是純資料的交換。資料以 JSON 形式儲存。</p>
<p>在第八週時，我們學會使用 JavaScript 來串接 API，前端負責顯示資料，後端只負責提供資料。</p>
<p>之前實作的留言板是透過 PHP 直接輸出內容。這週我們會透過 PHP 實作 API，再使用 JavaScript 串接 API 來動態顯示資料。</p>
<h3 id="如何測試-API"><a href="#如何測試-API" class="headerlink" title="如何測試 API"></a>如何測試 API</h3><p>有幾種方式能夠測試 API 是否能成功運行。可參考這篇文章介紹：<span class="exturl" data-url="aHR0cHM6Ly9ub29iLnR3L3Bvc3RtYW4v">API 實作(三)：以 Postman 測試 API<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>瀏覽器：撰寫程式碼不易，步驟繁瑣</li>
<li>curl 工具：不易進行 debug</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucG9zdG1hbi5jb20v">Postman<i class="fa fa-external-link-alt"></i></span>：方便使用，能夠針對不同分頁或欄位進行測試</li>
</ul>
<h2 id="練習：實作無會員機制的留言版-API"><a href="#練習：實作無會員機制的留言版-API" class="headerlink" title="練習：實作無會員機制的留言版 API"></a>練習：實作無會員機制的留言版 API</h2><h3 id="PHP-相關語法"><a href="#PHP-相關語法" class="headerlink" title="PHP 相關語法"></a>PHP 相關語法</h3><ul>
<li><code>header(&#39;Content-Type: application/json; charset=utf-8&#39;);</code>：指定瀏覽器以 JSON 格式內容，UTF-8 字元編碼</li>
<li><code>array_push()</code>：在一個陣列中，再插入一個值進去<ul>
<li>語法：<code>array_push(欲增加的陣列, 值)</code><pre><code class="php=">&lt;?php 
$array = array(); 
array_push($array, &quot;Test&quot;); 
print_r($array); 
?&gt;
// 輸出結果: Array ( [0] =&gt; Test )</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="用-PHP-實作-API"><a href="#用-PHP-實作-API" class="headerlink" title="用 PHP 實作 API"></a>用 PHP 實作 API</h3><p>首先要瞭解如何使用 PHP 做出 API，以 <code>api_comments.php</code> 下列程式碼為例：</p>
<pre><code class="php=">&lt;?php
  // 宣告變數 comments 為空陣列
  $comments = array();
  // 把資料放到陣列 $comments，裡面再建立陣列 array
  array_push($comments, array(
    &quot;id&quot; =&gt; 1,
    &quot;username&quot; =&gt; &quot;aaa&quot;,
    &quot;content&quot; =&gt; &quot;123&quot;
  ));
  array_push($comments, array(
    &quot;id&quot; =&gt; 2,
    &quot;username&quot; =&gt; &quot;bbb&quot;,
    &quot;content&quot; =&gt; &quot;456&quot;
  ));

  $json = array(
    &quot;comments&quot; =&gt; $comments
  );

  $response = json_encode($json);
  // 讓瀏覽器知道我們要印出 JSON 格式
  header(&#39;Content-Type: application/json; charset=utf-8&#39;);
  echo $response;
?&gt;</code></pre>
<p>在瀏覽器接收到的 response 就是 JSON 格式的物件，可使用開發者工具查看內容：</p>
<p><img src="https://i.imgur.com/RJIaktu.png"></p>
<h3 id="實作-API：列出所有文章"><a href="#實作-API：列出所有文章" class="headerlink" title="實作 API：列出所有文章"></a>實作 API：列出所有文章</h3><p>把之前實作留言板 <code>index.php</code> 時，使用的語法結合到 <code>api_comments.php</code>，即可得到只輸出資料的 API：</p>
<pre><code class="php=">&lt;?php
  require_once(&quot;conn.php&quot;);

  // 和 index.php 抓取資料的語法相同
  $page = 1;
  if (!empty($_GET[&#39;page&#39;])) &#123;
    $page = intval($_GET[&#39;page&#39;]);
  &#125;
  $items_per_page = 5;
  $offset = ($page - 1) * $items_per_page; 

  $sql =  &quot;SELECT &quot;.
            &quot;C.id as id, C.content AS content, &quot;. 
            &quot;C.created_at AS created_at, U.nickname AS nickname, U.username AS username &quot;.
          &quot;FROM heidi_comments AS C &quot;. 
          &quot;LEFT JOIN heidi_users AS U ON C.username = U.username &quot;.
          &quot;WHERE C.is_deleted IS NULL &quot;.
          &quot;ORDER BY C.id DESC &quot;.
          &quot;LIMIT ? OFFSET ? &quot;;
  $stmt = $conn-&gt;prepare($sql);
  $stmt-&gt;bind_param(&quot;ii&quot;, $items_per_page, $offset);
  $result = $stmt-&gt;execute();
  if (!$result) &#123;
    die(&#39;Error:&#39; . $conn-&gt;error);
  &#125;
  $result = $stmt-&gt;get_result();
  $comments = array();

  // 把讀取的資料放到陣列 $comments，裡面再建立陣列 array，概念比較像 JS 物件
  while($row = $result-&gt;fetch_assoc()) &#123;
    array_push($comments, array(
    &quot;id&quot; =&gt; $row[&#39;id&#39;],
    &quot;username&quot; =&gt; $row[&#39;username&#39;],
    &quot;nickname&quot; =&gt; $row[&#39;nickname&#39;],
    &quot;content&quot; =&gt; $row[&#39;content&#39;],
    &quot;created_at&quot; =&gt; $row[&#39;created_at&#39;]
    ));
  &#125;

  $json = array(
    &quot;comments&quot; =&gt; $comments
  );

  $response = json_encode($json);
  // 讓瀏覽器知道我們要印出 JSON 格式
  header(&#39;Content-Type: application/json; charset=utf-8&#39;);
  echo $response;
?&gt;</code></pre>
<p>上述程式碼，和 <code>index.php</code> 同樣是讀取資料，差別在於 API 是把資料放到陣列 <code>$comments</code>，裡面再建立陣列 array，概念比較像 JS 物件。</p>
<h3 id="實作-API：新增文章"><a href="#實作-API：新增文章" class="headerlink" title="實作 API：新增文章"></a>實作 API：新增文章</h3><p>以 <code>api_add_comment.php</code> 為例，寫法會和 <code>handle_add_comment.php</code>（新增留言功能）的邏輯類似：</p>
<pre><code class="php=">&lt;?php
  require_once(&#39;conn.php&#39;);

  header(&#39;Content-Type: application/json; charset=utf-8&#39;);
  // 若讀取失敗
  if (
    empty($_POST[&#39;content&#39;])
  ) &#123;
    $json = array(
      &quot;ok&quot; =&gt; false,
      &quot;message&quot; =&gt; &quot;Please input content&quot;
    );

    $response = json_encode($json);
    echo $response;
    die(); 
  &#125;

  $username = $_POST[&#39;username&#39;];
  $content = $_POST[&#39;content&#39;];

  $sql = &quot;INSERT INTO heidi_comments(username, content)
    VALUES(?, ?)&quot;;
  $stmt = $conn-&gt;prepare($sql);
  $stmt-&gt;bind_param(&#39;ss&#39;, $username, $content);
  $result = $stmt-&gt;execute();
  // 若執行失敗
  if (!$result) &#123;
    $json = array(
      &quot;ok&quot; =&gt; false,
      &quot;message&quot; =&gt; $conn-&gt;error
    );

    $response = json_encode($json);
    echo $response;
    die(); 
  &#125;
  // 若成功讀取資料
  $json = array(
      &quot;ok&quot; =&gt; true,
      &quot;message&quot; =&gt; &quot;Success&quot;
    );

    $response = json_encode($json);
    echo $response;
?&gt;</code></pre>
<p><img src="https://i.imgur.com/n9O600m.png"></p>
<h3 id="前端串接-API"><a href="#前端串接-API" class="headerlink" title="前端串接 API"></a>前端串接 API</h3><p>最後就是在前端頁面 <code>index.html</code> 串接寫好的 API：</p>
<pre><code class="javascript=">&lt;body&gt;
  &lt;div class=&quot;wrapper&quot;&gt;
    &lt;main class=&quot;board&quot;&gt;　
      &lt;div class =&quot;board__header&quot;&gt;
        &lt;h1 class=&quot;board__tittle&quot;&gt;Comments&lt;/h1&gt;
        &lt;div class=&quot;board__btn-block&quot;&gt; 
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;form class=&quot;board__new-comment-form&quot;&gt;
        &lt;textarea name=&quot;content&quot; rows=&quot;5&quot; placeholder=&quot;請輸入留言...&quot;&gt;&lt;/textarea&gt;
        &lt;input class=&quot;board__submit-btn&quot; type=&quot;submit&quot;&gt;
      &lt;/form&gt;
    &lt;div class=&quot;board__hr&quot;&gt;&lt;/div&gt;

    &lt;section&gt;
       // 動態新增留言的區塊...
    &lt;/section&gt;
    &lt;/main&gt;
  &lt;/div&gt;

  &lt;script&gt;
      // 發出 Request
      var request = new XMLHttpRequest();
      request.open(&#39;GET&#39;, &#39;api_comments.php&#39;, true);

      request.onload = function() &#123;
        if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123;
          var resp = this.response;
          var json = JSON.parse(resp)
          var comments = json.comments

          for (var i = 0; i &lt; comments.length; i++) &#123;
            var comment = comments[i]
            var div = document.createElement(&#39;div&#39;)
            div.classList.add(&#39;card&#39;)
            div.innerHTML = `
              &lt;div class=&quot;card__avatar&quot;&gt;&lt;/div&gt;
              &lt;div class=&quot;card__body&quot;&gt;
                  &lt;div class=&quot;card__info&quot;&gt;
                    &lt;span class=&quot;card__author&quot;&gt;
                      $&#123;encodeHTML(comment.nickname)&#125;(@$&#123;encodeHTML(comment.username)&#125;)
                    &lt;/span&gt;
                    &lt;span class=&quot;card__time&quot;&gt;
                      $&#123;encodeHTML(comment.created_at)&#125;
                    &lt;/span&gt;
                  &lt;/div&gt;
                  &lt;p class=&quot;card__content&quot;&gt;$&#123;encodeHTML(comment.content)&#125;&lt;/p&gt;
              &lt;/div&gt;
            `
            document.querySelector(&#39;section&#39;).appendChild(div)
          &#125;
        &#125; 
      &#125;;
      request.send();

      var form = document.querySelector(&#39;.board__new-comment-form&#39;)
      form.addEventListener(&#39;submit&#39;, function(e) &#123;
        // 阻止預設事件: 送出表單
        e.preventDefault()
        // 讀取輸入內容
        var content = document.querySelector(&#39;textarea[name=content]&#39;).value
        var request = new XMLHttpRequest();
        // 發出 POST Request
        request.open(&#39;POST&#39;, &#39;api_add_comment.php&#39;, true);
        request.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded; charset=UTF-8&#39;);
        request.send(&quot;username=aaa&amp;content=&quot; + encodeURIComponent(content));
        request.onload = function() &#123;
          if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123;
            var resp = this.response;
            var json = JSON.parse(resp)
            if (json.ok) &#123;
              // 頁面重整: 可重新抓取留言
              location.reload()
            &#125; else &#123;
              alert(json.message)
            &#125;       
          &#125;
        &#125;
      &#125;)
      // 字串均需進行 escape 跳脫
      function encodeHTML(s) &#123;
        return s.replace(/&amp;/g, &#39;&amp;amp;&#39;).replace(/&lt;/g, &#39;&amp;lt;&#39;).replace(/&quot;/g, &#39;&amp;quot;&#39;);
      &#125;
  &lt;/script&gt;
&lt;/body&gt;</code></pre>
<hr>
<h2 id="實戰：增強版-JavaScript-留言板"><a href="#實戰：增強版-JavaScript-留言板" class="headerlink" title="實戰：增強版 JavaScript 留言板"></a>實戰：增強版 JavaScript 留言板</h2><p>接著要來打造後端 API，再利用前端 JavaScript 來串接 API 實作留言板功能。</p>
<h3 id="建立後端-API"><a href="#建立後端-API" class="headerlink" title="建立後端 API"></a>建立後端 API</h3><h4 id="Step1-建立資料庫-discussions"><a href="#Step1-建立資料庫-discussions" class="headerlink" title="Step1. 建立資料庫 discussions"></a>Step1. 建立資料庫 discussions</h4><ul>
<li>id</li>
<li>site_key</li>
<li>nickname</li>
<li>content</li>
<li>created_at</li>
</ul>
<h4 id="Step2-新增留言功能-api-add-comments-php"><a href="#Step2-新增留言功能-api-add-comments-php" class="headerlink" title="Step2. 新增留言功能 api_add_comments.php"></a>Step2. 新增留言功能 <code>api_add_comments.php</code></h4><pre><code class="php=">&lt;?php
  require_once(&#39;conn.php&#39;);
  // 讓瀏覽器知道回覆的資料是 JSON 格式
  header(&#39;Content-Type: application/json; charset=utf-8&#39;);
  // 錯誤處理: 確認資料是否為空值
  if (
    empty($_POST[&#39;nickname&#39;]) ||
    empty($_POST[&#39;site_key&#39;]) ||
    empty($_POST[&#39;content&#39;])
    ) &#123;
    $json = array(
      &quot;ok&quot; =&gt; false,
      &quot;message&quot; =&gt; &quot;Please input content&quot;
    );
    $response = json_encode($json);
    echo $response;
    die();
  &#125;

  $nickname = $_POST[&#39;nickname&#39;];
  $site_key = $_POST[&#39;site_key&#39;];
  $content = $_POST[&#39;content&#39;];

  $sql = &quot;INSERT INTO heidi_discussions(site_key, nickname, content) VALUES (?, ?, ?)&quot;;
  $stmt = $conn-&gt;prepare($sql);
  $stmt-&gt;bind_param(&#39;sss&#39;, $site_key, $nickname, $content);
  $result = $stmt-&gt;execute();
  // 錯誤處理: 確認是否執行成功
  if (!$result) &#123;
    $json = array(
      &quot;ok&quot; =&gt; false,
      &quot;message&quot; =&gt; $conn-&gt;error     // 通常不會直接顯示錯誤訊息，因為可能包含敏感資訊
    );
    $response = json_encode($json);
    echo $response;
    die();
  &#125;
  // 成功拿到資料
  $json = array(
    &quot;ok&quot; =&gt; true,
    &quot;message&quot; =&gt; &quot;success&quot;
  );
  // 把建立好的 $json 物件，轉成 JSON 字串輸出
  $response = json_encode($json);
  echo $response;
?&gt;</code></pre>
<p>利用 postman 以 <code>POST</code> 方式發出 request 測試，確認是否能新增留言到資料庫：</p>
<p><img src="https://i.imgur.com/f4m5fNp.png" alt="postmanTest"></p>
<h4 id="Step3-顯示留言功能-api-comments-php"><a href="#Step3-顯示留言功能-api-comments-php" class="headerlink" title="Step3. 顯示留言功能 api_comments.php"></a>Step3. 顯示留言功能 <code>api_comments.php</code></h4><pre><code class="php=">&lt;?php
  require_once(&#39;conn.php&#39;);
  // 讓瀏覽器知道回覆的資料是 JSON 格式
  header(&#39;Content-Type: application/json; charset=utf-8&#39;);
  // 用 site_key 來區分不同的留言版
  if (
    empty($_GET[&#39;site_key&#39;])
    ) &#123;
    $json = array(
      &quot;ok&quot; =&gt; false,
      &quot;message&quot; =&gt; &quot;Please add site_key in url&quot;
    );

    $response = json_encode($json);
    echo $response;
    die();
  &#125;

  $site_key = $_GET[&#39;site_key&#39;];

  $sql = &quot;SELECT nickname, content, created_at FROM heidi_discussions WHERE site_key = ? ORDER BY id DESC&quot;;
  $stmt = $conn-&gt;prepare($sql);
  $stmt-&gt;bind_param(&#39;s&#39;, $site_key);
  $result = $stmt-&gt;execute();
  // 錯誤處理: 確認是否執行成功
  if (!$result) &#123;
    $json = array(
      &quot;ok&quot; =&gt; false,
      &quot;message&quot; =&gt; $conn-&gt;error
    );
    $response = json_encode($json);
    echo $response;
    die();
  &#125;
  // 若執行成功就拿取資料
  $result = $stmt-&gt;get_result();
  $discussions = array();
  while($row = $result-&gt;fetch_assoc()) &#123;
    array_push($discussions, array(
      &quot;nickname&quot; =&gt; $row[&quot;nickname&quot;],
      &quot;content&quot; =&gt; $row[&quot;content&quot;],
      &quot;created_at&quot; =&gt; $row[&quot;created_at&quot;]
    ));
  &#125;

  $json = array(
    &quot;ok&quot; =&gt; true,
    &quot;discussions&quot; =&gt; $discussions
  );
  // 把建立好的 $json 物件，轉成 JSON 字串輸出
  $response = json_encode($json);
  echo $response;
?&gt;
</code></pre>
<p>利用 postman 以 <code>GET</code> 方式發出 request 測試，確認是否能讀取留言：</p>
<p><img src="https://i.imgur.com/2rjKvzl.png"></p>
<p>這樣就完成後端 API 的新增留言和顯示留言功能。</p>
<h3 id="前端串接-API-1"><a href="#前端串接-API-1" class="headerlink" title="前端串接 API"></a>前端串接 API</h3><h4 id="Step1-建立-UI-頁面"><a href="#Step1-建立-UI-頁面" class="headerlink" title="Step1. 建立 UI 頁面"></a>Step1. 建立 UI 頁面</h4><p>首先利用 <span class="exturl" data-url="aHR0cHM6Ly9nZXRib290c3RyYXAuY29tL2RvY3MvNC41L2dldHRpbmctc3RhcnRlZC9pbnRyb2R1Y3Rpb24v">Bootstrap<i class="fa fa-external-link-alt"></i></span> 來快速建立前端頁面 <code>index.html</code></p>
<h4 id="Step2-將前端頁面串接-API"><a href="#Step2-將前端頁面串接-API" class="headerlink" title="Step2. 將前端頁面串接 API"></a>Step2. 將前端頁面串接 API</h4><ul>
<li>顯示留言 API</li>
<li>新增留言 API</li>
</ul>
<pre><code class="htmlmixed=">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Week12 留言板&lt;/title&gt;
  &lt;!-- 引入 jQuery --&gt;
  &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;
  &lt;!-- 引入 Bootstrap --&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css&quot; integrity=&quot;sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z&quot; crossorigin=&quot;anonymous&quot;&gt;
  &lt;style&gt;
    .add-comment-form &#123;
      margin-bottom: 10px;
    &#125;
    .card &#123;
      margin-bottom: 10px;
    &#125;
    .card-body h5, .card-body span &#123;
      display: inline-block;
      margin-right: 20px;
    &#125;
  &lt;/style&gt;
  &lt;script&gt;
    // 跳脫函式
    function escape(toOutput) &#123;
      return toOutput
        .replace(/&amp;/g, &#39;&amp;amp;&#39;)
        .replace(/&lt;/g, &#39;&amp;lt;&#39;)
        .replace(/&gt;/g, &#39;&amp;gt;&#39;)
        .replace(/&quot;/g, &#39;&amp;quot;&#39;)
        .replace(/&#39;/g, &#39;&amp;#039;&#39;);
    &#125;
    // 渲染 comment: 處理讀取的資料 &amp; 決定加在最前面或最後面
    function appendCommentToDOM(container, comment, isPrepend) &#123;
      const html = `
        &lt;div class=&quot;card&quot;&gt;
          &lt;div class=&quot;card-body&quot;&gt;
            &lt;h5 class=&quot;card-title&quot;&gt;$&#123;escape(comment.nickname)&#125;&lt;/h5&gt;
            &lt;span&gt;$&#123;escape(comment.created_at)&#125;&lt;/span&gt;
            &lt;p class=&quot;card-text&quot;&gt;$&#123;escape(comment.content)&#125;
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      `;
      if (isPrepend) &#123;
        container.prepend(html);
      &#125; else &#123;
        container.append(html);
      &#125;
    &#125;

    const showUrl = &#39;http://localhost/heidi/week12_local/hw1/api_comments.php?site_key=heidi&#39;;
    const addUrl = &#39;http://localhost/heidi/week12_local/hw1/api_add_comments.php&#39;;

    $(document).ready(() =&gt; &#123;
      // 顯示留言
      const commentDOM = $(&#39;.comments&#39;)
      $.ajax(&#123;
        url: showUrl,
      &#125;).done(function (data) &#123;
        if (!data.ok) &#123;
          alert(data.message);
          return;
        &#125;
        // 若 request 成功讀取資料
        const comments = data.discussions;
        for (let comment of comments) &#123;
          appendCommentToDOM(commentDOM, comment);
        &#125;
      &#125;);

      // 新增留言: 將資料存到後端
      $(&#39;.add-comment-form&#39;).submit(e =&gt; &#123;
        e.preventDefault();             // 取消原生行為 -&gt; 不會送出表單
        const newCommentData = &#123;
          &#39;site_key&#39;: &#39;heidi&#39;,
          &#39;nickname&#39;: $(&#39;input[name=nickname]&#39;).val(),
          &#39;content&#39;: $(&#39;textarea[name=content]&#39;).val()
        &#125;
        $.ajax(&#123;
          type: &#39;POST&#39;,
          url: addUrl,
          data: newCommentData
        &#125;).done(function(data) &#123;        // done(): 以函數處理回傳的 data 資料
          // 執行失敗
          if (!data.ok) &#123;
            alert(data.message);
            return;
          &#125;
          // 執行成功: 按下送出後把欄位清空
          $(&#39;input[name=nickname]&#39;).val(&#39;&#39;);
          $(&#39;textarea[name=content]&#39;).val(&#39;&#39;);
          // 新增留言後以 JS 動態方式加到最上方
          appendCommentToDOM(commentDOM, newCommentData, true);
        &#125;);
      &#125;);
    &#125;);
  &lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;form class=&quot;add-comment-form&quot;&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;form-nickname&quot;&gt;暱稱&lt;/label&gt;
        &lt;input name=&quot;nickname&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;form-nickname&quot; &gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;content-textarea&quot;&gt;留言內容&lt;/label&gt;
        &lt;textarea name=&quot;content&quot; class=&quot;form-control&quot; id=&quot;exampleFormControlTextarea1&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt;
      &lt;/div&gt;
      &lt;button type=&quot;submit&quot; class=&quot;btn btn-dark&quot;&gt;送出&lt;/button&gt;
    &lt;/form&gt;
    &lt;div class=&quot;comments&quot;&gt;
      &lt;!-- 以 JavaScript 動態顯示資料的區塊 --&gt;
    &lt;/div&gt;
  &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4 id="Step3-實作分頁機制"><a href="#Step3-實作分頁機制" class="headerlink" title="Step3. 實作分頁機制"></a>Step3. 實作分頁機制</h4><ul>
<li><p>Offset/limit-based Pagination</p>
<ul>
<li>基於 Offset/limit 的分頁，也就是我們在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hlaWRpbGl1MjAyMC9UaGlzLWlzLUNvZGVkaWFyeS9ibG9iL21hc3Rlci93ZWVrMTFfJUU1JTg4JUE5JUU3JTk0JUE4UEhQJUU1JUFGJUE2JUU0JUJEJTlDJUU3JTk1JTk5JUU4JUE4JTgwJUU2JTlEJUJGXyVFNiU5NiVCMCVFNSVBMiU5RSVFNSU4QSU5RiVFOCU4MyVCRCVFNyVBRiU4Ny5tZA==">week11 實作的留言板<i class="fa fa-external-link-alt"></i></span></li>
<li>可計算資料的總數量、目前頁數，或跳到指定的頁數</li>
<li>缺點：當資料量大時執行緩慢</li>
</ul>
</li>
</ul>
<pre><code class="sql">-- 跳過 5 筆資料，回傳接下來的 5 筆資料
SELECT * FROM comments ORDER BY id DESC LIMIT 5 OFFSET 5</code></pre>
<ul>
<li><p>Cursor-based pagination</p>
<ul>
<li>基於 Cursor（指標）的分頁</li>
<li>可透過指定明確的起始點（Pointer）來回傳資料，例如：id 或 created_at</li>
<li>缺點：沒有「總和」和「頁數」的概念</li>
</ul>
</li>
</ul>
<h4 id="相關函式"><a href="#相關函式" class="headerlink" title="相關函式"></a>相關函式</h4><pre><code class="javascript=">// 再包一層 function 避免重複輸入同樣的程式碼
function getComments() &#123;
  const commentDOM = $(&#39;.comments&#39;);
  $(&#39;.load-more&#39;).hide();         // 點擊後就隱藏按鈕
  if (isEnd) &#123;
    return;          // 若拿完資料就直接返回
  &#125;
  getCommentsAPI(siteKey, lastId, data =&gt; &#123;
    if (!data.ok) &#123;
      alert(data.message);
      return;
    &#125;
    // 若 request 成功讀取資料
    const comments = data.discussions;
    for (let comment of comments) &#123;
      appendCommentToDOM(commentDOM, comment);
    &#125;
    let length = comments.length;
    // 沒有 lastId: 初始頁面的留言若 &lt; 5 直接返回
    if (!lastId &amp;&amp; length &lt; 5) &#123;
      return (comments.length &lt; 5);
    &#125; 
    // 有 lastId: 若拿完資料就隱藏按鈕
    if (length === 0) &#123;
      isEnd = true;
      $(&#39;.load-more&#39;).hide();
    &#125; else &#123;
      lastId = comments[length - 1].id;
      $(&#39;.comments&#39;).append(loadMoreButtonHTML);   // 新增 &quot;載入更多&quot; 按鈕
    &#125;
  &#125;);
&#125;</code></pre>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9qaWVwZW5nLm1lLzIwMTkvMTIvMDYvbGVhcm5pbmctaG93LXRvLWltcGxlbWVudC1ncmFwaHFsLXBhZ2luYXRpb24=">深入淺出 GraphQL Pagination 實作<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><h4 id="錯誤一-Reason"><a href="#錯誤一-Reason" class="headerlink" title="錯誤一 Reason"></a>錯誤一 Reason</h4><pre><code>Reason: CORS header &#39;Access-Control-Allow-Origin&#39; missing</code></pre>
<ul>
<li>原因：缺少表頭 <code>header(&#39;Access-Control-Allow-Origin: *&#39;);</code></li>
<li>實際情況：可能是 php 檔語法上有錯誤，才會出現這個錯誤訊息</li>
</ul>
<h4 id="錯誤二-TypeError"><a href="#錯誤二-TypeError" class="headerlink" title="錯誤二 TypeError"></a>錯誤二 TypeError</h4><pre><code>TypeError: Cannot read property &#39;replace&#39; of undefined</code></pre>
<p><img src="https://i.imgur.com/t5Me7wL.png"></p>
<ul>
<li>原因：要進行跳脫的值為 null</li>
<li>解決辦法：先判斷該值是否為空再進行 replace 操作</li>
</ul>
<p>參考網站：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tfcHJpbmNlL2FydGljbGUvZGV0YWlscy84OTM1MDEyND91dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnQubm9uZS10YXNrLWJsb2ctQmxvZ0NvbW1lbmRGcm9tTWFjaGluZUxlYXJuUGFpMi0xLmNoYW5uZWxfcGFyYW0mZGVwdGhfMS11dG1fc291cmNlPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnQubm9uZS10YXNrLWJsb2ctQmxvZ0NvbW1lbmRGcm9tTWFjaGluZUxlYXJuUGFpMi0xLmNoYW5uZWxfcGFyYW0=">Cannot read property ‘replace’ of undefined<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 22] React：用 SPA 架構實作一個部落格（一）- Router</title>
    <url>/react-router/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUzMDItcmVhY3QtaG9va3M=">[FE302] React 基礎 - hooks 版本<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<blockquote>
<p>參考文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmh1bGkudHcvMjAxOS8wOS8xOC9zcGEtY29tbW9uLXByb2JsZW0tYWJvdXQtcm91dGVyLw==">淺談新手在學習 SPA 時的常見問題：以 Router 為例<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<a id="more"></a>

<p>之前實作的留言板只有單一頁面，但隨著專案規模越大，需要藉由路由來渲染不同頁面時，就需要路由進行配置與管理，而 react-router-dom 套件就有提供這個功能。</p>
<p>接下來我們使用 React 搭配 Router，實作一個 SPA（Single Page Application）架構的部落格。</p>
<hr>
<h2 id="React-Router：管理專案路由"><a href="#React-Router：管理專案路由" class="headerlink" title="React Router：管理專案路由"></a>React Router：管理專案路由</h2><p>可參考<span class="exturl" data-url="aHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vd2ViL2d1aWRlcy9xdWljay1zdGFydA==">官方文件<i class="fa fa-external-link-alt"></i></span>，我們可透過 React Router 套件來管理 URL 路由。</p>
<h3 id="安裝-react-router-dom"><a href="#安裝-react-router-dom" class="headerlink" title="安裝 react-router-dom"></a>安裝 react-router-dom</h3><pre><code>$ npm install react-router-dom</code></pre>
<h3 id="用-Component-的概念設計-Router"><a href="#用-Component-的概念設計-Router" class="headerlink" title="用 Component 的概念設計 Router"></a>用 Component 的概念設計 Router</h3><p>React Router 同樣是要用寫 React 方式去理解，也就是以 Component 的概念去設計一個 Router。</p>
<p>這其實和我們之前寫 Back-End 時很不一樣，例如 <code>app.get(&#39;/comment&#39;)</code> ，代表讀取留言的路由。</p>
<p>可參考<span class="exturl" data-url="aHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vd2ViL2V4YW1wbGUvYmFzaWM=">官方<i class="fa fa-external-link-alt"></i></span>提供的範例：</p>
<iframe src="https://codesandbox.io/embed/react-router-basic-bnpsd?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;"
     title="React Router - Basic"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

<p>以下是上方範例的程式碼，透過連結改變的網址，由 Router 決定要 render 的畫面：</p>
<pre><code class="javascript=">export default function BasicExample() &#123;
  return (
    &lt;Router&gt;
      &lt;div&gt;
&lt;!--    點選連結改變網址    --&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;Link to=&quot;/dashboard&quot;&gt;Dashboard&lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;

        &lt;hr /&gt;
&lt;!-- 根據不同網址 render 相對應頁面 --&gt;
        &lt;Switch&gt;
          &lt;Route exact path=&quot;/&quot;&gt;
            &lt;Home /&gt;
          &lt;/Route&gt;
          &lt;Route path=&quot;/about&quot;&gt;
            &lt;About /&gt;
          &lt;/Route&gt;
          &lt;Route path=&quot;/dashboard&quot;&gt;
            &lt;Dashboard /&gt;
          &lt;/Route&gt;
        &lt;/Switch&gt;
      &lt;/div&gt;
    &lt;/Router&gt;</code></pre>
<h3 id="BrowserRouter-vs-HashRouter"><a href="#BrowserRouter-vs-HashRouter" class="headerlink" title="BrowserRouter vs HashRouter"></a>BrowserRouter vs HashRouter</h3><p>而在引入 Router 時，其實有兩種方式：</p>
<ul>
<li>BrowserRouter：直接在網址帶入路徑，但這種方式在 GitHub Pages 上其實會出現問題</li>
</ul>
<pre><code class="javascript=">import &#123;
  BrowserRouter as Router,
  Switch,
  Route,
  Link
&#125; from &quot;react-router-dom&quot;;</code></pre>
<p>如果是從首頁點選 dashboard，前端就會透過 JavaScript 提供的 API 把網址改成 /dashboard，能夠正常 render 畫面。</p>
<p>但如果是直接在網址後帶上 /dashboard，GitHub Pages 會去找 dashboard 資料夾底下的 index.html，此時瀏覽器會直接發 request 到該頁面，發生不如預期的錯誤。</p>
<ul>
<li>HashRouter：會在網址加上 <code>/#/</code>，瀏覽器就會去載入 <code>#</code> 符號之前的網址，即可改善上述問題</li>
</ul>
<pre><code>Home  https://bnpsd.csb.app/#/
dashboard  https://bnpsd.csb.app/#/dashboard</code></pre>
<p>有了以上關於 Router 的基本概念後，就來繼續實作專案吧！</p>
<h3 id="實作：管理專案-Router"><a href="#實作：管理專案-Router" class="headerlink" title="實作：管理專案 Router"></a>實作：管理專案 Router</h3><h4 id="1-App-js：根據不同-Component-管理路由"><a href="#1-App-js：根據不同-Component-管理路由" class="headerlink" title="1. App.js：根據不同 Component 管理路由"></a>1. App.js：根據不同 Component 管理路由</h4><pre><code class="javascript=">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;
import styled from &quot;styled-components&quot;;
import PropTypes from &quot;prop-types&quot;;
import LoginPage from &quot;../../pages/LoginPage&quot;;
import HomePage from &quot;../../pages/HomePage&quot;;
import Header from &quot;../Header&quot;;

import &#123; HashRouter as Router, Switch, Route &#125; from &quot;react-router-dom&quot;;

const Root = styled.div``;

export default function App() &#123;
  return (
    &lt;Root&gt;
      &#123;/* Router: 包在最外層 */&#125;
      &lt;Router&gt;
        &#123;/* 導覽列: 共同區塊 */&#125;
        &lt;Header /&gt;
        &#123;/* Switch: 確保只會匹配第一個符合網址列的路由 */&#125;
        &lt;Switch&gt;
          &#123;/* exact path: 代表完整匹配；若只有 path 是部分匹配 */&#125;
          &lt;Route exact path=&quot;/&quot;&gt;
            &lt;HomePage /&gt;
          &lt;/Route&gt;
          &lt;Route exact path=&quot;/login&quot;&gt;
            &lt;LoginPage /&gt;
          &lt;/Route&gt;
        &lt;/Switch&gt;
      &lt;/Router&gt;
    &lt;/Root&gt;
  );
&#125;</code></pre>
<ol start="2">
<li>整理專案結構</li>
</ol>
<ul>
<li>src<ul>
<li>components<ul>
<li>App</li>
<li>Header 導覽列（共同區塊）</li>
</ul>
</li>
<li>pages<ul>
<li>HomePage 首頁</li>
<li>LoginPage 登入頁面</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以建立 HomePage Component 為例，Header 和 LoginPage 也是用這個模式：</p>
<pre><code class="javascript=">// HomePage.js
import React, &#123; useState, useEffect &#125; from &quot;react&quot;;

export default function HomePage() &#123;
  return &lt;div&gt;Home Page&lt;/div&gt;;
&#125;</code></pre>
<p>而為了調整專案結構，需在 index.js 引入並引出 HomePage.js，可參考<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWZlMzAyLXJlYWN0LWJvYXJk">上篇筆記<i class="fa fa-external-link-alt"></i></span>：</p>
<pre><code class="javascript=">// index.js
export &#123; default &#125; from &quot;./HomePage&quot;;</code></pre>
<p>執行結果如下，可透過不同路由 render 相對應的頁面，其中 Header 是共同區塊不會變動：</p>
<p><img src="https://i.imgur.com/ff3aVd1.png"></p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmh1bGkudHcvMjAxOS8wOS8xOC9zcGEtY29tbW9uLXByb2JsZW0tYWJvdXQtcm91dGVyLw==">淺談新手在學習 SPA 時的常見問題：以 Router 為例<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wamNoZW5kZXIuYmxvZ3Nwb3QuY29tLzIwMTgvMTEvcmVhY3QtcmVhY3Qtcm91dGVyLWR5bmFtaWMtYnJlYWRjcnVtYi5odG1s">[React] 搭配 React Router 打造一個動態麵包屑（dynamic breadcrumb）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="實作：從切板開始！"><a href="#實作：從切板開始！" class="headerlink" title="實作：從切板開始！"></a>實作：從切板開始！</h2><h2 id="1-切板與整合-react-router"><a href="#1-切板與整合-react-router" class="headerlink" title="1. 切板與整合 react router"></a>1. 切板與整合 react router</h2><p>瞭解到如何管理路由之後，再來就是透過 component 切出想要的畫面。</p>
<p>首先進行 Header component 導覽列連結的部分。</p>
<h3 id="方法一：透過-Link、useLoction"><a href="#方法一：透過-Link、useLoction" class="headerlink" title="方法一：透過 Link、useLoction"></a>方法一：透過 Link、useLoction</h3><ul>
<li>使用 useLocation 讀取當前位置，再透過 $active 這個屬性判斷符合哪個路徑，render 出相對應畫面：</li>
</ul>
<pre><code class="javascript=">// 引入使用 Link, useLocation
import &#123; Link, useLocation &#125; from &quot;react-router-dom&quot;;

const location = useLocation();

&lt;Nav to=&quot;/&quot; $active=&#123;location.pathname === &quot;/&quot;&#125;&gt;</code></pre>
<p>程式碼如下：</p>
<pre><code class="javascript=">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;
import styled from &quot;styled-components&quot;;

import &#123; Link, useLocation &#125; from &quot;react-router-dom&quot;;

const HeaderContainer = styled.div`
  height: 58px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  border-bottom: 1px solid rgba(0, 0, 0, 0.2);
  box-shadow: 0px 0px 6px rgb(199, 197, 197);
  padding: 0px 32px;
`;

const Brand = styled.h1`
  margin: 0;
`;

const NavbarList = styled.ul`
  display: flex;
  align-items: center;
  list-style-type: none;
  text-decoration: none;
  margin: 0;
  padding: 0;
`;

const Nav = styled(Link)`
  height: 58px;
  width: 100px;
  display: flex;
  justify-content: center;
  align-items: center;
  text-decoration: none;
  color: #666;

  $&#123;(props) =&gt;
    props.$active &amp;&amp;
    `
      background: #eee;
      color: #222;
  `&#125;
`;

const LeftNavbar = styled.div`
  display: flex;
  align-items: center;

  /* 代表在 LeftNavbar 底下的 NavbarList */
  $&#123;NavbarList&#125; &#123;
    margin-left: 32px;
  &#125;
`;

export default function Header() &#123;
  // 可拿到目前路徑
  const location = useLocation();

  return (
    &lt;HeaderContainer&gt;
      &lt;LeftNavbar&gt;
        &lt;Brand&gt;
          &lt;Link exact to=&quot;/&quot;&gt;
            React 部落格
          &lt;/Link&gt;
        &lt;/Brand&gt;
        &lt;NavbarList&gt;
          &lt;Nav to=&quot;/&quot; $active=&#123;location.pathname === &quot;/&quot;&#125;&gt;
            首頁
          &lt;/Nav&gt;
          &lt;Nav to=&quot;/new-post&quot; $active=&#123;location.pathname === &quot;/new-post&quot;&#125;&gt;
            發布文章
          &lt;/Nav&gt;
        &lt;/NavbarList&gt;
      &lt;/LeftNavbar&gt;
      &lt;NavbarList&gt;
        &lt;Nav to=&quot;/login&quot; $active=&#123;location.pathname === &quot;/login&quot;&#125;&gt;
          登入
        &lt;/Nav&gt;
      &lt;/NavbarList&gt;
    &lt;/HeaderContainer&gt;
  );
&#125;</code></pre>
<h3 id="方法二：NavLink"><a href="#方法二：NavLink" class="headerlink" title="方法二：NavLink"></a>方法二：NavLink</h3><p>除了使用 useLocation 來判斷當前路徑，React Router 還有提供 <span class="exturl" data-url="aHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vd2ViL2FwaS9OYXZMaW5r">NavLink<i class="fa fa-external-link-alt"></i></span> 這個特殊的 Component，具有以下屬性：</p>
<ul>
<li>activeClassName(string)：設置選中樣式，預設為 active</li>
<li>activeStyle(object)：當元素被選中時，為此元素添加樣式</li>
<li>exact(bool)：為 true 時，只有當完全符合時才會應用</li>
<li>isActive(func)：判斷連結是否執行額外功能</li>
</ul>
<p>參考資料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/fcb87e3b4da4"><NavLink>的介紹與使用</a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczMjUxMi9hcnRpY2xlL2RldGFpbHMvMTAzMTgyODMxP3V0bV9tZWRpdW09ZGlzdHJpYnV0ZS5wY19yZWxldmFudF90MC5ub25lLXRhc2stYmxvZy1CbG9nQ29tbWVuZEZyb21CYWlkdS0xLmNvbnRyb2wmZGVwdGhfMS11dG1fc291cmNlPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnRfdDAubm9uZS10YXNrLWJsb2ctQmxvZ0NvbW1lbmRGcm9tQmFpZHUtMS5jb250cm9s">React手册之Link和NaviLink区别<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>可透過 activeClassName 屬性或 inline style 行內樣式，來表示 NavLink 有無被選取，官方提供的範例如下：</p>
<h4 id="引入使用-NavLink"><a href="#引入使用-NavLink" class="headerlink" title="引入使用 NavLink"></a>引入使用 NavLink</h4><pre><code class="javascript=">import &#123; NavLink &#125; from &#39;react-router-dom&#39;</code></pre>
<h4 id="1-一般寫法"><a href="#1-一般寫法" class="headerlink" title="1. 一般寫法"></a>1. 一般寫法</h4><pre><code class="javascript=">&lt;NavLink to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;</code></pre>
<h4 id="2-activeClassName-string"><a href="#2-activeClassName-string" class="headerlink" title="2. activeClassName: string"></a>2. activeClassName: string</h4><pre><code class="javascript=">&lt;NavLink to=&quot;/faq&quot; activeClassName=&quot;selected&quot;&gt;
  FAQs
&lt;/NavLink&gt;</code></pre>
<h4 id="3-activeStyle-object"><a href="#3-activeStyle-object" class="headerlink" title="3. activeStyle: object"></a>3. activeStyle: object</h4><pre><code class="javascript=">&lt;NavLink
  to=&quot;/faq&quot;
  activeStyle=&#123;&#123;
    fontWeight: "bold",
    color: "red"
  &#125;&#125;
&gt;
  FAQs
&lt;/NavLink&gt;</code></pre>
<p>但在實際應用的時候，有遇到個問題，就是如果想搭配 style-component 使用，會不知該如何傳入 activeClassName 這個 props！</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzQ0MTgyNTQvaG93LWRvLWktYWRkLWFuLWFjdGl2ZS1jbGFzcy10by1hLWxpbmstZnJvbS1yZWFjdC1yb3V0ZXI=">How do I add an active class to a Link from React Router?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>針對如何在 NavLink 組件中使用 activeClassName 屬性，參考一些網路上的範例進行改寫，以下示範兩種作法：</p>
<h4 id="1-透過-styled-component-在-NavLink-component，使用-attr-自訂屬性-activeClassName："><a href="#1-透過-styled-component-在-NavLink-component，使用-attr-自訂屬性-activeClassName：" class="headerlink" title="1. 透過 styled component 在 NavLink component，使用 .attr() 自訂屬性 activeClassName："></a>1. 透過 styled component 在 NavLink component，使用 .attr() 自訂屬性 activeClassName：</h4><pre><code class="javascript=">const activeClassName = &#39;nav-item-active&#39;

const StyledLink = styled(NavLink).attrs(&#123; activeClassName &#125;)`

  &amp;.$&#123;activeClassName&#125; &#123;
    background: #eee;
  &#125;
`;

// ...
      &lt;NavbarList&gt;
        &lt;StyledLink exact to=&quot;/&quot;&gt;首頁&lt;/StyledLink&gt;
        &lt;StyledLink to=&quot;/new-post&quot;&gt;發布文章&lt;/StyledLink&gt;
      &lt;/NavbarList&gt;
    &lt;/LeftNavbar&gt;
    &lt;NavbarList&gt;
      &lt;StyledLink to=&quot;/login&quot;&gt;登入&lt;/StyledLink&gt;
    &lt;/NavbarList&gt;</code></pre>
<p>可參考下方範例：</p>
<iframe src="https://codesandbox.io/embed/34z5152z1q?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;"
     title="Styling React Router - NavLink using Styled-Components "
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

<h4 id="2-將-activeClassName-視為一個-props，當-NavLink-被選中時，才會加上-activeClassName-屬性："><a href="#2-將-activeClassName-視為一個-props，當-NavLink-被選中時，才會加上-activeClassName-屬性：" class="headerlink" title="2. 將 activeClassName 視為一個 props，當 NavLink 被選中時，才會加上 activeClassName 屬性："></a>2. 將 activeClassName 視為一個 props，當 NavLink 被選中時，才會加上 activeClassName 屬性：</h4><pre><code class="javascript=">const StyledLink = styled(NavLink)`

&amp;.$&#123;(props) =&gt; props.activeClassName&#125; &#123;
    background: #eee;
  &#125;
`;

export default function Header() &#123;
  return (
    &lt;HeaderContainer&gt;
      &lt;LeftNavbar&gt;
        &lt;Brand&gt;
          &lt;Link exact to=&quot;/&quot;&gt;
            React 部落格
          &lt;/Link&gt;
        &lt;/Brand&gt;
        &lt;NavbarList&gt;
          &lt;StyledLink exact to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;
            首頁
          &lt;/StyledLink&gt;
          &lt;StyledLink to=&quot;/new-post&quot; activeClassName=&quot;active&quot;&gt;
            發布文章
          &lt;/StyledLink&gt;
        &lt;/NavbarList&gt;
      &lt;/LeftNavbar&gt;
      &lt;NavbarList&gt;
        &lt;StyledLink to=&quot;/login&quot; activeClassName=&quot;active&quot;&gt;
          登入
        &lt;/StyledLink&gt;
      &lt;/NavbarList&gt;
    &lt;/HeaderContainer&gt;
  );
&#125;</code></pre>
<p>其他參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3pyOHhtMDkxMHA/ZmlsZT0vZXhhbXBsZS5qcw==">React Router - Basic<i class="fa fa-external-link-alt"></i></span>：使用 isActive 屬性來判斷要 render 哪個 component</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2VucnVvL3AvMTAzMjE0NTYuaHRtbA==">React 中 Link 和 NavLink 组件 activeClassName、activeStyle 属性不生效的问题<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="實作：文章列表頁面"><a href="#實作：文章列表頁面" class="headerlink" title="實作：文章列表頁面"></a>實作：文章列表頁面</h2><p>測試用的 API 同樣參考：Lidemy 學生專用 API Server，部落格要串接的是 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xpZGVteS9saWRlbXktc3R1ZGVudC1qc29uLWFwaS1zZXJ2ZXIjcG9zdHM=">Posts API<i class="fa fa-external-link-alt"></i></span>，資料結構如下：</p>
<p>URL：<span class="exturl" data-url="aHR0cHM6Ly9zdHVkZW50LWpzb24tYXBpLmxpZGVteS5tZS9wb3N0cz91c2VySWQ9MQ==">https://student-json-api.lidemy.me/posts?userId=1<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://i.imgur.com/B6N7n53.png"></p>
<h3 id="1-串連-API：拿取所有-posts"><a href="#1-串連-API：拿取所有-posts" class="headerlink" title="1. 串連 API：拿取所有 posts"></a>1. 串連 API：拿取所有 posts</h3><p>通常會在 src 路徑底下，新增一個 WebAPI.js 專門用來管理串連 API 相關程式碼。</p>
<p>如下方程式碼，使用 fetch 串接 API 再進行資料處理：</p>
<pre><code class="javascript=">const BASE_URL = &quot;https://student-json-api.lidemy.me&quot;;

export const getPosts = () =&gt; &#123;
  return fetch(`$&#123;BASE_URL&#125;/posts?_sort=createdAt&amp;_order=desc`).then((res) =&gt;
    res.json()
  );
&#125;;</code></pre>
<h3 id="2-顯示文章標題-amp-時間"><a href="#2-顯示文章標題-amp-時間" class="headerlink" title="2. 顯示文章標題 &amp; 時間"></a>2. 顯示文章標題 &amp; 時間</h3><p>在文章列表頁面，我們希望能夠顯示文章標題（title）和時間（createdAt）這兩個資訊：</p>
<pre><code class="javascript=">// HomePage.js

import React, &#123; useState, useEffect &#125; from &quot;react&quot;;
import styled from &quot;styled-components&quot;;
import PropTypes from &quot;prop-types&quot;;

import &#123; Link &#125; from &quot;react-router-dom&quot;;
import &#123; getPosts &#125; from &quot;../../WebAPI&quot;;

const Root = styled.div`
  max-width: 80%;
  margin: 0 auto;
`;

const PostContainer = styled.div`
  border-bottom: 1px solid rgba(0, 0, 0, 0.3);
  padding: 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const PostTitle = styled(Link)`
  font-size: 24px;
  color: #333;
  text-decoration: none;
`;

const PostDate = styled.div`
  color: rgba(0, 0, 0, 0.8);
`;

// PostList component: 顯示文章列表
function PostList(&#123; post &#125;) &#123;
  return (
    &lt;PostContainer&gt;
      &lt;PostTitle to=&#123;`/posts/$&#123;post.id&#125;`&#125;&gt;&#123;post.title&#125;&lt;/PostTitle&gt;
      &lt;PostDate&gt;&#123;new Date(post.createdAt).toLocaleDateString()&#125;&lt;/PostDate&gt;
    &lt;/PostContainer&gt;
  );
&#125;

PostList.propTypes = &#123;
  post: PropTypes.object,
&#125;;

export default function HomePage() &#123;
  const [posts, setPosts] = useState([]);

  useEffect(() =&gt; &#123;
    getPosts().then((posts) =&gt; setPosts(posts));
  &#125;, []);

  return (
    &lt;Root&gt;
      &#123;posts.map((post) =&gt; (
        &lt;PostList post=&#123;post&#125; /&gt;
      ))&#125;
    &lt;/Root&gt;
  );
&#125;
</code></pre>
<ul>
<li>轉換時間格式</li>
</ul>
<pre><code class="javascript=">new Date(post.createdAt).toLocaleDateString()</code></pre>
<ul>
<li>用 map() 處理 List 結構的資料：</li>
</ul>
<pre><code class="javascript=">  &#123;posts.map((post) =&gt; (
    &lt;Post post=&#123;post&#125; /&gt;
  ))&#125;</code></pre>
<ul>
<li>title 改用連結，引入 Link component 使用</li>
</ul>
<pre><code class="javascript=">import &#123; Link &#125; from &quot;react-router-dom&quot;;

const PostTitle = styled(Link)`
  font-size: 24px;
  color: #333;
  text-decoration: none;
`;

// ...
  // 用 to=&#123;&#125; 設定點擊導向的路由
  &lt;PostTitle to=&#123;`/posts/$&#123;post.id&#125;`&#125;&gt;&#123;post.title&#125;&lt;/PostTitle&gt;</code></pre>
<p>結果如下：</p>
<p><img src="https://i.imgur.com/dny0n1U.png"></p>
<h2 id="實作：單一文章頁面"><a href="#實作：單一文章頁面" class="headerlink" title="實作：單一文章頁面"></a>實作：單一文章頁面</h2><h3 id="1-串聯-API：根據不同-id-拿取-post"><a href="#1-串聯-API：根據不同-id-拿取-post" class="headerlink" title="1. 串聯 API：根據不同 id 拿取 post"></a>1. 串聯 API：根據不同 id 拿取 post</h3><p>接著是單一文章頁面，當我們在 Router 使用動態參數來讀取個別資料時，會需要取得 URL 上的 id 值。</p>
<p>在 WebAPI.js 中，根據路由上不同 id 來拿取相對應的 post：</p>
<pre><code class="javascript=">export const getPost = (id) =&gt; &#123;
  return fetch(`$&#123;BASE_URL&#125;/posts?id=$&#123;id&#125;`).then((res) =&gt; res.json());
&#125;;</code></pre>
<h3 id="2-useParams：抓取-URL-上的指定值"><a href="#2-useParams：抓取-URL-上的指定值" class="headerlink" title="2. useParams：抓取 URL 上的指定值"></a>2. useParams：抓取 URL 上的指定值</h3><p>透過 react-router 提供的 Hooks：<span class="exturl" data-url="aHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vd2ViL2FwaS9Ib29rcy91c2VwYXJhbXM=">useParams<i class="fa fa-external-link-alt"></i></span> 就能更方便取得 id 值，而不需再透過 <code>props.match.params</code> 抓取 URL 路由的參數值。</p>
<p>以下是官方文件提供的範例，這裡指定的值就是 <code>&#123;slug&#125;</code>：</p>
<pre><code class="javascript=">import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
import &#123;
  BrowserRouter as Router,
  Switch,
  Route,
  useParams
&#125; from &quot;react-router-dom&quot;;

function BlogPost() &#123;
  // 指定參數值
  let &#123; slug &#125; = useParams();
  return &lt;div&gt;Now showing post &#123;slug&#125;&lt;/div&gt;;
&#125;

ReactDOM.render(
  &lt;Router&gt;
    &lt;Switch&gt;
      &lt;Route exact path=&quot;/&quot;&gt;
        &lt;HomePage /&gt;
      &lt;/Route&gt;
      // 抓取 URL 上的指定參數值
      &lt;Route path=&quot;/blog/:slug&quot;&gt;
        &lt;BlogPost /&gt;
      &lt;/Route&gt;
    &lt;/Switch&gt;
  &lt;/Router&gt;,
  node
);</code></pre>
<h4 id="3-App-js-設定路由"><a href="#3-App-js-設定路由" class="headerlink" title="3. App.js 設定路由"></a>3. App.js 設定路由</h4><p>新增 PostPage 和 NewPostPage 的路由，並在 src\pages 資料夾建立 pages component 引入使用：</p>
<pre><code class="javascript=">// 統一從 pages 的 index.js 引入
import &#123;
  HomePage,
  NewPostPage,
  PostPage,
  LoginPage,
&#125; from &quot;../../pages&quot;;

// ...

  &lt;Switch&gt;
    &#123;/* exact path: 完整匹配 */&#125;
    &lt;Route exact path=&quot;/&quot;&gt;
      &lt;HomePage /&gt;
    &lt;/Route&gt;
    &lt;Route exact path=&quot;/posts/:id&quot;&gt;
      &lt;PostPage /&gt;
    &lt;/Route&gt;
    &lt;Route exact path=&quot;/new-post&quot;&gt;
      &lt;NewPostPage /&gt;
    &lt;/Route&gt;
    &lt;Route exact path=&quot;/login&quot;&gt;
      &lt;LoginPage /&gt;
    &lt;/Route&gt;
  &lt;/Switch&gt;</code></pre>
<p>稍微整理專案結構，在 <code>src\pages</code> 建立 index.js 來統一處理 pages 的引入引出動作：</p>
<pre><code class="javascript=">import HomePage from &quot;./HomePage&quot;;
import LoginPage from &quot;./LoginPage&quot;;
import PostPage from &quot;./PostPage&quot;;
import NewPostPage from &quot;./NewPostPage&quot;;

export &#123; HomePage, LoginPage, PostPage, NewPostPage &#125;;</code></pre>
<h4 id="4-實作-PostPage-js"><a href="#4-實作-PostPage-js" class="headerlink" title="4. 實作 PostPage.js"></a>4. 實作 PostPage.js</h4><pre><code class="javascript=">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;
import styled from &quot;styled-components&quot;;

import &#123; useParams &#125; from &quot;react-router-dom&quot;;
import &#123; getPost &#125; from &quot;../../WebAPI&quot;;

const PostContainer = styled.div`
  padding: 0 30px;
  max-width: 960px;
  margin: 8px auto;
`;

const PostHeader = styled.div`
  margin-bottom: 16px;
  padding: 16px 0;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
`;

const PostTitle = styled.div`
  font-size: 36px;
  font-weight: 700;
`;

const PostDate = styled.div`
  font-size: 16px;
  color: rgba(0, 0, 0, 0.4);
  margin-top: 16px;
`;

const PostBody = styled.div`
  font-size: 20px;
  letter-spacing: 3px;
  line-height: 1.5;
`;

export default function PostPage() &#123;
  const [post, setPost] = useState(null);
  const &#123; id &#125; = useParams();

  useEffect(() =&gt; &#123;
    getPost(id).then((post) =&gt; setPost(post[0]));
  &#125;, [id]);

  return (
    &lt;PostContainer&gt;
      &lt;PostHeader&gt;
        &#123;/* post &amp;&amp;: 確認陣列裡面有東西才會執行 */&#125;
        &lt;PostTitle&gt;&#123;post &amp;&amp; post.title&#125;&lt;/PostTitle&gt;
        &lt;PostDate&gt;
          &#123;post &amp;&amp; new Date(post.createdAt).toLocaleString()&#125;
        &lt;/PostDate&gt;
      &lt;/PostHeader&gt;
      &lt;PostBody&gt;&#123;post &amp;&amp; post.body&#125;&lt;/PostBody&gt;
    &lt;/PostContainer&gt;
  );
&#125;</code></pre>
<ul>
<li>用 useParams() 讀取網址列上的 id 值，並透過 useEffect 在 render 之後拿取資料，再以 setPost 來改變狀態：</li>
</ul>
<pre><code class="javascript=">  const [post, setPost] = useState(null);
  const &#123; id &#125; = useParams();

  useEffect(() =&gt; &#123;
    getPost(id).then((post) =&gt; setPost(post[0]));
  &#125;, [id]);</code></pre>
<ul>
<li>需以 <code>post &amp;&amp;</code> 確認陣列裡面有東西才會執行，以 <code>post.title</code> 為例：</li>
</ul>
<pre><code class="javascript=">&lt;PostTitle&gt;&#123;post &amp;&amp; post.title&#125;&lt;/PostTitle&gt;</code></pre>
<ul>
<li>顯示日期時間：</li>
</ul>
<pre><code class="javascript=">new Date(post.createdAt).toLocaleString()
// &quot;2020/12/12 上午10:48:39&quot;

new Date(post.createdAt).toLocaleDateString()
// &quot;2020/12/12&quot;</code></pre>
<p>結果如下：</p>
<p><img src="https://i.imgur.com/AromKKu.png"></p>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>到這邊我們已經完成專案基本架構，設定路由，以及顯示全部文章、顯示單篇文章的功能，下一篇要繼續學習如何在 React 實作登入機制。</p>
<ul>
<li>傳送門：<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWZlMzAyLXJlYWN0LWJsb2ctbG9naW4=">[week 21] React 實戰篇：用 SPA 架構實作一個部落格（二）<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 21] React Hooks API：useEffect &amp; 實作一個自己的鉤子</title>
    <url>/react-useeffect/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUzMDItcmVhY3QtaG9va3M=">[FE302] React 基礎 - hooks 版本<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<p>在 React Hooks 當中，最重要的就是 useState 和 useEffect，若能學會如何使用這兩個 hook，對於 React 應用也會更容易上手。</p>
<a id="more"></a>
<hr>
<h2 id="初探-useEffect"><a href="#初探-useEffect" class="headerlink" title="初探 useEffect"></a>初探 useEffect</h2><blockquote>
<p>詳細可參考官方文件：<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvaG9va3MtZWZmZWN0Lmh0bWw=">使用 Effect Hook<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
<p>簡單來說，就是透過 useEffect 這個 hook，告訴 React「component 在 render 之後要做的事情」。</p>
<p>有別於一般的 hook 是傳值進去，userEffect 傳入的是 function，使用方法如下：</p>
<pre><code class="javascript=">// 從 react 引入使用useEffect
import &#123; useEffect &#125; from &quot;react&quot;;

function App() &#123;
  useEffect(() =&gt; &#123;
    alert(&quot;執行完畢!&quot;);
  &#125;);
&#125;</code></pre>
<p>就會在每次畫面 render 結束後執行 useEffect 傳入的 function：</p>
<p><img src="https://i.imgur.com/QJJIuOp.png"></p>
<p>但通常我們不會想要在每次 render 後都執行 function，像是設定在某些 state 改變時才會執行。</p>
<h3 id="範例：把資料同步到-LocalStorage"><a href="#範例：把資料同步到-LocalStorage" class="headerlink" title="範例：把資料同步到 LocalStorage"></a>範例：把資料同步到 LocalStorage</h3><p>以把 todo APP 同步到 LocalStorage 這個功能為例：</p>
<pre><code class="javascript=">function writeTodosToLocalStorage(todos) &#123;
  // localStorage 只能存字串
  window.localStorage.setItem(&quot;todos&quot;, JSON.stringify(todos));
&#125;</code></pre>
<h3 id="setState-：非同步更新狀態"><a href="#setState-：非同步更新狀態" class="headerlink" title="setState()：非同步更新狀態"></a>setState()：非同步更新狀態</h3><p>此外，還有很重要的一點，就是之前實作的 setTodos() 功能其實是非同步行為。</p>
<p>如果在新增 todo 的同時進行 <code>console.log(todos)</code>，會發現畫面 render 了，todos 卻還沒有更新：</p>
<p><img src="https://i.imgur.com/ATpucjM.png"></p>
<p>因此不能直接在 function 中寫入 todos，而是要直接寫入更新過的狀態，其他功能也以此類推，在每次改變 todo 時都要執行 writeTodosToLocalStorage()：</p>
<pre><code class="javascript=">  const handleButtonClick = () =&gt; &#123;
    setTodos([
      &#123;
        id: id.current,
        content: value,
      &#125;,
      ...todos,
    ]);
    // 因為 setTodos 非同步，不能直接傳入 todos
    writeTodosToLocalStorage([
      &#123;
        id: id.current,
        content: value,
      &#125;,
      ...todos,
    ]);
    setValue(&quot;&quot;);
    id.current++;
  &#125;;</code></pre>
<p>上述這種做法，其實是我們過去利用 jQury 實作的想法，在變動資料的同時進行其他動作。</p>
<p>但其實進行新增、編輯、刪除 todo 時有個共通點，就是會「todos 會改變」，接著就是 useEffect 登場的時候了！</p>
<p>因為 useEffect() 會在每次 render 後執行，有 render 就代表 state 有變動。一旦有變動就執行同步 function，可把程式碼改寫如下：</p>
<pre><code class="javascript=">// 每次 render 後會執行 useEffect 中的 function
useEffect(() =&gt; &#123;
  writeTodosToLocalStorage(todos);
  console.log(JSON.stringify(todos));
&#125;);</code></pre>
<p>這樣就成功在每次 render 後，都把最新的 todos 狀態同步到 localStorage：</p>
<p><img src="https://i.imgur.com/UKSkzM7.png"></p>
<p>但這樣做其實有個缺點，透過執行的 console.log()，可發現連在輸入 input 時也會執行 render，應該只需要在 todos 有改變時才進行 render。</p>
<h3 id="useEffect-：可接收兩個參數"><a href="#useEffect-：可接收兩個參數" class="headerlink" title="useEffect()：可接收兩個參數"></a>useEffect()：可接收兩個參數</h3><p>而 useEffect 的第二個參數可以解決這個問題，需傳入一個陣列，用來放想要關注的資料，當變數改變時才會執行 useEffect：</p>
<pre><code class="javascript=">useEffect(() =&gt; &#123; code &#125;, [array]);
// 第一個參數：一個函式，表示要做什麼事
// 第二個參數：一個陣列，定義哪寫變數改變時，才會重新執行 useEffect</code></pre>
<p>可改寫如下，代表在 todos 改變時才會重新執行 useEffect()：</p>
<pre><code class="javascript=">useEffect(() =&gt; &#123;
writeTodosToLocalStorage(todos);
// 傳入第二個參數 [todos]
&#125;, [todos]);</code></pre>
<p>透過 localStorage 的記憶功能，我們就能在頁面第一次 render 結束後，把 localStorage 中的 todos 同步到頁面上。</p>
<h3 id="第二個參數是空陣列：不會重新執行"><a href="#第二個參數是空陣列：不會重新執行" class="headerlink" title="第二個參數是空陣列：不會重新執行"></a>第二個參數是空陣列：不會重新執行</h3><p>在第二個參數傳入空陣列，就只有第一次 render 會執行這個 useEffect，可用來進行初始化：</p>
<pre><code class="javascript=">// 進行初始化: setTodos 或是拿 API
useEffect(() =&gt; &#123;
  // 拿取資料，沒有資料的話就是空字串（進行錯誤處理）
  const todoData = window.localStorage.getItem(&quot;todos&quot;) || &quot;&quot;;
  if (todoData) &#123;
    // 把 todoData 放回 state
    setTodos(JSON.parse(todoData));
  &#125;
// 傳入空陣列: 代表只有第一次 render 才會執行這個 useEffect
&#125;, []);</code></pre>
<h3 id="useEffect-會遇到的問題"><a href="#useEffect-會遇到的問題" class="headerlink" title="useEffect 會遇到的問題"></a>useEffect 會遇到的問題</h3><p>但是在重整頁面瞬間，會發現畫面閃了一下，這是因為第一次 render 畫面顯示的是 useState 初始設定，第二次 render 才是放入 todoDate：</p>
<p><img src="https://i.imgur.com/asdZh1d.gif"></p>
<p>那麼該如何解決 useEffect 這個問題呢？接下來會繼續介紹其他功能來改善。</p>
<h2 id="useLayoutEffect：render-時同步執行"><a href="#useLayoutEffect：render-時同步執行" class="headerlink" title="useLayoutEffect：render 時同步執行"></a>useLayoutEffect：render 時同步執行</h2><p>我們在開頭提到，可透過 useEffect 這個 hook，告訴 React「component 在 render 之後要做的事情」。</p>
<p>但其實更精確的，應該是「在 render 完，瀏覽器 paint 以後要做的事情」，所以才會有 render 後畫面閃一下的情況發生。</p>
<p>而 useLayoutEffect 這個 hook，則是「在 render 完，瀏覽器 paint 以前要做的事情」。</p>
<p>也就是說，和 useEffect 功能其實很類似，差別在於同步與非同步：</p>
<ul>
<li>useEffect：非同步函式，等 UI 渲染完才會執行</li>
<li>useLayoutEffect：同步函式，UI 會等 useLayoutEffect 中做的事情結束才會渲染</li>
</ul>
<p>實際修改剛才的程式碼：</p>
<pre><code class="javascript=">// 從 react 引入 hook
import &#123; useState, useRef, useEffect, useLayoutEffect &#125; from &quot;react&quot;;

// 把讀取 todoData 的 useEffect 改用 useLayoutEffect
  useLayoutEffect(() =&gt; &#123;
    const todoData = window.localStorage.getItem(&quot;todos&quot;) || &quot;&quot;;
    if (todoData) &#123;
      setTodos(JSON.parse(todoData));
    &#125;
  &#125;, []);</code></pre>
<p>如此畫面就不會再閃一次初始的資料了：</p>
<p><img src="https://i.imgur.com/HNXymGK.gif"></p>
<p>至於為什麼會產生這個情況，可從 React 的 Hook Flow 談起。</p>
<h3 id="Hook-Flow-流程圖"><a href="#Hook-Flow-流程圖" class="headerlink" title="Hook Flow 流程圖"></a>Hook Flow 流程圖</h3><p><img src="https://i.imgur.com/usOw4li.png"><br>（圖片來源：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvbmF2b24vaG9vay1mbG93L2Jsb2IvbWFzdGVyL1JFQURNRS5tZCVFRiVCQyU4OQ==">https://github.com/donavon/hook-flow/blob/master/README.md）<i class="fa fa-external-link-alt"></i></span></p>
<p>Hook 執行流程可分為三個部分：</p>
<ul>
<li>Mount：把 component 放到畫面上</li>
<li>Update：更新 state 流程</li>
<li>Unmount：清除 effect</li>
</ul>
<p>原本是在瀏覽器 paint 之後才 run effects，若能提早改變 state 並更新畫面，就會直接顯示最新的 state，而不會出現初始 state。</p>
<p>除了透過 useLayoutEffect，還有另一種做法，同樣能解決畫面閃一下的問題，也就是接下來要介紹的 lazy initializer。</p>
<p>因為 useState 可以傳入初始值，那就直接把要更新的 todoDate 作為 state 初始值：</p>
<pre><code class="javascript=">function App() &#123;
  // 從 localStorage 拿取資料
  const todoData = window.localStorage.getItem(&quot;todos&quot;) || &quot;&quot;;
  // 直接把 todoData 設為 state 初始值，沒有資料就設為空陣列
  const [todos, setTodos] = useState(JSON.parse(todoData) || []);
  // 略</code></pre>
<p>但這麼會產生另一個問題，就是只有第一次 render 才會執行 useState 初始值，但後續 render 還是會進行撈取 todoData 的動作，又因為 useState 已經有值了，React 就會忽略裡面的東西，這其實會造成效能上的浪費。</p>
<h3 id="lazy-initializer"><a href="#lazy-initializer" class="headerlink" title="lazy initializer"></a>lazy initializer</h3><p>useState 除了設定初始值，其實可以傳入一個 function，經由 function return 的值就會是 state 的初始值：</p>
<pre><code class="javascript=">function App() &#123;
  // 在 useState 傳入 function，會把回傳值設為初始值
  const [todos, setTodos] = useState(() =&gt; &#123;
    // 用來檢測 useState 是否只執行一次
    console.log(&quot;init&quot;);
    const todoData = window.localStorage.getItem(&quot;todos&quot;) || &quot;&quot;;
    return JSON.parse(todoData) || [];
  &#125;);
// 略</code></pre>
<p>又因為初始值改變了，也要重新設定 todo id，修改後如下：</p>
<blockquote>
<ul>
<li>JSON.stringify()：將資料轉為 JSON 格式的字串</li>
<li>JSON.parse()：將資料由 JSON 格式字串轉回原本的資料型別</li>
</ul>
</blockquote>
<pre><code class="javascript=">function App() &#123;
  // 因為初始值改變了，也要重新設定 todo id
  const id = useRef(1);
  const [todos, setTodos] = useState(() =&gt; &#123;
    // 把 todos 轉回陣列型態
    let todoData = JSON.parse(window.localStorage.getItem(&quot;todos&quot;)) || &quot;&quot;;
    // 改由陣列長度判斷是否為空陣列
    if (todoData.length) &#123;
      id.current = todoData[0].id + 1;
    &#125; else &#123;
      todoData = [];
    &#125;
    // 把 return 的值設定為初始值
    return todoData;
  &#125;);</code></pre>
<p>像這樣在 useState 透過傳入 function 來設定初始值，就是 run lazy initializer 的過程。因為只有第一次會執行，適合用於一些複雜的運算，這樣 function 就只會被執行一次，避免每次 render 產生的效能問題。</p>
<h2 id="再探-useEffect：cleanup-effect"><a href="#再探-useEffect：cleanup-effect" class="headerlink" title="再探 useEffect：cleanup effect"></a>再探 useEffect：cleanup effect</h2><p>在 Hook Flow 中，有個步驟其實是先 cleanup effect，然後再 run effect，這是什麼意思呢？</p>
<p>繼續用剛才的 todos 為範例，以下程式碼代表「每當 todos 改變，就會執行 useEffect 中的 function」：</p>
<pre><code class="javascript=">  useEffect(() =&gt; &#123;
    writeTodosToLocalStorage(todos);
  &#125;, [todos]);</code></pre>
<p>但其實在這個 function 中可以 return 另一個 function，又稱為 cleanup function，代表「在這個 effect 被清掉之前要做的事情」：</p>
<pre><code class="javascript=">  useEffect(() =&gt; &#123;
    // 每當 todos 改變，effect 要做的事
    writeTodosToLocalStorage(todos);

    return () =&gt; &#123;
    // effect 被清掉前要做的事
    &#125;
  &#125;, [todos]);</code></pre>
<p>每次畫面渲染時，其實就是執行一次 APP() 這個 function，可透過這段程式碼來模擬流程：</p>
<pre><code class="javascript=">function APP() &#123;
  // ...
  useEffect(() =&gt; &#123;
    writeTodosToLocalStorage(todos);
    console.log(&quot;useEffect: todos&quot;, JSON.stringify(todos));
    // clean up
    return () =&gt; &#123;
      console.log(&quot;clearEffect: todos&quot;, JSON.stringify(todos));
    &#125;;
  &#125;, [todos]);
  // ...</code></pre>
<h4 id="1-進行第一次-render，執行-APP-，呼叫-useEffect"><a href="#1-進行第一次-render，執行-APP-，呼叫-useEffect" class="headerlink" title="1. 進行第一次 render，執行 APP()，呼叫 useEffect()"></a>1. 進行第一次 render，執行 APP()，呼叫 useEffect()</h4><pre><code class="javascript=">  useEffect(() =&gt; &#123;
    writeTodosToLocalStorage(todos);
    console.log(&quot;useEffect: todos&quot;, JSON.stringify(todos));
// useEffect: todos [&#123;&quot;id&quot;:2,&quot;content&quot;:&quot;render!&quot;&#125;]</code></pre>
<h4 id="2-點擊已完成，進行第二次-render，執行-APP-，先清除上一個-effect，再執行第二次-useEffect"><a href="#2-點擊已完成，進行第二次-render，執行-APP-，先清除上一個-effect，再執行第二次-useEffect" class="headerlink" title="2. 點擊已完成，進行第二次 render，執行 APP()，先清除上一個 effect，再執行第二次 useEffect"></a>2. 點擊已完成，進行第二次 render，執行 APP()，先清除上一個 effect，再執行第二次 useEffect</h4><pre><code class="javascript=">1. 先清除上一個 effect
// clearEffect: todos [&#123;&quot;id&quot;:2,&quot;content&quot;:&quot;render!&quot;&#125;]
2. 再進行第二次 useEffect
// useEffect: todos [&#123;&quot;id&quot;:2,&quot;content&quot;:&quot;render!&quot;,&quot;isDone&quot;:true&#125;]</code></pre>
<h3 id="cleanup-function-執行時機"><a href="#cleanup-function-執行時機" class="headerlink" title="cleanup function 執行時機"></a>cleanup function 執行時機</h3><p>結合上述範例，cleanup function 執行的時間點有兩個：</p>
<ul>
<li>要執行下一個 useEffect 的時候，要先清除上一個 effect</li>
<li>component unmount 的時候，會清除 effect</li>
</ul>
<p>那我們可以透過 useEffect 的 cleanup function 做什麼呢？例如：</p>
<ul>
<li>用來清除訂閱操作，避免記憶體洩漏，可參考<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvaG9va3MtZWZmZWN0Lmh0bWw=">官網範例<i class="fa fa-external-link-alt"></i></span></li>
<li>當 component 被 unmount 時要執行的事情</li>
</ul>
<p>以下方範例來說，代表「只有在這個 component 被 unmount 會執行 cleanup function」，又因為第二個參數是空陣列，所以這個 useEffect 只會執行一次：</p>
<pre><code class="javascript=">  useEffect(() =&gt; &#123;
    console.log(&quot;mount&quot;);
    return () =&gt; &#123;
      console.log(&quot;unmount&quot;);
    &#125;;
  &#125;, []);</code></pre>
<h2 id="實作一個自己的鉤子"><a href="#實作一個自己的鉤子" class="headerlink" title="實作一個自己的鉤子"></a>實作一個自己的鉤子</h2><p>接下來要談談 hooks 最強大的地方，就是我們其實能寫一個自己 hook，又稱作 custom hook，命名開頭必須是 use 開頭，詳細內容可參考<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvaG9va3MtY3VzdG9tLmh0bWw=">官方文件<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="實作一個-useInput"><a href="#實作一個-useInput" class="headerlink" title="實作一個 useInput"></a>實作一個 useInput</h3><p>以 input 元素為例，我們可以把 value 和 handleInputChange 等行為包在 useInput.js 檔案，寫法和之前的 APP.js 很類似：</p>
<pre><code class="javascript=">// 從 react 引入 useState
import &#123; useState &#125; from &quot;react&quot;;

// 匯出 useInput()
export default function useInput() &#123;
  const [value, setValue] = useState(&quot;&quot;);
  const handleChange = (e) =&gt; &#123;
    setValue(e.target.value);
  &#125;;
  return &#123;
    value,
    setValue,
    handleChange,
  &#125;;
&#125;</code></pre>
<p>就可以用從 useInput.js 讀取到的 handleChange，取代原本的 handleInputChange：</p>
<pre><code class="javascript=">// APP.js
import useInput from &quot;./useInput&quot;;

function APP &#123;
  // ...
  // 從 useInput 讀取 value 資料
  const &#123; value, setValue, handleChange &#125; = useInput();
  // ...
  return (
  &lt;div className=&quot;App&quot;&gt;
    &lt;input
      type=&quot;text&quot;
      placeholder=&quot;Add todo...&quot;
      value=&#123;value&#125;
      // 改為 handleChange
      onChange=&#123;handleChange&#125;
      onKeyDown=&#123;handleKeyDown&#125;
    /&gt;</code></pre>
<p>修改完程式也能正常運行，這樣寫的好處就是，如果有第二個 input 時，也能使用共通的邏輯，例如：</p>
<pre><code class="javascript=">// 第一個 input
const &#123; value, setValue, handleChange &#125; = useInput();
// 第二個 input
const &#123; value: todoName, setValue:setTodoName , handleChange: handleTodoName &#125; = useInput();</code></pre>
<h3 id="實作一個-useTodos"><a href="#實作一個-useTodos" class="headerlink" title="實作一個 useTodos"></a>實作一個 useTodos</h3><p>我們也可以把 todos 的邏輯獨立成一個 hook，也就是 useTodos.js：</p>
<pre><code class="javascript=">// useTodo.js
import &#123; useState, useEffect, useRef &#125; from &quot;react&quot;;

function writeTodosToLocalStorage(todos) &#123;
  window.localStorage.setItem(&quot;todos&quot;, JSON.stringify(todos));
&#125;

export default function useTodos() &#123;
  const id = useRef(1);
  const [todos, setTodos] = useState(() =&gt; &#123;
    // 把 todos 轉回陣列型態
    let todoData = JSON.parse(window.localStorage.getItem(&quot;todos&quot;)) || &quot;&quot;;
    // 改由陣列長度判斷是否為空陣列
    if (todoData.length) &#123;
      id.current = todoData[0].id + 1;
    &#125; else &#123;
      todoData = [];
    &#125;
    return todoData;
  &#125;);

  useEffect(() =&gt; &#123;
    writeTodosToLocalStorage(todos);
  &#125;, [todos]);

  return &#123;
    todos,
    setTodos,
    id,
  &#125;;
&#125;</code></pre>
<p>並引入 APP.js 使用：</p>
<pre><code class="javascript=">import useInput from &quot;./useInput&quot;;
import useTodos from &quot;./useTodos&quot;;

function App() &#123;
  // 從 useTodos 讀取 todos 資料
  const &#123; todos, setTodos, id &#125; = useTodos();
  // 從 useInput 讀取 value 資料
  const &#123; value, setValue, handleChange &#125; = useInput();
  // ...</code></pre>
<h3 id="將-UI-與邏輯分開寫"><a href="#將-UI-與邏輯分開寫" class="headerlink" title="將 UI 與邏輯分開寫"></a>將 UI 與邏輯分開寫</h3><p>若再繼續細分功能，甚至可以做到把 UI 和 todos 邏輯完全分開，改寫如下：</p>
<ul>
<li>App.js</li>
</ul>
<pre><code class="javascript=">import TodoItem from &quot;./TodoItem&quot;;
import useTodos from &quot;./useTodos&quot;;

function App() &#123;
  // 從 useTodos 讀取 todos 資料
  const &#123;
    todos,
    setTodos,
    id,
    handleButtonClick,
    handleKeyDown,
    handleTogglerIsDone,
    handleDeleteTodo,
    value,
    setValue,
    handleChange,
  &#125; = useTodos();

  // 剩下 UI 畫面
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;input
        type=&quot;text&quot;
        placeholder=&quot;Add todo...&quot;
        value=&#123;value&#125;
        onChange=&#123;handleChange&#125;
        onKeyDown=&#123;handleKeyDown&#125;
      /&gt;
      &lt;button onClick=&#123;handleButtonClick&#125;&gt;Add Todo&lt;/button&gt;
      &#123;todos.map((todo) =&gt; (
        &lt;TodoItem
          key=&#123;todo.id&#125;
          todo=&#123;todo&#125;
          handleDeleteTodo=&#123;handleDeleteTodo&#125;
          handleTogglerIsDone=&#123;handleTogglerIsDone&#125;
        /&gt;
      ))&#125;
    &lt;/div&gt;
  );
&#125;

export default App;</code></pre>
<ul>
<li>useTodo.js</li>
</ul>
<pre><code class="javascript=">import &#123; useState, useEffect, useRef &#125; from &quot;react&quot;;
import useInput from &quot;./useInput&quot;;

function writeTodosToLocalStorage(todos) &#123;
  window.localStorage.setItem(&quot;todos&quot;, JSON.stringify(todos));
&#125;

export default function useTodos() &#123;
  const id = useRef(1);
  // 從 useInput 讀取 value 資料
  const &#123; value, setValue, handleChange &#125; = useInput();
  const [todos, setTodos] = useState(() =&gt; &#123;
    let todoData = JSON.parse(window.localStorage.getItem(&quot;todos&quot;)) || &quot;&quot;;
    if (todoData.length) &#123;
      id.current = todoData[0].id + 1;
    &#125; else &#123;
      todoData = [];
    &#125;
    return todoData;
  &#125;);

  // 點擊按鈕新增 todo
  const handleButtonClick = () =&gt; &#123;
    addTodo();
  &#125;;
  // enter 新增 todo
  const handleKeyDown = (e) =&gt; &#123;
    if (e.keyCode !== 13) return;
    addTodo();
  &#125;;

  const addTodo = () =&gt; &#123;
    // 檢查輸入欄位是否為空值，trim() 可清除字串前後空白
    if (value.trim().length === 0) return;
    setTodos([
      &#123;
        id: id.current,
        content: value,
      &#125;,
      ...todos,
    ]);
    setValue(&quot;&quot;);
    id.current++;
  &#125;;

  const handleTogglerIsDone = (id) =&gt; &#123;
    setTodos(
      todos.map((todo) =&gt; &#123;
        if (todo.id !== id) return todo;
        return &#123;
          ...todo,
          isDone: !todo.isDone,
        &#125;;
      &#125;)
    );
  &#125;;

  const handleDeleteTodo = (id) =&gt; &#123;
    setTodos(todos.filter((todo) =&gt; todo.id !== id));
  &#125;;

  useEffect(() =&gt; &#123;
    writeTodosToLocalStorage(todos);
  &#125;, [todos]);

  return &#123;
    todos,
    setTodos,
    id,
    handleButtonClick,
    handleKeyDown,
    handleTogglerIsDone,
    handleDeleteTodo,
    value,
    setValue,
    handleChange,
  &#125;;
&#125;</code></pre>
<p>其實和之前寫前後端分離的時候很類似，寫成自訂 hook 的過程，就像是把不同邏輯的 function 給模組化，這麼說似乎也沒錯，畢竟 hook 就是 fucntion。</p>
<p>透過抽出共同邏輯的方式，可將功能包裝在 hooks，就算是在不同 UI，也同樣能利用 return 的值，在畫面上呈現想要的資料。</p>
<h2 id="hooks-觀念總結"><a href="#hooks-觀念總結" class="headerlink" title="hooks 觀念總結"></a>hooks 觀念總結</h2><p>hooks 基本上可以分成下列幾種：</p>
<ul>
<li>內建 hooks<ul>
<li>useState：讓 function component 擁有 state，可以管理內部狀態</li>
<li>useEffect：在 render 完、瀏覽器 paint 畫面之後要做什麼事</li>
<li>useLayoutEffect：在 render 完、瀏覽器 paint 畫面之前要做什麼事</li>
</ul>
</li>
<li>自訂 hooks：把邏輯從 UI 抽出來寫一個 hook</li>
<li>參考別人寫好的 hooks：<span class="exturl" data-url="aHR0cHM6Ly91c2Vob29rcy5jb20v">useHooks<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="補充資料"><a href="#補充資料" class="headerlink" title="補充資料"></a>補充資料</h2><p>推薦閱讀 Dan Abramov 所撰寫有關 React 的系列文章，裡面對於 useEffect 的原理有更詳細敘述：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb211cy5kZXYvemgtaGFudC9hLWNvbXBsZXRlLWd1aWRlLXRvLXVzZWVmZmVjdC8=">A Complete Guide to useEffect<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb211cy5kZXYvemgtaGFucy9ob3ctYXJlLWZ1bmN0aW9uLWNvbXBvbmVudHMtZGlmZmVyZW50LWZyb20tY2xhc3Nlcy8=">How Are Function Components Different from Classes?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>第 11 屆 iT 邦幫忙鐵人賽有關 React 的系列文章：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy91c2Vycy8yMDEwMzMxNS9pcm9ubWFuLzI2Njg=">從 Hooks 開始，讓你的網頁 React 起來<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDI1MjExOA==">【Day.26】React進階 - useEffect v.s useLayoutEffect<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb211cy5kZXYv">Overreacted - Dan Abramov.<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wamNoZW5kZXIuZ2l0aHViLmlvLzIwMTkvMDgvMDcvcmVhY3Rkb2MtcmVhY3QtaG9va3MtdXNlZWZmZWN0Lw==">[ReactDoc] React Hooks - useEffect<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 21] React Hooks API：useState &amp; 再戰 Todo List</title>
    <url>/react-usestate/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvZmUzMDItcmVhY3QtaG9va3M=">[FE302] React 基礎 - hooks 版本<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<pre><code>學習目標：

 P1 我知道 React 的目的以及原理
 P1 我知道我們為什麼需要 React
 P1 我知道使用 React 跟之前使用 jQuery 的區別
 P1 我理解 state 跟 props 的不同</code></pre>
<a id="more"></a>
<hr>
<h2 id="React-Hooks-API"><a href="#React-Hooks-API" class="headerlink" title="React Hooks API"></a>React Hooks API</h2><p>根據<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvaG9va3MtaW50cm8uaHRtbD9uby1jYWNoZT0x">官網介紹<i class="fa fa-external-link-alt"></i></span>：</p>
<blockquote>
<p>Hook 是 React 16.8 中增加的新功能。它讓你不必寫 class 就能使用 state 以及其他 React 的功能。</p>
</blockquote>
<p>先前提到，React 的核心概念之一是 component，而根據寫法又可分為兩種：</p>
<ul>
<li>class compent：透過 class 寫成，可以控制 state 和生命週期</li>
<li>function compent：透過 function 寫成，主要用來呈現 UI</li>
</ul>
<h3 id="hook-其實就是-function"><a href="#hook-其實就是-function" class="headerlink" title="hook 其實就是 function"></a>hook 其實就是 function</h3><p>根據<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvaG9va3Mtb3ZlcnZpZXcuaHRtbA==">官方文件<i class="fa fa-external-link-alt"></i></span>：</p>
<blockquote>
<p>hook 是 function，讓我們可以從 function component「hook into」React state 與生命週期功能。</p>
</blockquote>
<p>也就是說，React 因為加入了 hooks，再結合 props、state、context、refs 以及 lifecycle 等概念，提供了更直接的 API 使用，讓我們能在 functional component 管理狀態和使用生命周期等功能，藉此簡化程式碼與提高重用性。</p>
<p>引入 hook 的語法如下，原本要寫成 React.useState，透過 ES6 解構語法即可直接使用 useState：</p>
<pre><code class="javascript=">import &#123; useState, useEffect, useRef &#125; from &#39;react&#39;; </code></pre>
<h3 id="hooks-只能寫在-component-第一層"><a href="#hooks-只能寫在-component-第一層" class="headerlink" title="hooks 只能寫在 component 第一層"></a>hooks 只能寫在 component 第一層</h3><p>因為 React 背後的機制，hooks 只能寫在 component 第一層。</p>
<p>也就是說，不能把 hooks 寫在 if - else 等條件判斷句裡面，像是符合 XX 條件才使用，否則會出現錯誤訊息：</p>
<blockquote>
<p>React Hook “useRef” is called conditionally. React Hooks must be called in the exact same order in every component render    react-hooks/rules-of-hooks</p>
</blockquote>
<p>只能自行在 hooks 裡面進行判斷是否使用，例如下方寫法：</p>
<pre><code class="javascript=">useEffect(() =&gt; &#123;
  // 若不符合就直接 return
  if (!todos) return;
  // 若符合要做的事情
&#125;)</code></pre>
<h3 id="useState：用來設定-react-中的-state"><a href="#useState：用來設定-react-中的-state" class="headerlink" title="useState：用來設定 react 中的 state"></a>useState：用來設定 react 中的 state</h3><p>語法如下：</p>
<pre><code class="javascript=">const [currentValue, setCurrentValue] = useState(initialValue);</code></pre>
<ul>
<li>currentValue：存放 state 的值</li>
<li>setCurrentValue：用來設定 state 值</li>
<li>initialValue：state 的初始值</li>
</ul>
<p>還記得我們前面舉的 Counter component 範例嗎？簡單來說，就是在 <code>useState([初始值])</code> 傳入初始值，然後回傳一個陣列：</p>
<pre><code class="javascript=">function App()&#123;
const [todos, setTodos] = useState([1])
&#125;</code></pre>
<p>其中 todos 具有 immutable 特性，也就是無法再賦值，必須用 setTodos 來產生新的 state，才能在每次 render 畫面時改變 todos 的值。</p>
<p>透過這個概念，我們也能實作出簡單的 Todo List：</p>
<pre><code class="javascript=">// 解構語法
import &#123; useState &#125; from &#39;react&#39;;

function App() &#123;
  const [todos, setTodos] = useState([
    1
  ]);

  const handleButtonClick = () =&gt; &#123;
    // 傳入參數: 新的 todo + 解構 todos
    setTodos([&quot;new todo&quot;, ...todos]);
  &#125;

  return (
    &lt;div className=&quot;App&quot;&gt;
      /* 在 JSX 中，單標籤必須 /&gt; 結尾 */
      &lt;input type=&quot;text&quot; placeholder=&quot;Add todo...&quot; /&gt;
      &lt;button onClick=&#123;handleButtonClick&#125;&gt;Add Todo&lt;/button&gt;
      &#123;
        todos.map((todo, index) =&gt; &lt;TodoItem key=&#123;index&#125; content=&#123;todo&#125; /&gt; ) 
      &#125;
    &lt;/div&gt;
  );
&#125;</code></pre>
<p><img src="https://i.imgur.com/f6EsvhC.png"></p>
<h3 id="controlled-vs-uncontrolled"><a href="#controlled-vs-uncontrolled" class="headerlink" title="controlled vs uncontrolled"></a>controlled vs uncontrolled</h3><blockquote>
<p>詳細可參考<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvZm9ybXMuaHRtbCNjb250cm9sbGVkLWNvbXBvbmVudHM=">官方文件<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
<p>在 React 中，表單元素的處理可分為 uncontrolled 和 controlled，兩者之間的差別，在於 component 的資料是否受到 React 的控制：</p>
<ul>
<li>uncontrolled component：資料不受 React 的控制<ul>
<li>例如 input、textarea 等表單元素，通常會維持本身的 state，並根據使用者的輸入來更新該元素的 state</li>
<li>若想取得 uncontrolled component 的值，可透過直接操作 DOM 或使用 useRef 來選取特定元素</li>
</ul>
</li>
<li>controlled component：資料受到 React 的控制 <ul>
<li>如果將資料的控制權交給 React 來處理，畫面就會根據 state 是否改變來重新渲染</li>
</ul>
</li>
</ul>
<p>參考文章：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIyNzg2Ng==">[Day 27 - 即時天氣] React 中的表單處理（Controlled vs Uncontrolled）以及 useRef 的使用<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<hr>
<h2 id="再戰-Todo-List"><a href="#再戰-Todo-List" class="headerlink" title="再戰 Todo List"></a>再戰 Todo List</h2><h3 id="新增-Todo"><a href="#新增-Todo" class="headerlink" title="新增 Todo"></a>新增 Todo</h3><p>透過下方程式碼，可存取 input 的值，並藉由 setValue 來更新 todos 狀態：</p>
<pre><code class="javascript=">import TodoItem from &#39;./TodoItem&#39;
// 解構語法
import &#123; useState, useRef &#125; from &#39;react&#39;;

function App() &#123;
  const [todos, setTodos] = useState([
    1
  ]);

  const [value, setValue] = useState(&#39;&#39;);

  const handleButtonClick = () =&gt; &#123;
    // 傳入參數: 新的 todo + 解構 todos
    setTodos([value, ...todos]);
    // 新增完 todo 後清空 value
    setValue(&#39;&#39;);
  &#125;

  const handleInputChange = (e) =&gt; &#123;
    // 拿到 input 的 value
    setValue(e.target.value);
  &#125;

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;Add todo...&quot; value=&#123;value&#125; onChange=&#123;handleInputChange&#125; /&gt;
      &lt;button onClick=&#123;handleButtonClick&#125;&gt;Add Todo&lt;/button&gt;
      &#123;
        todos.map((todo, index) =&gt; &lt;TodoItem key=&#123;index&#125; content=&#123;todo&#125; /&gt; ) 
      &#125;
    &lt;/div&gt;
  );
&#125;</code></pre>
<p><img src="https://i.imgur.com/EAY1tzO.png"></p>
<h3 id="useRef：用來抓取-DOM-節點的-hook"><a href="#useRef：用來抓取-DOM-節點的-hook" class="headerlink" title="useRef：用來抓取 DOM 節點的 hook"></a>useRef：用來抓取 DOM 節點的 hook</h3><p>基本用法：</p>
<pre><code class="javascript=">const refContainer = useRef(initialValue);</code></pre>
<p>根據<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW50LnJlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlcmVm">官方文件<i class="fa fa-external-link-alt"></i></span>介紹：</p>
<blockquote>
<p>useRef 回傳一個可變的 ref object，其 .current 屬性被初始為傳入的參數（initialValue）。回傳的 object 在 component 的生命週期將保持不變。</p>
</blockquote>
<p>簡單來說，useRef 是可持有 mutable（可變的）值、具有 .current 屬性的「盒子」，並具有以下特性：</p>
<ul>
<li>當 .current 屬性有變動時不會觸發重新 render</li>
<li>在每次 render 時都會給同一個的 ref object</li>
</ul>
<p>我們可透過宣告 <code>id = useRef(2)</code>，就能夠在每次 render 時，更改每個 todo 中 id.current 的值：</p>
<pre><code class="javascript=">function App() &#123;
  const [todos, setTodos] = useState([
    &#123;id: 1, content: &#39;todo1&#39;&#125;
  ]);

  const [value, setValue] = useState(&#39;&#39;);
  // useRef: 能我們抓取到 DOM 節點的 hooks
  // 會回傳一個物件，要以 id.current 讀取
  const id = useRef(2);

  const handleButtonClick = () =&gt; &#123;
    setTodos([
      &#123;
        id: id.current,
        content: value
      &#125;, ...todos]
    );
    setValue(&#39;&#39;);
    id.current++;
  &#125;

  const handleInputChange = (e) =&gt; &#123;
    setValue(e.target.value);
  &#125;

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;Add todo...&quot; value=&#123;value&#125; onChange=&#123;handleInputChange&#125; /&gt;
      &lt;button onClick=&#123;handleButtonClick&#125;&gt;Add Todo&lt;/button&gt;
      &#123;
        todos.map(todo =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; /&gt; ) 
      &#125;
    &lt;/div&gt;
  );</code></pre>
<p>傳入 todo 這個參數，並放到 TodoItem：</p>
<pre><code class="javascript=">export default function TodoItem(&#123; content, todo &#125;) &#123;
  return (
    &lt;TodoItemWrapper data-todo-id=&#123;todo.id&#125;&gt;
      &lt;TodoContent&gt;&#123;todo.content&#125;&lt;/TodoContent&gt;
      &lt;TodoButtonWrapper&gt;
        &lt;Button&gt;未完成&lt;/Button&gt;
        &lt;RedButton&gt;刪除&lt;/RedButton&gt;
      &lt;/TodoButtonWrapper&gt;
    &lt;/TodoItemWrapper&gt;
  );
&#125;

===上方寫法等同於===

function TodoItem() &#123;
  // ...
&#125;
export default TodoItem;</code></pre>
<h3 id="刪除-todo"><a href="#刪除-todo" class="headerlink" title="刪除 todo"></a>刪除 todo</h3><h4 id="1-把要做的-function-寫在-Parent，並傳入參數給-Children"><a href="#1-把要做的-function-寫在-Parent，並傳入參數給-Children" class="headerlink" title="1. 把要做的 function 寫在 Parent，並傳入參數給 Children"></a>1. 把要做的 function 寫在 Parent，並傳入參數給 Children</h4><p>把 handleDeleteTodo 這個 function 當作 props 傳給 TodoItem：</p>
<pre><code class="javascript=">  const handleDeleteTodo = id =&gt; &#123;

  &#125;

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;Add todo...&quot; value=&#123;value&#125; onChange=&#123;handleInputChange&#125; /&gt;
      &lt;button onClick=&#123;handleButtonClick&#125;&gt;Add Todo&lt;/button&gt;
      &#123;
        todos.map(todo =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; handleDeleteTodo=&#123;handleDeleteTodo&#125; /&gt; ) 
      &#125;
    &lt;/div&gt;
  );</code></pre>
<h4 id="2-再由-Children-呼叫-function"><a href="#2-再由-Children-呼叫-function" class="headerlink" title="2. 再由 Children 呼叫 function"></a>2. 再由 Children 呼叫 function</h4><p>TodoItem 就可以接收這個 funtcion，並透過刪除按鈕的監聽事件，來呼叫 handleDeleteTodo 以及回傳該 <code>todo.id</code>：</p>
<pre><code class="javascript=">export default function TodoItem(&#123; content, todo, handleDeleteTodo &#125;) &#123;
  return (
    &lt;TodoItemWrapper data-todo-id=&#123;todo.id&#125;&gt;
      &lt;TodoContent&gt;&#123;todo.content&#125;&lt;/TodoContent&gt;
      &lt;TodoButtonWrapper&gt;
        &lt;Button&gt;未完成&lt;/Button&gt;
        &lt;RedButton onClick=&#123;() =&gt; &#123;
          handleDeleteTodo(todo.id)
        &#125;&#125;&gt;刪除&lt;/RedButton&gt;
      &lt;/TodoButtonWrapper&gt;
    &lt;/TodoItemWrapper&gt;
  );
&#125;</code></pre>
<h4 id="3-接著在-Parent-處理-function"><a href="#3-接著在-Parent-處理-function" class="headerlink" title="3. 接著在 Parent 處理 function"></a>3. 接著在 Parent 處理 function</h4><pre><code class="javascript=">  const handleDeleteTodo = id =&gt; &#123;
    // 若用 splice() 會改到原本的 todo，因此要用 filter()，留下該 id 以外的 todo
    setTodos(todos.filter(todo =&gt; todo.id !== id))
  &#125;</code></pre>
<h3 id="編輯-todo"><a href="#編輯-todo" class="headerlink" title="編輯 todo"></a>編輯 todo</h3><p>在實作編輯 todo 之前，要先來檢視資料結構，也就是把 todo 的狀態加上 isDone，用來判斷是否已完成：</p>
<pre><code class="javascript=">function App() &#123;
  const [todos, setTodos] = useState([
    &#123; id: 1, content: &#39;done&#39;, isDone: true &#125;,
    &#123; id: 2, content: &#39;not done&#39;, isDone: false &#125;
  ]);

  const [value, setValue] = useState(&#39;&#39;);
  const id = useRef(3);</code></pre>
<p>接著在 TodoItem 的按鈕加上三元運算子，用來判斷 todo 狀態，再藉由 $isDone 這個參數，判斷式是否執行後面的 JSX 語法：</p>
<pre><code class="javascript=">const TodoContent = styled.div`
  font-size: 26px;
  color: $&#123;props =&gt; props.theme.colors.primary_300&#125;;

  // 若 isDone 這個參數為 true(已完成) 則接續後面的 JSX 語法
  $&#123;props =&gt; props.$isDone &amp;&amp; `
    text-decoration: line-through;
  `&#125;
`

export default function TodoItem(&#123; content, todo, handleDeleteTodo &#125;) &#123;
  return (
    &lt;TodoItemWrapper data-todo-id=&#123;todo.id&#125;&gt;
      // 傳入 isDone 這個參數
      &lt;TodoContent $isDone=&#123;todo.isDone&#125;&gt;&#123;todo.content&#125;&lt;/TodoContent&gt;
      &lt;TodoButtonWrapper&gt;
        &lt;Button&gt;
          // 透過三元運算子判斷 todo 狀態
          &#123;todo.isDone ? &#39;已完成&#39; : &#39;未完成&#39;&#125;
        &lt;/Button&gt;
        &lt;RedButton onClick=&#123;() =&gt; &#123;
          handleDeleteTodo(todo.id)
        &#125;&#125;&gt;刪除&lt;/RedButton&gt;
      &lt;/TodoButtonWrapper&gt;
    &lt;/TodoItemWrapper&gt;
  );
&#125;</code></pre>
<p>除了三元運算子，也可改寫成邏輯運算子 &amp;&amp; 的寫法，適用於多種可能的情況：</p>
<pre><code class="javascript=">  &lt;Button onClick=&#123;handleToggleClick&#125;&gt;
    &#123;todo.isDone &amp;&amp; &#39;已完成&#39;&#125;
    &#123;!todo.isDone &amp;&amp; &#39;未完成&#39;&#125;
  &lt;/Button&gt;</code></pre>
<p>接著實作 handleToggleIsDone 修改 todo 功能：</p>
<pre><code class="javascript=">  const handleToggleIsDone = id =&gt; &#123;
    setTodos(todos.map(todo =&gt; &#123;
      // 如果不是要修改的 todo id 就直接回傳
      if (todo.id !== id) return todo;
      // 要修改的 todo id
      return &#123;
        // todo 原本的東西
        ...todo,
        // 要修改的屬性
        isDone: !todo.isDone
      &#125;
    &#125;));
  &#125;</code></pre>
<p>傳入參數到 TodoItem：</p>
<pre><code class="javascript=">  &#123;
    todos.map(todo =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; handleDeleteTodo=&#123;handleDeleteTodo&#125; handleToggleIsDone=&#123;handleToggleIsDone&#125;/&gt; ) 
  &#125;</code></pre>
<p>由 TodoItem 接收參數，可以把 click 事件抽出來寫，相較於原本的 inline function，能夠提高程式碼的可讀性：</p>
<pre><code class="javascript=">export default function TodoItem(&#123; todo, handleDeleteTodo, handleToggleIsDone &#125;) &#123;
  const handleToggleClick = () =&gt; &#123;
    handleToggleIsDone(todo.id);
  &#125;

  const handleDeleteClick = () =&gt; &#123;
    handleDeleteTodo(todo.id);
  &#125;

  return (
    &lt;TodoItemWrapper data-todo-id=&#123;todo.id&#125;&gt;
      &lt;TodoContent $isDone=&#123;todo.isDone&#125;&gt;&#123;todo.content&#125;&lt;/TodoContent&gt;
      &lt;TodoButtonWrapper&gt;
        &lt;Button onClick=&#123;handleToggleClick&#125;&gt;
          &#123;todo.isDone ? &#39;已完成&#39; : &#39;未完成&#39;&#125;
        &lt;/Button&gt;
        &lt;RedButton onClick=&#123;handleDeleteClick&#125;&gt;刪除&lt;/RedButton&gt;
      &lt;/TodoButtonWrapper&gt;
    &lt;/TodoItemWrapper&gt;
  );
&#125;</code></pre>
<h3 id="Transient-props：-lt-props-gt"><a href="#Transient-props：-lt-props-gt" class="headerlink" title="Transient props：$&lt;props&gt;"></a>Transient props：<code>$&lt;props&gt;</code></h3><p>在上方程式碼中，加在 TodoContent 的 $isDone 這個 props，會被視為 style component props，不會被繼續傳到下一個 DOM 元素，也就不會顯示在 TodoContent 標籤上。</p>
<p>如果沒有加上 $ 符號，這個 props 就會被直接加在 TodoContent 這個 DOM 結構上。</p>
<p>再以下方程式碼為例：</p>
<pre><code class="javascript=">&lt;TodoContent id=&quot;abc&quot; $isDone=&#123;todo.isDone&#125;&gt;&#123;todo.content&#125;&lt;/TodoContent&gt;</code></pre>
<p>可以發現經過 render 之後，在 DOM 元素只會出現 <code>id=&quot;abc&quot;</code> 這個屬性，而不會有 <code>$isDone</code>，這是因為 Transient props 不會被往下傳：</p>
<p><img src="https://i.imgur.com/K4ROwak.png"></p>
<h2 id="Todo-List-總結"><a href="#Todo-List-總結" class="headerlink" title="Todo List 總結"></a>Todo List 總結</h2><p>透過實作簡單的 Todo List，其實我們就差不多學會了有關 React 的基礎：</p>
<ol>
<li>Component 組件</li>
</ol>
<p>開發 React 很重要的一點，就是去思考在頁面有哪些重複性高或相似的 Element，再透過 JSX 將這些 Element 建立成一個 Components，讓每個 Components 擁有重複性及可擴充性。</p>
<ol start="2">
<li>Props 參數</li>
</ol>
<p>Props 主要提供值給 Component，用來設定屬性或資料，因此就算是同一個組件，也會根據提供的 Props 而有所不同。</p>
<ol start="3">
<li>Style 樣式</li>
</ol>
<p>可透過幾種方式撰寫 React 中的 CSS，目前主流方法是透過 styled-components 這個套件來撰寫 CSS 語法。</p>
<ol start="4">
<li>Event handler 事件機制</li>
</ol>
<p>和過去在網頁添加事件監聽不同，必須先以 <code>querySelector()</code> 選取 DOM 元素：</p>
<pre><code class="javascript=">function sayHello() &#123;
  alert(&#39;Hello!&#39;);
&#125;
document.querySelector(&#39;.sayHello&#39;).addEventListener(&#39;click&#39;, sayHello);</code></pre>
<p>而 React 把 DOM 和 JavaScript 程式碼寫在一起，因此可直接在 DOM 元素加上 onClick、onSubmit、onKeyDown 等事件監聽：</p>
<pre><code class="javascript=">function TodoItem(&#123; todo, handleDeleteTodo &#125;) &#123;
  const handleDeleteClick = () =&gt; &#123;
    handleDeleteTodo(todo.id);
  &#125;
  return (
    &lt;RedButton onClick=&#123;handleDeleteClick&#125;&gt;刪除&lt;/RedButton&gt;
  );
&#125;

      /* 也可簡化成箭頭函式 */

function TodoItem(&#123; todo, handleDeleteTodo &#125;) &#123;
  return (
    &lt;RedButton onClick=&#123;() =&gt; &#123;
      handleDeleteTodo(todo.id)
    &#125;&#125;&gt;刪除&lt;/RedButton&gt;
  );
&#125;</code></pre>
<ol start="5">
<li>JSX 語法</li>
</ol>
<p>透過 JSX 語法，即可將 HTML 語法轉成 JavaScript 的形式，讓我們用來建立 React elements。</p>
<p>使用 JSX 時需注意下列幾點：</p>
<ul>
<li>class 是保留字，必須改寫成 className</li>
<li>可在大括號內寫程式碼，例如：<code>&#123; JS code &#125;</code>，也因此 inline-style 需改為駝峰式命名</li>
<li>沒有迴圈的概念，也沒有 if-else 判斷式<ul>
<li>解決方法：透過三元運算子，或是邏輯運算子 &amp;&amp; 進行判斷</li>
</ul>
</li>
</ul>
<p>此外，當我們要 render 一系列 list 的時候，會使用 <code>map()</code> 把資料變成一個陣列，然後 render 需要提供 key：</p>
<pre><code class="javascript=">&#123;
   todos.map(todo =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; /&gt; ) 
&#125;</code></pre>
<ol start="6">
<li>State 狀態</li>
</ol>
<p>是 React 中最重要的觀念，可透過 useState 設定 state 初始值，再以 setState 去改變 state。state 會對應到一個 UI，一旦 state 有變動，就會自動呼叫 render()。</p>
<p>state 最基本的語法如下：</p>
<pre><code class="javascript=">const [currentValue, setCurrentValue] = useState(initialValue);</code></pre>
<p>在 React 當中，若要進行新增、編輯、刪除功能，雖然有許多方法能夠達成，但基本上有固定的作法：</p>
<ul>
<li>新增功能：解構語法</li>
</ul>
<pre><code class="javascript=">  const handleButtonClick = () =&gt; &#123;
    setTodos([
      &#123;
        // 要新增的 todo
        id: id.current,
        content: value
        // 解構語法
      &#125;, ...todos]
    );
    setValue(&#39;&#39;);
    id.current++;
  &#125;</code></pre>
<ul>
<li>編輯功能：map()</li>
</ul>
<pre><code class="javascript=">  const handleToggleIsDone = id =&gt; &#123;
    setTodos(todos.map(todo =&gt; &#123;
      // 如果不是要修改的 todo id 就直接回傳
      if (todo.id !== id) return todo;
      // 要修改的 todo id
      return &#123;
        // todo 原本的東西
        ...todo,
        // 要修改的屬性
        isDone: !todo.isDone
      &#125;
    &#125;));
  &#125;</code></pre>
<ul>
<li>刪除功能：filter()</li>
</ul>
<pre><code class="javascript=">  const handleDeleteTodo = id =&gt; &#123;
    // 留下該 id 以外的 todo
    setTodos(todos.filter(todo =&gt; todo.id !== id))
  &#125;</code></pre>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><hr>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>這和以往的思考模式其實很不一樣，像是在切好的 UI 畫面上新增各種功能；而 React 則是先思考 state 狀態，再去想會如何改變畫面。</p>
<p>記住一個重點，就是 Component 之間可透過 props 把 state 傳遞下去。並且，只要 state 所有變動，就會觸發 render() 來更新 UI 畫面。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9zbmg5MDEwMC5tZWRpdW0uY29tLyVFNSVCOCVCOCVFOCVBNiU4QiVFNyU5QSU4NCVFNSVCOSVCRSVFNSU4MCU4Qi1yZWFjdC1ob29rcy0lRTQlQkIlOEIlRTclQjQlQjktdXNlc3RhdGUtdXNlZWZmZWN0LXVzZXJlZi00MGM5YWNkMGNjNGM=">常見的幾個 React hooks 教學-useState、useEffect、useRef<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRlY2hicmlkZ2UuY2MvMjAxOC8wMS8wNS9yZWFjdC1yZW5kZXItb3B0aW1pemF0aW9uLw==">React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 17] 後端中階 - 淺談 Sequelize：使用 ORM 框架串接資料庫</title>
    <url>/sequelize-orm/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvYmUyMDEtZXhwcmVzcy1zZXF1ZWxpemU=">[BE201] 後端中階：Express 與 Sequelize<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<p>瞭解如何使用 Express 這套 Web 應用框架之後，再來要介紹新的工具：Sequelize，這是一款基於 Node.js 的非同步 ORM 框架，讓我們能透過 ORM（物件關聯對映）來開發網頁，以物件導向的概念來操作資料庫。</p>
<a id="more"></a>

<pre><code>學習目標：

 P1 了解什麼是 ORM
 P1 了解 ORM 的優缺點
 P1 了解什麼是 N+1 problem
 P1 我知道如何部署 Node.js 應用程式到 heroku</code></pre>
<hr>
<h2 id="什麼是-ORM？"><a href="#什麼是-ORM？" class="headerlink" title="什麼是 ORM？"></a>什麼是 ORM？</h2><p>前面我們提到 Sequelize 是一款 ORM 框架，那什麼是 ORM？</p>
<p>ORM（Object Relational Mapping），中文為物件關聯對映。是一種將關聯式資料庫（MySQL）映射（mapping）至物件導向（OOP）的資料抽象化技術。</p>
<p>簡單來說，在網站開發 MVC 結構中，ORM 扮演資料庫系統和 Model 資料容器的中間橋梁，讓我們能透過程式語言（JavaScript）去操作資料庫語言（SQL），是實作物件導向概念的一種工具模式。</p>
<pre><code>JavaScript（物件） -&gt; ORM -&gt; SQL（資料）</code></pre>
<h2 id="初探-Sequelize"><a href="#初探-Sequelize" class="headerlink" title="初探 Sequelize"></a>初探 Sequelize</h2><p>初步瞭解什麼是 ORM 框架以後，接著我們要來實際操作 Sequelize 這套 Library，詳細可參考 <span class="exturl" data-url="aHR0cHM6Ly9zZXF1ZWxpemUub3JnL21hc3Rlci9tYW51YWwvZ2V0dGluZy1zdGFydGVkLmh0bWw=">Sequelize 官方文件<i class="fa fa-external-link-alt"></i></span>。</p>
<p>透過 npm 來安裝套件，如果專案設在新開的目錄底下，則需先初始化 npm：</p>
<pre><code>$ npm init
$ npm install --save sequelize</code></pre>
<p>並根據使用的 database 來安裝相關套件，本篇使用 MySQL 作為範例：</p>
<pre><code># One of the following:
$ npm install --save pg pg-hstore # Postgres
$ npm install --save mysql2
$ npm install --save mariadb
$ npm install --save sqlite3
$ npm install --save tedious # Microsoft SQL Server</code></pre>
<h3 id="連線資料庫"><a href="#連線資料庫" class="headerlink" title="連線資料庫"></a>連線資料庫</h3><p>建立 index.js 來引入 sequelize 套件，並透過物件導向概念來連線資料庫：</p>
<pre><code class="javascript=">// 引入 sequelize 套件
const &#123; Sequelize &#125; = require(&#39;sequelize&#39;);

// 透過 new 建立 Sequelize 這個 class，而 sequelize 就是物件 instance
const sequelize = new Sequelize(&#39;database&#39;, &#39;username&#39;, &#39;password&#39;, &#123;
  host: &#39;localhost&#39;,
  dialect: &#39;mysql&#39;
&#125;);</code></pre>
<h3 id="定義物件：Model-模型"><a href="#定義物件：Model-模型" class="headerlink" title="定義物件：Model 模型"></a>定義物件：Model 模型</h3><p>由於 ORM 是透過物件與資料庫做連線，物件中的屬性會對映到資料庫欄位，例如資料型態、是否可為空值等等。</p>
<p>透過 <code>sequelize.define</code> 指令可定義 Model 模型：</p>
<pre><code class="javascript=">// 定義一個叫做 User 的資料結構
const User = sequelize.define(&#39;User&#39;, &#123;
  // 定義 Model 屬性
  firstName: &#123;     　　　 // 欄位名稱
    type: Sequelize.STRING,  //  資料型態
    allowNull: false　　　// 能不能為空，預設是 true
  &#125;,
  lastName: &#123;
    type: Sequelize.STRING
    // allowNull defaults to true
  &#125;
&#125;, &#123;
  // Other model options go here
&#125;);</code></pre>
<p>再來必須呼叫 <code>sequelize.sync()</code> 來執行程式，Sequelize 就會在資料庫建立欄位。而這個指令會回傳一個 promise 物件，需要用 <code>.then()</code> 來接續後面的動作。</p>
<blockquote>
<p>這部分可參考之前的學習筆記：<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWZldGNoLWFuZC1wcm9taXNl">[week 13] Fetch &amp; Promise 補充<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
<h3 id="create-：新增一筆資料"><a href="#create-：新增一筆資料" class="headerlink" title=".create()：新增一筆資料"></a><code>.create()</code>：新增一筆資料</h3><p>如果要新增資料，就在 <code>.then()</code> 裡面使用 <code>&lt;Table Name&gt;.create()</code>，傳入欄位名稱和資料內容：</p>
<pre><code class="javascript=">sequelize.sync().then(() =&gt; &#123;
  // 寫入對映欄位名稱的資料內容
  User.create(&#123;
    // 記得 value 字串要加上引號
    firstName: &#39;Heidi&#39;,
    lastName:&#39;Liu&#39;
  &#125;).then(() =&gt; &#123;
    // 執行成功後會印出文字
    console.log(&#39;successfully created!!&#39;) 
  &#125;);
&#125;);</code></pre>
<p>在 CLI 介面執行後會發現 SQL log：</p>
<p><img src="https://i.imgur.com/sV6Dauj.png"></p>
<p>Sequelize 就會根據 Model 定義，自動在資料庫建立 users table 和一筆資料，並且會自動生成 createdAt 和 updateAt 兩個欄位：</p>
<p><img src="https://i.imgur.com/apIryUS.png"></p>
<h3 id="findAll-：選取所有資料"><a href="#findAll-：選取所有資料" class="headerlink" title=".findAll()：選取所有資料"></a><code>.findAll()</code>：選取所有資料</h3><p>如果要選取所有資料，就在 <code>.then()</code> 裡面用 <code>&lt;Table Name&gt;.findAll()</code>，而 <code>findAll()</code> 會回傳一個 promise，因此也要用 <code>.then()</code> 來接收：</p>
<pre><code class="javascript=">sequelize.sync().then(() =&gt; &#123;
  User.findAll().then(users =&gt; &#123;
    // 用 JSON.stringify() 來格式化輸出
    console.log(&quot;All users:&quot;, JSON.stringify(users, null, 4));
  &#125;);
&#125;);</code></pre>
<p>就能拿到 All users 的資料：</p>
<p><img src="https://i.imgur.com/mY7pNA4.png"></p>
<p>若試著印出 <code>user[0]</code> 的資料：</p>
<pre><code class="javascript=">sequelize.sync().then(() =&gt; &#123;
  User.findAll().then(users =&gt; &#123;
    // 用 JSON.stringify() 來格式化輸出
    console.log(users[0]);
  &#125;);
&#125;);</code></pre>
<p>會得到一個 User 物件，除了資料訊息，也會有一些底線開頭的屬性，像是 Sequelize 設定的資訊：</p>
<p><img src="https://i.imgur.com/mE0MsOM.png"></p>
<p>如果要存取 user 的資料訊息，可直接用 <code>user[0].id</code> 來拿到 id：</p>
<pre><code class="javascript=">sequelize.sync().then(() =&gt; &#123;
  User.findAll().then(users =&gt; &#123;
    console.log(users[0].id, users[0].firstName);
  &#125;);
&#125;);</code></pre>
<p><img src="https://i.imgur.com/fWaQzG1.png"></p>
<h3 id="findAll-where-：設定資料條件"><a href="#findAll-where-：設定資料條件" class="headerlink" title=".findAll(where{ })：設定資料條件"></a>.findAll(where{ })：設定資料條件</h3><p>如果要指定讀取哪些資料，可在 <code>.findAll()</code> 裡面填入 <code>where&#123;&#125;</code> 這個物件來指定條件。假如在資料庫中找不到相對應的資料，就會回傳錯誤訊息：</p>
<pre><code class="javascript=">sequelize.sync().then(() =&gt; &#123;
  User.findAll(&#123;
    where: &#123;
      firstName: &#39;Apple&#39;
    &#125;
  &#125;).then(users =&gt; &#123;
    console.log(users[0].id, users[0].firstName);
  &#125;);
&#125;);</code></pre>
<p>印出符合條件的資料：</p>
<p><img src="https://i.imgur.com/8raviKR.png"></p>
<p>這種寫法就相當於 SQL 語法的 <code>SELECT * FROM users WHERE firstName = Apple</code>，更多有關條設定的語法可參考：<span class="exturl" data-url="aHR0cHM6Ly9zZXF1ZWxpemUub3JnL3Y1L21hbnVhbC9xdWVyeWluZy5odG1s">官方文件 -  querying<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="findOne-：選取單一資料"><a href="#findOne-：選取單一資料" class="headerlink" title=".findOne()：選取單一資料"></a>.findOne()：選取單一資料</h3><p>如果只想選取單一資料，或是想要透過 id 來讀取資料，可以使用 <code>.findOne()</code>：</p>
<pre><code class="javascript=">sequelize.sync().then(() =&gt; &#123;
  User.findOne(&#123;
    where: &#123;
      id: &#39;1&#39;
    &#125;
  &#125;).then(user =&gt; &#123;
    console.log(user.firstName);
  &#125;);
&#125;);
// Heidi</code></pre>
<p>成功撈取指定資料之後，就可以對該筆資料進行 CRUD。</p>
<h3 id="update-：更新資料"><a href="#update-：更新資料" class="headerlink" title=".update()：更新資料"></a>.update()：更新資料</h3><p>如果要更新資料，可使用 <code>.then()</code> 接住資料，並在裡面傳入 function，用來執行 <code>user.update()</code>，把要更新的內容用 <code>&#123;&#125;</code> 大括號包住，再填入 <code>update()</code> 中：</p>
<pre><code class="javascript=">sequelize.sync().then(() =&gt; &#123;
  User.findOne(&#123;
    where: &#123;
      id: &#39;3&#39;
    &#125;
  &#125;).then(user =&gt; &#123;
    // 在 () 裡面用 &#123;&#125; 大括號包住要更新的內容
    user.update(&#123;
      lastName: &#39;Banana&#39;
    &#125;);
  &#125;).then(() =&gt; &#123;
    console.log(&#39;update done!&#39;);
  &#125;);
&#125;);</code></pre>
<p>這樣就成功更新 id 為 3 這筆資料的 lastName：</p>
<p><img src="https://i.imgur.com/wZ95sPf.png"></p>
<h3 id="destroy-：刪除資料"><a href="#destroy-：刪除資料" class="headerlink" title=".destroy()：刪除資料"></a>.destroy()：刪除資料</h3><p>如果要刪除資料，可使用 <code>.then()</code> 接住資料，並在裡面傳入 function，用來執行 <code>user.destroy()</code>：</p>
<pre><code class="javascript=">sequelize.sync().then(() =&gt; &#123;
  User.findOne(&#123;
    where: &#123;
      id: &#39;2&#39;
    &#125;
  &#125;).then(user =&gt; &#123;
    user.destroy().then(() =&gt; &#123;
      console.log(&#39;destroy done!&#39;);
    &#125;);
  &#125;);
&#125;);</code></pre>
<hr>
<h2 id="Associations-資料庫關聯"><a href="#Associations-資料庫關聯" class="headerlink" title="Associations 資料庫關聯"></a>Associations 資料庫關聯</h2><p>再來我們要學習如何做資料庫關聯，也就是將兩個不同的 table 關聯，例如將 <code>users.id</code> 對應到 <code>comments.userId</code>。我們在之前課程使用的 SQL 指令，就是透過 <code>user.id</code> 或是 JOIN 等方式來進行資料庫關聯。</p>
<p>而在 ORM 當中，要將兩個 tabel 進行關聯，則需要透過 <code>.hasMany()</code>、<code>.hasOne</code> 等指令，告訴 Sequelize 執行資料庫關聯，詳細內容可參考<span class="exturl" data-url="aHR0cHM6Ly9zZXF1ZWxpemUub3JnL3Y1L2NsYXNzL2xpYi9hc3NvY2lhdGlvbnMvYmFzZS5qc35Bc3NvY2lhdGlvbi5odG1s">官方文件<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="如何關聯兩個-table"><a href="#如何關聯兩個-table" class="headerlink" title="如何關聯兩個 table"></a>如何關聯兩個 table</h3><p>以 <code>User.hasMany(Comment)</code> 指令來說，意思就是告訴 Sequelize 一個 user 可以有很多 comment，接著就會在 comment table 中加上 userId 來建立關聯：</p>
<pre><code class="javascript=">const User = sequelize.define(&#39;user&#39;, &#123;
  firstName: &#123;
    type: Sequelize.STRING,
    allowNull: false
  &#125;,
  lastName: &#123;
    type: Sequelize.STRING
  &#125;
&#125;, &#123;
&#125;);

const Comment = sequelize.define(&#39;comment&#39;, &#123;
  content: &#123;
    type: Sequelize.STRING,
  &#125;
&#125;);

User.hasMany(Comment);  // 將兩個 table 進行關聯</code></pre>
<p>執行後就會發現建立了 comments table，還多了 userId 這個欄位：</p>
<p><img src="https://i.imgur.com/KiaKCDW.png"></p>
<h3 id="範例：新增留言"><a href="#範例：新增留言" class="headerlink" title="範例：新增留言"></a>範例：新增留言</h3><p>接著我們就能對資料庫進行操作，以新建一個 comment 為例，在 Comment 要填入 content 和 userId：</p>
<pre><code class="javascript=">sequelize.sync().then(() =&gt; &#123;
  Comment.create(&#123;
    userId: &#39;3&#39;,
    content: &#39;Hello!&#39;
  &#125;).then(() =&gt;&#123;
    console.log(&#39;done!&#39;)
  &#125;);
  User.findOne(&#123;
    where: &#123;
      firstName: &#39;Apple&#39;
    &#125;
  &#125;).then(user =&gt; &#123;

  &#125;);
&#125;);</code></pre>
<p>執行成功會印出設定的 <code>done!</code>：</p>
<p><img src="https://i.imgur.com/7HvR4V7.png"></p>
<p>這樣就成功在 comments table 建立了一則留言：</p>
<p><img src="https://i.imgur.com/Qi9bRny.png"></p>
<h3 id="範例：撈取資料"><a href="#範例：撈取資料" class="headerlink" title="範例：撈取資料"></a>範例：撈取資料</h3><p>接著我們就可以利用關聯的 user id 來撈取資料，透過 <code>include:&lt;Table&gt;</code> 這個參數來指定 Model，如果要 include 多個 Model 可透過 Array 傳入：</p>
<pre><code class="javascript=">sequelize.sync().then(() =&gt; &#123;
  User.findOne(&#123;
    where: &#123;
      firstName: &#39;Apple&#39;
    &#125;,
    // 新增 include 這個參數來指定 Model
    include: Comment
  &#125;).then(user =&gt; &#123;
    console.log(user)
  &#125;);
&#125;);</code></pre>
<p>若把 user 資料印出來，會發現包含很多資訊：</p>
<p><img src="https://i.imgur.com/c6SBlsD.png"></p>
<p>利用 <code>JSON.stringify()</code> 來格式化輸出，即可忽略不需要的資訊：</p>
<pre><code class="javascript=">sequelize.sync().then(() =&gt; &#123;
  User.findOne(&#123;
    where: &#123;
      firstName: &#39;Apple&#39;
    &#125;,
    include: Comment
  &#125;).then(user =&gt; &#123;
    console.log(JSON.stringify(user.comments, null, 4));
  &#125;);
&#125;);</code></pre>
<p>就會拿到 userId 為 3 的使用者的所有留言：</p>
<p><img src="https://i.imgur.com/RYpcxxT.png"></p>
<p>而 <code>User.hasMany(Comment);</code> 其實是單向關係，也就是將 User 對 Comment 進行關聯，但沒有說明 Comment 和 User 的關係是什麼。這時如果要從 comment 來查詢 user 的資料，就會出現錯誤訊息。</p>
<p>需要加上 <code>Comment.belongsTo(User)</code>，透過這段指令將 Comment 對 User 做關聯，建立起雙向關係：</p>
<pre><code class="javascript=">User.hasMany(Comment);
Comment.belongsTo(User);

sequelize.sync().then(() =&gt; &#123;
  Comment.findOne(&#123;
    where: &#123;
      content: &#39;Hello!&#39;
    &#125;,
    include: User
  &#125;).then(comment =&gt; &#123;
    console.log(JSON.stringify(comment, null, 4));
  &#125;);
&#125;);</code></pre>
<p>就會拿到有關 comment 的 user 資訊：</p>
<p><img src="https://i.imgur.com/5U9BsA1.png"></p>
<h2 id="Sequelize-CLI"><a href="#Sequelize-CLI" class="headerlink" title="Sequelize CLI"></a>Sequelize CLI</h2><p>在實際開發時，為了讓程式碼更有結構性以及方便管理，可安裝 Sequelize CLI 這套工具，詳細內容可參考<span class="exturl" data-url="aHR0cHM6Ly9zZXF1ZWxpemUub3JnL3Y1L21hbnVhbC9taWdyYXRpb25zLmh0bWw=">官方文件<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="安裝並初始化"><a href="#安裝並初始化" class="headerlink" title="安裝並初始化"></a>安裝並初始化</h3><pre><code>$ npm install --save sequelize-cli
$ npx sequelize-cli init</code></pre>
<p>完成初始化會建立 config.json 檔案，裡面會有連線資料庫的設定，包含 database 帳密等資訊，因此通常不會加到 commit：</p>
<p><img src="https://i.imgur.com/UOauFVL.png"></p>
<h3 id="設定連線資料庫"><a href="#設定連線資料庫" class="headerlink" title="設定連線資料庫"></a>設定連線資料庫</h3><p>接著可以在 config.json 更改成我們連線資料庫的設定，三種設定分別是在開發環境、測試環境、正式環境。因為我們現在是在 localhost 開發所以要修改 development 的部分：</p>
<p><img src="https://i.imgur.com/opeKSyL.png"></p>
<h3 id="建立-Model"><a href="#建立-Model" class="headerlink" title="建立 Model"></a>建立 Model</h3><p>接著我們可以直接透過 CLI 指令來建立 User 和 Comment 這兩個 Model：</p>
<pre><code>$ npx sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string
$ npx sequelize-cli model:generate --name Comment --attributes content:string</code></pre>
<p>建立好 Model 之後，Sequelize 會自動在 models 和 migrations 資料夾底下建立檔案：</p>
<p><img src="https://i.imgur.com/xTNnc3A.png"></p>
<p>我們可以透過 user.js 和 comment.js 這些檔案設定，來對 model 進行微調：</p>
<pre><code class="javascript=">&#39;use strict&#39;;
module.exports = (sequelize, DataTypes) =&gt; &#123;
  const Comment = sequelize.define(&#39;Comment&#39;, &#123;
    content: DataTypes.STRING
  &#125;, &#123;&#125;);
  Comment.associate = function(models) &#123;
    //  在這裡設定資料庫關聯
    Comment.belongsTo(Models.User);
  &#125;;
  return Comment;
&#125;</code></pre>
<h3 id="執行-Migrations"><a href="#執行-Migrations" class="headerlink" title="執行 Migrations"></a>執行 Migrations</h3><p>但設定完這些檔案之後，資料庫裡面還不會有任何東西。這是因為必須透過執行 Migrations，才會依照我們在 Model 做的設定去操作資料庫：</p>
<pre><code>$ npx sequelize-cli db:migrate</code></pre>
<p>接著就會在資料庫建立 SequelizeMeta table 來記錄執行過的 migrations；並且依照 migrations 中的檔案去操作資料庫，也就是建立 users 和 comments table：</p>
<p><img src="https://i.imgur.com/RPTzLXv.png"></p>
<p>有了 migrations，就不需再透過 <code>sync()</code> 指令來操作資料庫，並且能夠以更結構性的方式進行管理。</p>
<h3 id="透過-Migrations-關聯資料庫"><a href="#透過-Migrations-關聯資料庫" class="headerlink" title="透過 Migrations 關聯資料庫"></a>透過 Migrations 關聯資料庫</h3><p>接著在建立好的檔案 user.js 和 comment.js 加上關聯設定，其中 model 通常會以英文大寫開頭：</p>
<ul>
<li>user.js</li>
</ul>
<pre><code class="javascript=">&#39;use strict&#39;;
const &#123;
  Model
&#125; = require(&#39;sequelize&#39;);
module.exports = (sequelize, DataTypes) =&gt; &#123;
  class User extends Model &#123;
    static associate(models) &#123;
      // 加上關聯資料庫的設定
      User.hasMany(models.Comment)
    &#125;
  &#125;;
  User.init(&#123;
    firstName: DataTypes.STRING,
    lastName: DataTypes.STRING,
    email: DataTypes.STRING
  &#125;, &#123;
    sequelize,
    modelName: &#39;User&#39;,
  &#125;);
  return User;
&#125;;</code></pre>
<ul>
<li>comment.js</li>
</ul>
<pre><code class="javascript=">&#39;use strict&#39;;
const &#123;
  Model
&#125; = require(&#39;sequelize&#39;);
module.exports = (sequelize, DataTypes) =&gt; &#123;
  class Comment extends Model &#123;
    static associate(models) &#123;
      // 加上關聯資料庫的設定，存取其他 Model
      Comment.belongsTo(models.User);
    &#125;
  &#125;;
  Comment.init(&#123;
    content: DataTypes.STRING
  &#125;, &#123;
    sequelize,
    modelName: &#39;Comment&#39;,
  &#125;);
  return Comment;
&#125;;</code></pre>
<h3 id="新增資料"><a href="#新增資料" class="headerlink" title="新增資料"></a>新增資料</h3><p>再來回到根目錄的 index.js，即可從 models 引入 db 來使用：</p>
<pre><code class="javascript=">const db = require(&#39;./models&#39;);</code></pre>
<p>以下列程式碼為例，如此就可以透過 index.js 來操作資料庫：</p>
<pre><code class="javascript=">const User = db.User;
const Comment =　db.Comment;

User.create(&#123;
  firstName: &#39;Hello&#39;,
  lastName: &#39;World&#39;
&#125;).then(() =&gt; &#123;
  console.log(&#39;done!&#39;)
&#125;);</code></pre>
<p>執行後成功在 User 新增一筆資料：</p>
<p><img src="https://i.imgur.com/OPsscPV.png"></p>
<hr>
<h2 id="改造留言板系統"><a href="#改造留言板系統" class="headerlink" title="改造留言板系統"></a>改造留言板系統</h2><p>在瞭解到什麼是 Sequelize 和 ORM 之後，接著我們要來改造之前時做的<span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWJlMjAxLWV4cHJlc3MtcHJhY3RpY2U=">留言版系統<i class="fa fa-external-link-alt"></i></span>，也就是把 Model 部分改用 Sequelize 實作。</p>
<h3 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h3><p>在 express 專案中引入 Sequelize 套件，並進行初始化：</p>
<pre><code>$ npm install sequelize mysql2
$ npm install sequelize-cli
$ npx sequelize-cli init</code></pre>
<p>接著在建立 Model 之前，可以先清除不必要的檔案和程式碼，例如 db.js、todocontroller、以及原本 models 的部分。</p>
<h3 id="設定連線資料庫-1"><a href="#設定連線資料庫-1" class="headerlink" title="設定連線資料庫"></a>設定連線資料庫</h3><p>接著修改 config.json 資料庫連線的設定：</p>
<pre><code class="javascript=">  &quot;development&quot;: &#123;
    &quot;username&quot;: &quot;root&quot;,
    &quot;password&quot;: null,
    &quot;database&quot;: &quot;mydb&quot;,
    &quot;host&quot;: &quot;localhost&quot;,
    &quot;dialect&quot;: &quot;mysql&quot;
  &#125;,</code></pre>
<h3 id="建立-Model-1"><a href="#建立-Model-1" class="headerlink" title="建立 Model"></a>建立 Model</h3><p>再來要建立 User 和 Comment 兩個 Model：</p>
<ul>
<li>因為已經要把兩個 table 進行關聯，Comment  table 就不須再加上 username 欄位</li>
<li>string 型態預設會建立 VARCHAR，最大長度為 255，因此可以把 content 改用 text</li>
<li>在新增之前記得先把舊的同名 table 移除，避免互相干擾</li>
</ul>
<pre><code>$ npx sequelize-cli model:generate --name User --attributes username:string,password:string,nickname:string

$ npx sequelize-cli model:generate --name Comment --attributes content:text</code></pre>
<p>執行後會在 models 建立檔案：</p>
<p><img src="https://i.imgur.com/XXR8r9j.png"></p>
<h3 id="執行-Migrations-1"><a href="#執行-Migrations-1" class="headerlink" title="執行 Migrations"></a>執行 Migrations</h3><p>再來執行 Migrations，才會真正把資料寫入資料庫來建立 table：</p>
<pre><code>$ npx sequelize-cli db:migrate</code></pre>
<p>執行後會在資料庫建立 table：</p>
<p><img src="https://i.imgur.com/cJidV5z.png"></p>
<p>但我們還需要在 comment table 加上 UserId 欄位，這部分要自己手動修改 migrations 中的 create-comment 檔案：</p>
<pre><code class="javascript=">// 新增 UserId 這個欄位，型態是數字
  UserId: &#123;
    type: Sequelize.INTEGER
  &#125;</code></pre>
<p>接著要重跑一次 Migrations，可透過下方<br>指令來撤銷上一個動作：</p>
<pre><code>// 單次撤銷（最近的一次）
$ npx sequelize-cli db:migrate:undo

// 撤銷所有
$ npx sequelize-cli db:migrate:all</code></pre>
<p><img src="https://i.imgur.com/iGSJ2HF.png"></p>
<p>到資料庫會發現 comments 不見了，但 users 不會受到影響：</p>
<p><img src="https://i.imgur.com/XKqaVdq.png"></p>
<p>再跑一次 Migrations 建立 Comment table，會多一個 UserId 欄位：</p>
<p><img src="https://i.imgur.com/N6Hfsy7.png"></p>
<h4 id="補充：設定-username-為-UNIQUE"><a href="#補充：設定-username-為-UNIQUE" class="headerlink" title="補充：設定 username 為 UNIQUE"></a>補充：設定 username 為 UNIQUE</h4><p>此外，也可透過修改 create-user 檔案，把 username 欄位設定為 UNIQUE，然後再重新 Migrations。如此可避免註冊時會有重複的 username：</p>
<pre><code class="javascript=">  username: &#123;
    type: Sequelize.STRING,
    unique: true
  &#125;,</code></pre>
<h3 id="關聯資料庫"><a href="#關聯資料庫" class="headerlink" title="關聯資料庫"></a>關聯資料庫</h3><p>再來要進行資料庫關聯，分別在 models 資料夾中的 user.js 和 comment.js 加上關聯指令：</p>
<pre><code class="javascript=">// user.js
  static associate(models) &#123;
    User.hasMany(models.Comment);
  &#125;</code></pre>
<pre><code class="javascript=">// comment.js
  static associate(models) &#123;
    Comment.belongsTo(models.User);
    &#125;</code></pre>
<h3 id="修改-Controllers"><a href="#修改-Controllers" class="headerlink" title="修改 Controllers"></a>修改 Controllers</h3><p>接著要來修改 user 和 comment 的 Controllers，也就是原本處理 userModel 的部分：</p>
<ul>
<li>controllers\user.js</li>
</ul>
<ol>
<li>拿掉原本引入的 userModel，改成引入 db 中的 models：</li>
</ol>
<pre><code class="javascript=">const db = require(&#39;../models&#39;);
const User = db.User;</code></pre>
<ol start="2">
<li>修改 handleLogin：</li>
</ol>
<pre><code class="javascript=">  handleLogin: (req, res, next) =&gt; &#123;
    const &#123; username, password &#125; = req.body;
    if (!username || !password) &#123;
      req.flash(&#39;errorMessage&#39;, &#39;請輸入您的帳密&#39;);
      return next();
    &#125;

    // 從 User table 撈取對應 username 的資料
    User.findOne(&#123;
      where: &#123;
        username
      &#125;
    &#125;).then(user =&gt; &#123;
      if (!user) &#123;
        req.flash(&#39;errorMessage&#39;, &#39;使用者不存在&#39;);
        return next();
      &#125;

      bcrypt.compare(password, user.password, function (err, isSccess) &#123;
        if (err || !isSccess) &#123;
          req.flash(&#39;errorMessage&#39;, &#39;輸入帳密有誤&#39;);
          return next();
        &#125;
        req.session.username = user.username;
        // 在 session 中加入 user.id
        req.session.userId = user.id;
        res.redirect(&#39;/&#39;)
      &#125;);
    // 有錯誤的話就印出錯誤訊息
    &#125;).catch(err =&gt; &#123;
      req.flash(&#39;errorMessage&#39;, err.toString());
      return next();
    &#125;);
  &#125;,</code></pre>
<ol start="3">
<li>修改 handleRegister：</li>
</ol>
<pre><code class="javascript=">  handleRegister: (req, res, next) =&gt; &#123;
    const &#123;username, password, nickname&#125; = req.body;
    if (!username || !password || !nickname) &#123;
      req.flash(&#39;errorMessage&#39;, &#39;缺少必要欄位&#39;);
      return next();
    &#125;

    bcrypt.hash(password, saltRounds, function (err, hash) &#123;
      if (err) &#123;
        req.flash(&#39;errorMessage&#39;, err.toString());
        return next();
      &#125;
      // 在 User table 建立資料
      User.create(&#123;
        username,
        nickname,
        password: hash
      &#125;).then(user =&gt; &#123;     // create 完會回傳一個 instance
        req.session.username = username;
        // 在 session 中加入 user.id
        req.session.userId = user.id;
        res.redirect(&#39;/&#39;);

      // 有錯誤的話就印出錯誤訊息
      &#125;).catch(err =&gt; &#123;
        req.flash(&#39;errorMessage&#39;, &#39;已存在相同用戶名&#39;);
        return next();
      &#125;);
    &#125;);
  &#125;,</code></pre>
<ul>
<li>controllers\comment.js</li>
</ul>
<ol>
<li>拿掉原本引入的 commentModel，改成引入 db 中的 models：</li>
</ol>
<pre><code class="javascript=">// 從 models 引入 db
const db = require(&#39;../models&#39;);
const Comment = db.Comment;
const User = db.User;</code></pre>
<ol start="2">
<li>修改 add：</li>
</ol>
<pre><code class="javascript=">  add: (req, res, next) =&gt; &#123;
    const &#123;userId&#125; = req.session
    const &#123;content&#125; = req.body
    if (!userId) &#123;
      req.flash(&#39;errorMessage&#39;, &#39;請先登入&#39;);
      return next();
    &#125;
    if (!content) &#123;
      req.flash(&#39;errorMessage&#39;, &#39;請填入留言內容&#39;);
      return next();
    &#125;

    Comment.create(&#123;
      content,
      UserId: userId
    &#125;).then(() =&gt; &#123;
      res.redirect(&#39;/&#39;);
    &#125;)
  &#125;,</code></pre>
<ol start="3">
<li>修改 index：</li>
</ol>
<pre><code class="javascript=">  index: (req, res) =&gt; &#123;
    Comment.findAll(&#123;
      // 撈取資料需要關聯 Comment 和 User table
      include: User
    &#125;).then(comments =&gt; &#123;
      res.render(&#39;index&#39;, &#123;
        comments
      &#125;);
    &#125;);
  &#125;,</code></pre>
<p>因為資料形式改變，必須修改 View 的部分，例如拿取 nickname 的部分，要改成 comment.User.nickname 來透過關聯拿取：</p>
<pre><code class="htmlmixed=">&lt;!-- index.ejs --&gt;
  &lt;div class=&quot;card-container d-flex justify-content-around flex-wrap&quot; style=&quot;width: 100%;&quot;&gt;
    &lt;% comments.forEach(function(comment) &#123; %&gt;
      &lt;div class=&quot;card mb-2&quot; style=&quot;width: 22rem; height: 18rem;&quot;&gt;
        &lt;div class=&quot;card-header&quot;&gt;
          &lt;div class=&quot;card-top d-flex justify-content-between&quot;&gt;
            &lt;h5 class=&quot;card-title&quot;&gt;&lt;%= comment.User.nickname %&gt;&lt;/h5&gt;
            &lt;div class=&quot;card-btn&quot;&gt;
              &lt;% if (username === comment.User.username) &#123;%&gt;
              &lt;a href=&quot;/update_comments/&lt;%= comment.id %&gt;&quot; class=&quot;card-link&quot;&gt;編輯&lt;/a&gt;
              &lt;a href=&quot;/delete_comments/&lt;%= comment.id %&gt;&quot; class=&quot;card-link&quot;&gt;刪除&lt;/a&gt;
              &lt;% &#125; %&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;p class=&quot;card-subtitle text-muted&quot;&gt;&lt;%= moment(comment.createdAt).format(shortDateFormat) %&gt;&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class=&quot;card-body&quot; style=&quot;overflow:scroll; overflow-x:hidden; &quot;&gt;
          &lt;p class=&quot;card-text&quot; &gt;&lt;%= comment.content %&gt;&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;% &#125;) %&gt;
  &lt;/div&gt;</code></pre>
<ol start="4">
<li>修改 delete：</li>
</ol>
<pre><code class="javascript=">  delete: (req, res) =&gt; &#123;
    Comment.findOne(&#123;
      where: &#123;
        id: req.params.id,
        UserId: req.session.userId
      &#125;
    &#125;).then(comment =&gt; &#123;
      return comment.destroy();
    &#125;).then(() =&gt; &#123;
      res.redirect(&#39;/&#39;);
    &#125;).catch(() =&gt; &#123;
      res.redirect(&#39;/&#39;);
    &#125;);
  &#125;,</code></pre>
<ol start="5">
<li>修改 update 和 handleupdate：</li>
</ol>
<pre><code class="javascript=">  update: (req, res) =&gt; &#123;
    Comment.findOne(&#123;
      where: &#123;
        id: req.params.id
      &#125;
    &#125;).then(comment =&gt; &#123;
      res.render(&#39;update&#39;, &#123;
        comment
      &#125;);
    &#125;);
  &#125;,

  handleUpdate: (req, res) =&gt; &#123;
    Comment.findOne(&#123;
      where: &#123;
        id: req.params.id,
        UserId: req.session.userId
      &#125;
    &#125;).then(comment =&gt; &#123;
      return comment.update(&#123;
        content: req.body.content
      &#125;);
    &#125;).then(() =&gt; &#123;
      res.redirect(&#39;/&#39;);
    &#125;).catch(() =&gt; &#123;
      res.redirect(&#39;/&#39;);
    &#125;);
  &#125;</code></pre>
<p>修改結果：</p>
<p><img src="https://i.imgur.com/aSeD9vH.png"></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這樣就成功透過 Express 搭配 Sequelize 修改之前的留言板結構，即使不使用 SQL 指令，也能以 ORM 提供的物件導向形式來操作資料庫。</p>
<p>這種寫法和之前使用 PHP &amp; MySQL 實作留言板的方式很不相同會比較偏向先完成切版，然後一步一步增加功能；但以 MVC 架構去撰寫程式碼，會先規劃不同功能對應的不同路由，接著再規劃 Model 資料結構，以及如何呈現在畫面上，這使得整體結構分工更明確，也有助於後續的維護。</p>
<p>參考資料：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tdHIwNC1ub3RlLmNvZGVyYnJpZGdlLmlvLzIwMjAvMTAvMTAvc2VxdWVsaXplLw==">[ 筆記 ] Express 03 - ORM ＆ Sequelize<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIwNzc1Mg==">[Day20] 資料庫設計概念 - ORM<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>Back-End</tag>
        <tag>Sequelize</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 17] 後端中階 - Express 實戰：簡易會員註冊系統 &amp; 留言板</title>
    <url>/express-board/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvYmUyMDEtZXhwcmVzcy1zZXF1ZWxpemU=">[BE201] 後端中階：Express 與 Sequelize<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<p>在之前的課程中，我們學到如何使用 Express 這套框架，以及在 Express 扮演重要角色的 Middleware：</p>
<a id="more"></a>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWJlMjAxLWV4cHJlc3Mtbm9kZQ==">[week 17] 後端中階 - 使用 Node.js + Express 框架建立一個靜態網頁<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oYWNrbWQuaW8vQEhlaWRpLUxpdS9ub3RlLWJlMjAxLWV4cHJlc3MtbWlkZGxld2FyZQ==">[week 17] 後端中階 - Express 中不可或缺的拼圖：淺談 Middleware<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>接下來要整合我們之前所學的東西，透過串聯資料庫系統，來實作一個簡單的會員註冊系統，並且具有留言版功能的網頁。</p>
<hr>
<h2 id="實戰練習：簡易會員註冊系統"><a href="#實戰練習：簡易會員註冊系統" class="headerlink" title="實戰練習：簡易會員註冊系統"></a>實戰練習：簡易會員註冊系統</h2><p>在使用 Express 框架實作網頁時，大致上會依照下方流程進行：</p>
<ol>
<li>思考產品全貌：會員註冊系統</li>
<li>規劃資料庫結構：users table</li>
<li>載入需要的模組，設定 app 路由部分</li>
<li>依照 MVC 架構撰寫程式碼：<ul>
<li>設定 Controller：針對不同路由進行控制</li>
<li>設定 Model：如何處理資料</li>
<li>設定 View：如何呈現畫面</li>
</ul>
</li>
</ol>
<p>接下來我們也同樣會依照這個流程來進行實作。</p>
<h3 id="Step1-規劃資料庫"><a href="#Step1-規劃資料庫" class="headerlink" title="Step1. 規劃資料庫"></a>Step1. 規劃資料庫</h3><p>首先在資料庫新增一個 users Tabel：</p>
<p><img src="https://i.imgur.com/22wyXlm.png"></p>
<p>可以把 username 設定為 UNIQUE（唯一），只要 username 有重複就會自動跳出錯誤訊息：</p>
<p><img src="https://i.imgur.com/75SSRX2.png"></p>
<h3 id="Step2-實作-Model-部分"><a href="#Step2-實作-Model-部分" class="headerlink" title="Step2. 實作 Model 部分"></a>Step2. 實作 Model 部分</h3><p>接著要來建立 userModel：</p>
<pre><code class="javascript=">const db = require(&#39;../db&#39;);

const userModel = &#123;
  // 新增 user 功能
  add: (user, cb) =&gt; &#123;
    db.query(
      &#39;INSERT INTO users(username, password, nickname) VALUES(?, ?, ?)&#39;,
      [user.username, user.password, user.nickname],
      (err, results) =&gt; &#123;
        if (err) return cb(err);
        cb(null);
      &#125;
    );
  &#125;,

  // 登入 -&gt; 讀取 user 功能
  get: (username, cb) =&gt; &#123;
    db.query(
      &#39;SELECT * FROM users WHERE username = ?&#39;, [username], (err, results) =&gt; &#123;
      if (err) return cb(err);
      cb(null, results[0]);
    &#125;);
  &#125;
&#125;

module.exports = userModel;</code></pre>
<h3 id="Step3-實作-Controller-部分"><a href="#Step3-實作-Controller-部分" class="headerlink" title="Step3. 實作 Controller 部分"></a>Step3. 實作 Controller 部分</h3><ol>
<li>先建立好程式碼架構，再來填寫路由部分：</li>
</ol>
<pre><code class="javascript=">// 引入 userModel
const userModel = require(&#39;../models/todo&#39;)

const userController = &#123;
  get: (req, res) =&gt; &#123;

  &#125;
&#125;

// 輸出 userController
module.exports = userController</code></pre>
<ol start="2">
<li>在 index.js 引入 userController，並新增 userController 處理 login 和 logout 的路由：</li>
</ol>
<pre><code class="javascript=">const userController = require(&#39;./controllers/user&#39;)

app.get(&#39;/login&#39;, userController.login)
app.post(&#39;/login&#39;, userController.handleLogin)
app.get(&#39;/logout&#39;, userController.logout)</code></pre>
<ol start="3">
<li>Controller 就會根據不同路由，建立相對應的 Method：</li>
</ol>
<pre><code class="javascript=">// 引入 userModel
const userModel = require(&#39;../models/user&#39;)

const userController = &#123;
  // 渲染登入畫面
  login: (req, res) =&gt; &#123;
    res.render(&#39;login&#39;)
  &#125;,

  // 驗證登入狀態
  handleLogin: (req, res) =&gt; &#123;
    if (req.body.password) === &#39;abc&#39; &#123;
      req.session.isLogin = true
      res.redirect(&#39;/&#39;)
    &#125; else &#123;
      req.flash(&#39;errorMessage&#39;, &#39;Please input the correct password.&#39;)
    &#125;
  &#125;,

  // 登出: 清除 session 並導回首頁
  logout:: (req, res) =&gt; &#123;
    req.session.isLogin = false;
    res.redirect(&#39;/&#39;);
  &#125;
&#125;

// 輸出 userController
module.exports = userController</code></pre>
<h3 id="Step4-實作-View-部分"><a href="#Step4-實作-View-部分" class="headerlink" title="Step4. 實作 View 部分"></a>Step4. 實作 View 部分</h3><ol>
<li>在根目錄增加一個首頁 index 的路由：</li>
</ol>
<pre><code class="javascript=">// 建立首頁
app.get(&#39;/&#39;, (req, res) =&gt; &#123;
  res.render(&#39;index&#39;)
&#125;)</code></pre>
<ol start="2">
<li>接著建立 index.ejs 檔案，實作主要頁面：</li>
</ol>
<pre><code class="javascript=">&lt;h1&gt;簡易會員系統&lt;/h1&gt;

&lt;a href=&quot;/register&quot;&gt;註冊&lt;/a&gt;
&lt;a href=&quot;/login&quot;&gt;登入&lt;/a&gt;
&lt;a href=&quot;/logout&quot;&gt;登出&lt;/a&gt;</code></pre>
<p>到這裡可先運行程式看看有沒有問題：</p>
<p><img src="https://i.imgur.com/Z1iMl9S.png"></p>
<ol start="3">
<li>加入前面範例中的驗證功能：</li>
</ol>
<pre><code class="javascript=">&lt;h1&gt;簡易會員系統&lt;/h1&gt;

&lt;% if(isLogin) &#123; %&gt;
  &lt;a href=&quot;/logout&quot;&gt;登出&lt;/a&gt;
&lt;% &#125; else &#123; %&gt;
  &lt;a href=&quot;/register&quot;&gt;註冊&lt;/a&gt;
  &lt;a href=&quot;/login&quot;&gt;登入&lt;/a&gt;
&lt;% &#125; %&gt;</code></pre>
<p>這樣在未登入狀態下，就只會看到註冊和登入，這樣就完成了首頁 index 的部分：</p>
<p><img src="https://i.imgur.com/n7ew34I.png"></p>
<h3 id="Step5-實作註冊功能"><a href="#Step5-實作註冊功能" class="headerlink" title="Step5. 實作註冊功能"></a>Step5. 實作註冊功能</h3><ol>
<li>先建立 register 路由：</li>
</ol>
<pre><code class="javascript=">app.get(&#39;/register&#39;, userController.register)
app.post(&#39;/register&#39;, userController.handleRegister)</code></pre>
<ol start="2">
<li>根據不同路由建立相對應的 controller，這裡可以把有關 user 的 view 放在同一個資料夾，較方便管理：</li>
</ol>
<pre><code class="javascript=">  // 渲染註冊頁面
  register: (req, res) =&gt; &#123;
    // 把路徑設在 user 資料夾，較方便管理
    res.render(&#39;user/register&#39;);
  &#125;,

  // 驗證註冊
  handleRegister: (req, res) =&gt; &#123;

  &#125;,</code></pre>
<ol start="3">
<li>新增 register 的 view：</li>
</ol>
<pre><code class="htmlmixed=">&lt;h1&gt;註冊頁面&lt;/h1&gt;

&lt;h2&gt;&lt;%= errorMessage %&gt;&lt;/h2&gt;

&lt;form method=&quot;POST&quot; action=&quot;/register&quot;&gt;
  &lt;div&gt;username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;/div&gt;
  &lt;div&gt;nickname: &lt;input type=&quot;text&quot; name=&quot;nickname&quot; /&gt;&lt;/div&gt;
  &lt;div&gt;password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;/div&gt;
  &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;</code></pre>
<p>記得每做到一個段落就執行程式看有沒有出錯，這樣我們就完成簡單的註冊頁面。這時按提交還不會有反應：</p>
<p><img src="https://i.imgur.com/AiRq3HA.png"></p>
<ol start="4">
<li>再來就是實作 handleRegister 的 Controller 部分：</li>
</ol>
<pre><code class="javascript=">  // 驗證註冊
  handleRegister: (req, res) =&gt; &#123;
    // 從 resquest body 拿取 user 資料
    const &#123;username, password, nickname&#125; = req.body;
    if (!username || !password || !nickname) &#123;
      // 這裡用 return 就可避免 if-else 寫法增加層數
      return req.flash(&#39;errorMessage&#39;, &#39;缺少必要欄位&#39;);
    &#125;
    // 資料都沒問題的話，就可透過 userModel 寫入資料
    // 傳入一個物件，若有錯誤會回傳 cb 
    userModel.add(&#123;
      username,
      nickname,
      password
    &#125;, (err) =&gt; &#123;
        if (err) &#123;
          // 印出 err
          return req.flash(&#39;errorMessage&#39;, err.toString());
        &#125;
      &#125;
      // 註冊成功就保持登入狀態，並導回首頁
      req.session.username = username;
      res.redirect(&#39;/&#39;);
    &#125;);
  &#125;,

  logout: (req, res) =&gt; &#123;
  // 登出就把 session 重置
  req.session.username = null;
  res.redirect(&#39;/&#39;);
&#125;</code></pre>
<ol start="5">
<li>但這樣其實就要把 session 改成存 username，有 username 就代表有登入狀態：</li>
</ol>
<pre><code class="javascript=">// 透過 locals 傳值: session 功能和 errorMessage
app.use((req, res, next) =&gt; &#123;
  // 有 username 代表有登入狀態
  res.locals.username = req.session.username
  res.locals.errorMessage = req.flash(&#39;errorMessage&#39;)
  next()
&#125;)</code></pre>
<ol start="6">
<li>首頁 index.ejs 的驗證也同樣修改成判斷是否有 username，因為使用 <code>&lt;%= %&gt;</code> 會輸出原始碼，相當於做 escpae：</li>
</ol>
<pre><code class="htmlmixed=">&lt;h1&gt;簡易會員系統&lt;/h1&gt;

&lt;!-- 以是否有 username 來判斷登入狀況 --&gt;
&lt;% if(username) &#123; %&gt;
  &lt;!-- 使用 &lt;%= %&gt; 會輸出原始碼，相當於做 escpae --&gt;
  &lt;div&gt;Hello, &lt;%= username + &#39;!&#39; %&gt;&lt;/div&gt;
  &lt;a href=&quot;/logout&quot;&gt;登出&lt;/a&gt;
&lt;% &#125; else &#123; %&gt;
  &lt;a href=&quot;/register&quot;&gt;註冊&lt;/a&gt;
  &lt;a href=&quot;/login&quot;&gt;登入&lt;/a&gt;
&lt;% &#125; %&gt;</code></pre>
<h3 id="Step6-用-hash-雜湊處理明碼"><a href="#Step6-用-hash-雜湊處理明碼" class="headerlink" title="Step6. 用 hash 雜湊處理明碼"></a>Step6. 用 hash 雜湊處理明碼</h3><ol>
<li>接下來可安裝 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlbGVrdGl2L25vZGUuYmNyeXB0LmpzLw==">node.bcrypt.js<i class="fa fa-external-link-alt"></i></span> 套件，即可將明碼進行雜湊處理，避免儲存明碼造成安全性問題：</li>
</ol>
<pre><code>$ npm install bcrypt</code></pre>
<ul>
<li>使用方法</li>
</ul>
<pre><code class="javascript=">// 引入 bcrypt
const bcrypt = require(&#39;bcrypt&#39;);
// 加鹽，增加密碼的複雜程度
const saltRounds = 10;</code></pre>
<ul>
<li>雜湊函式</li>
</ul>
<pre><code class="javascript=">bcrypt.hash(myPlaintextPassword, saltRounds, function(err, hash) &#123;
    // Store hash in your password DB.
&#125;);</code></pre>
<ol start="2">
<li>再來修改剛才的 handleRegister，利用 bcrypt 套件對密碼進行雜湊處理，再儲存 hash 過的密碼到資料庫：</li>
</ol>
<pre><code class="javascript=">  // 驗證註冊
  handleRegister: (req, res, next) =&gt; &#123;
    // 從 resquest body 拿取 user 資料
    const &#123;username, password, nickname&#125; = req.body;
    if (!username || !password || !nickname) &#123;
      // 這裡用 return 就可避免 if-else 寫法增加層數
      req.flash(&#39;errorMessage&#39;, &#39;缺少必要欄位&#39;);
      return next();
    &#125;

    // 利用 bcrypt 套件對密碼進行雜湊處理
    bcrypt.hash(password, saltRounds, function (err, hash) &#123;
      // 若有 err 就直接顯示錯誤訊息
      if (err) &#123;
        req.flash(&#39;errorMessage&#39;, err.toString());
        return next();
      &#125;
      // 資料都沒問題的話，就可透過 userModel 寫入資料
      userModel.add(&#123;
        username,
        nickname,
        password: hash
      &#125;, (err) =&gt; &#123;
        // 若有 err 就直接顯示錯誤訊息
        if (err) &#123;
          req.flash(&#39;errorMessage&#39;, &#39;已存在相同用戶名&#39;);
          return next();
        &#125;
        // 註冊成功就保持登入狀態，並導回首頁
        req.session.username = username;
        res.redirect(&#39;/&#39;);
      &#125;);
    &#125;);
  &#125;,
</code></pre>
<p>執行程式並註冊一個帳號，確認資料是否有成功寫進資料庫，密碼也有先經過 hash 才儲存：</p>
<p><img src="https://i.imgur.com/SVAu3GZ.png"></p>
<p>這樣就差不多完成了註冊功能：</p>
<p><img src="https://i.imgur.com/zJZMhbF.png"></p>
<h3 id="Step7-實作登入功能"><a href="#Step7-實作登入功能" class="headerlink" title="Step7. 實作登入功能"></a>Step7. 實作登入功能</h3><ol>
<li>再來要修改登入頁面 login.ejs，畫面和註冊頁面很類似：</li>
</ol>
<pre><code class="htmlmixed=">&lt;h1&gt;登入頁面&lt;/h1&gt;

&lt;h2&gt;&lt;%= errorMessage %&gt;&lt;/h2&gt;

&lt;form method=&quot;POST&quot; action=&quot;/login&quot;&gt;
  &lt;div&gt;username: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;/div&gt;
  &lt;div&gt;password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;/div&gt;
  &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;</code></pre>
<ol start="2">
<li>然後是 handleLogin，確認是否有填入帳密、確認資料是否正確，透過 bcrypt.compare() 驗證雜湊密碼：</li>
</ol>
<pre><code class="javascript=">  // 渲染登入畫面
  login: (req, res) =&gt; &#123;
    res.render(&#39;login&#39;)
  &#125;,

  // 驗證登入狀態
  handleLogin: (req, res, next) =&gt; &#123;
    const &#123; username, password &#125; = req.body;
    // 確認是否有填入資料
    if (!username || !password) &#123;
      req.flash(&#39;errorMessage&#39;, &#39;請輸入您的帳密！&#39;);
      // 每當呼叫 next 時，就會將控制權給下一個中間介 redirectBack(導回上一頁)
      return next();
    &#125;
    // 輸入正確就從 userModel 找出 user 資料
    userModel.get(username, (err, user) =&gt; &#123;
      if (err) &#123;
        req.flash(&#39;errorMessage&#39;, err.toString());
        return next();
      &#125;
      if (!user) &#123;
        req.flash(&#39;errorMessage&#39;, &#39;使用者不存在&#39;);
        return next();
      &#125;
      // 驗證密碼是否正確，三個參數代表: 明碼, 雜湊密碼, 方法
      bcrypt.compare(password, user.password, function (err, isSccess) &#123;
        // 若出現錯誤或比對不成功，就顯示錯誤訊息
        if (err || !isSccess) &#123;
          req.flash(&#39;errorMessage&#39;, &#39;密碼錯誤&#39;);
          return next();
        &#125;
        req.session.username = user.username;
        res.redirect(&#39;/&#39;)
      &#125;);
    &#125;)
  &#125;,

  // 登出: 清除 session 並導回首頁
  logout: (req, res) =&gt; &#123;
    req.session.username = null;
    res.redirect(&#39;/&#39;);
  &#125;</code></pre>
<ol start="3">
<li>在登入和註冊頁面，每當呼叫 next 時，就會將控制權給下一個中間介，可以自己寫一個中間介 redirectBack，用來在提交表單後自動導回上一頁：</li>
</ol>
<pre><code class="javascript=">// 自己寫的中間介，用來導回上一頁
function redirectBack(req, res, next) &#123;
  res.redirect(&#39;back&#39;)
&#125;

app.get(&#39;/register&#39;, userController.register)
app.post(&#39;/register&#39;, userController.handleRegister, redirectBack)
app.get(&#39;/login&#39;, userController.login)
app.post(&#39;/login&#39;, userController.handleLogin, redirectBack)
app.get(&#39;/logout&#39;, userController.logout)</code></pre>
<p>能夠根據未填欄位、或是資料輸入錯誤，顯示相對應的錯誤訊息：</p>
<p><img src="https://i.imgur.com/rS4BspM.png"></p>
<p>執行程式確認註冊和登入功能都沒問題的話，這樣就完成了簡易的會員註冊系統！藉由 MVC 架構，就能夠很清楚的分工，簡化程式邏輯。</p>
<hr>
<h2 id="實戰練習：有新增功能的簡易留言板"><a href="#實戰練習：有新增功能的簡易留言板" class="headerlink" title="實戰練習：有新增功能的簡易留言板"></a>實戰練習：有新增功能的簡易留言板</h2><p>再來要結合會員系統，實作一個有新增功能的簡易留言版。那麼就趕緊開始吧！</p>
<h3 id="Step1-規劃資料庫-1"><a href="#Step1-規劃資料庫-1" class="headerlink" title="Step1. 規劃資料庫"></a>Step1. 規劃資料庫</h3><p>在 app database 新增一個 comments table，以 username 欄位和 users table 進行關聯</p>
<p><img src="https://i.imgur.com/WcPt20O.png"></p>
<h3 id="Step2-新增留言區塊"><a href="#Step2-新增留言區塊" class="headerlink" title="Step2. 新增留言區塊"></a>Step2. 新增留言區塊</h3><p>在首頁 index.ejs 介面新增留言表單，如果是登入狀態，就能看到留言區塊：</p>
<pre><code class="htmlmixed=">&lt;h1&gt;簡易會員系統&lt;/h1&gt;

&lt;!-- 以是否有 username 來判斷是否登入 --&gt;
&lt;% if(username) &#123; %&gt;
  &lt;div&gt;Hello, &lt;%= username + &#39;!&#39; %&gt;&lt;/div&gt;
  &lt;a href=&quot;/logout&quot;&gt;登出&lt;/a&gt;

  &lt;form method=&quot;POST&quot; action=&quot;/comments&quot;&gt;
    &lt;textarea name=&quot;content&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;
    &lt;input type=&quot;submit&quot; /&gt;
  &lt;/form&gt;

&lt;% &#125; else &#123; %&gt;
  &lt;a href=&quot;/register&quot;&gt;註冊&lt;/a&gt;
  &lt;a href=&quot;/login&quot;&gt;登入&lt;/a&gt;
&lt;% &#125; %&gt;</code></pre>
<p>畫面看起來會是這個樣子：</p>
<p><img src="https://i.imgur.com/KbxPCEY.png"></p>
<h3 id="Step3-新增留言功能"><a href="#Step3-新增留言功能" class="headerlink" title="Step3. 新增留言功能"></a>Step3. 新增留言功能</h3><ol>
<li>新增路由：</li>
</ol>
<pre><code class="javascript=">const commentController = require(&#39;./controllers/comment&#39;);

// 提交表單來新增 comment，同樣以 redirectBack 來導回上一頁
app.post(&#39;/comments&#39;, commentController.add, redirectBack)</code></pre>
<ol start="2">
<li>建立 commentConrtoller 架構：</li>
</ol>
<pre><code class="javascript=">// 引入 commentModel
const commentModel = require(&#39;../models/comment&#39;)

const commentController = &#123;
  add: (req, res, next) =&gt; &#123;
    const &#123;username&#125; = req.session
    const &#123;content&#125; = req.body
    if (!username) &#123;
      req.flash(&#39;errorMessage&#39;, &#39;請先登入&#39;);
      return next();
    &#125;
    if (!content) &#123;
      req.flash(&#39;errorMessage&#39;, &#39;缺少必要欄位&#39;);
      return next();
    &#125;
    // 若新增失敗就導回首頁
    commentModel.add(username, content, err =&gt; &#123;
      return res.redirect(&#39;/&#39;);
    &#125;)
  &#125;
&#125;

// 輸出commentController
module.exports = commentController;
</code></pre>
<ol start="3">
<li>建立 commentModel 並新增 add，將表單提交內容寫入資料庫：</li>
</ol>
<pre><code class="javascript=">const commentModel = &#123;
  // 新增 comment 功能
  add: (username, content, cb) =&gt; &#123;
    db.query(
      &#39;INSERT INTO comments(username, content) VALUES(?, ?)&#39;,
      [username, content],
      (err, results) =&gt; &#123;
        if (err) return cb(err);
        cb(null);
      &#125;
    );
  &#125;
&#125;</code></pre>
<h3 id="Step4-讀取留言功能"><a href="#Step4-讀取留言功能" class="headerlink" title="Step4. 讀取留言功能"></a>Step4. 讀取留言功能</h3><ol>
<li>繼續在 commentModel 新增 getAll 來處讀取 username 資料，進行 users 和 comments 資料庫關聯：</li>
</ol>
<pre><code class="javascript=">  // 讀取 comment 功能
  getAll: (cb) =&gt; &#123;
    // 資料庫關聯
    db.query(
      `
      SELECT U.nickname, C.content FROM comments as C
      LEFT JOIN users as U on U.username = C.username       
      `,
      (err, results) =&gt; &#123;
      if (err) return cb(err);
      cb(null, results);
    &#125;);
  &#125;</code></pre>
<ol start="2">
<li>修改首頁 index 路由：</li>
</ol>
<pre><code class="javascript=">app.get(&#39;/&#39;, commentController.index)</code></pre>
<ol start="3">
<li>在 Controller 處理 index 頁面，讀取資料並進行渲染：</li>
</ol>
<pre><code class="javascript=">  // 在 index 頁面讀取資料
  index: (req, res) =&gt; &#123;
    commentModel.getAll((err, results) =&gt; &#123;
      if (err) &#123;
        console.log(err);
      &#125;
      res.render(&#39;index&#39;, &#123;
        comments: results;
      &#125;);
    &#125;);
  &#125;</code></pre>
<ol start="4">
<li>修改首頁 index.ejs 顯示留言部分：</li>
</ol>
<pre><code class="javascript=">&lt;% comments.forEach(function(comment) &#123; %&gt;
  &lt;div&gt;
    &lt;h2&gt;&lt;%= comment.nickname %&gt; &lt;%= comment.created_at %&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;%= comment.content %&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;% &#125;) %&gt;</code></pre>
<p>這樣其實就完成簡易的留言版了！但可以注意到，透過 EJS 語法輸出的時間，和我們預期的 <code>&#39;MMM-DD-YYYY&#39;</code> 格式不太相同：</p>
<p><img src="https://i.imgur.com/7BWBdzc.png"></p>
<h3 id="補充：透過-moment-js-修改時間格式"><a href="#補充：透過-moment-js-修改時間格式" class="headerlink" title="補充：透過 moment.js 修改時間格式"></a>補充：透過 moment.js 修改時間格式</h3><p>透過 <span class="exturl" data-url="aHR0cHM6Ly9tb21lbnRqcy5jb20v">moment.js<i class="fa fa-external-link-alt"></i></span> 這個套件，我們就能夠制定要輸出的時間日期格式，也能設定不同時區的時間。</p>
<ol>
<li>安裝 moment.js 套件：</li>
</ol>
<pre><code>npm install moment --save</code></pre>
<ol start="2">
<li>在 index.js 引入套件，並將 moment 和設定好的格式放入 locals，這樣就能在 View 使用：</li>
</ol>
<pre><code class="javascript=">// 引入 moment 套件
const moment = require(&#39;moment&#39;);
// 設定時間格式
const shortDateFormat = &quot;YYYY-MM-DD HH:mm:ss&quot;;
// 將 moment 和 shortDateFormat 放到 locals 全域環境中
app.locals.moment = moment;
app.locals.shortDateFormat = shortDateFormat;</code></pre>
<ol start="3">
<li>修改 index.ejs 的 View，用 moment 語法來輸出時間，也就是 <code>moment(&#39;datetime&#39;).format(&#39;模版&#39;)</code>，改寫如下：</li>
</ol>
<pre><code class="javascript=">&lt;% comments.forEach(function(comment) &#123; %&gt;
  &lt;div&gt;
    &lt;h2&gt;&lt;%= comment.nickname %&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;%= moment(comment.created_at).format(shortDateFormat) %&gt;&lt;/p&gt;
    &lt;p&gt;&lt;%= comment.content %&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;% &#125;) %&gt;</code></pre>
<p>這樣就成功把時間修改成 “YYYY-MM-DD h:mm:ss” 格式了！</p>
<p><img src="https://i.imgur.com/yiiWQeZ.png"></p>
<p>找了幾種引用 moment 的寫法，最後覺得這篇：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI3OTQ4NjAvaG93LXRvLXVzZS1ub2RlLW1vZHVsZXMtbGlrZS1tb21lbnRqcy1pbi1lanMtdmlld3M=">How to use node modules (like MomentJS) in EJS views?<i class="fa fa-external-link-alt"></i></span> 內容蠻符合需要的，也就是要如何透過 node 提供的套件來改變 EJS views，稍微嘗試過後，也成功將時間格式調整成想要的樣子！</p>
<hr>
<h2 id="實戰：優化留言板"><a href="#實戰：優化留言板" class="headerlink" title="實戰：優化留言板"></a>實戰：優化留言板</h2><p>在上述範例中，我們在完成了一個有新增功能簡易留言版，接下來我們要試著把系統變得更完整一點。</p>
<h3 id="Step1-思考產品全貌"><a href="#Step1-思考產品全貌" class="headerlink" title="Step1. 思考產品全貌"></a>Step1. 思考產品全貌</h3><p>在開始實作產品內容之前，需要先思考幾個重點：</p>
<ol>
<li>產品會有哪些功能：新增留言、編輯留言、刪除留言</li>
<li>如何設計路由<ul>
<li>刪除留言</li>
<li><code>GET /delete_comments/:id =&gt; /</code></li>
<li>編輯留言<ul>
<li>跳轉到編輯頁面 <code>GET /update_comments/:id =&gt; form</code></li>
<li>編輯完成提交 <code>POST /update_comments/:id =&gt; /</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Step2-規劃資料庫結構"><a href="#Step2-規劃資料庫結構" class="headerlink" title="Step2. 規劃資料庫結構"></a>Step2. 規劃資料庫結構</h3><p>規劃好系統功能和路由之後，再來就是規劃資料庫結構，這部分在先前的實作中就完成得差不多了。</p>
<p>在 users 和 comments table 中有個同樣的欄位 username，透過這個外鍵（Foreign Key），我們就能夠進行資料庫關聯，拿到想要的資料形式。</p>
<h3 id="Step3-實作刪除功能"><a href="#Step3-實作刪除功能" class="headerlink" title="Step3. 實作刪除功能"></a>Step3. 實作刪除功能</h3><ol>
<li>在 index.ejs 新增刪除按紐，並且只有留言本人才看得到刪除鍵：</li>
</ol>
<pre><code class="htmlmixed=">&lt;% comments.forEach(function(comment) &#123; %&gt;
  &lt;div&gt;
    &lt;h2&gt;&lt;%= comment.nickname %&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;%= moment(comment.created_at).format(shortDateFormat) %&gt;&lt;/p&gt;
    &lt;p&gt;&lt;%= comment.content %&gt;&lt;/p&gt;
    &lt;!-- 判斷使用者的 username 和 comment 的 username 是否相同--&gt;
    &lt;% if (username === comment.username) &#123;%&gt;
      &lt;!-- 只有本人才會看到刪除鍵 --&gt;
      &lt;a href=&quot;/delete_comments/&lt;%= comment.id %&gt;&quot;&gt;刪除&lt;/a&gt;
    &lt;% &#125; %&gt;
  &lt;/div&gt;
&lt;% &#125;) %&gt;</code></pre>
<ol start="2">
<li>修改 commentModel 來拿取需要的資料，也就是 comment table 的 id 和 username：</li>
</ol>
<pre><code class="javascript=">  // 讀取 comment 功能
  getAll: (cb) =&gt; &#123;
    // 資料庫關聯
    db.query(
      `
      SELECT U.nickname, U.created_at, C.content, C.id, C.username, C.created_at 
      FROM comments as C
      LEFT JOIN users as U on U.username = C.username
      ORDER BY C.created_at DESC       
      `,
      (err, results) =&gt; &#123;
      if (err) return cb(err);
      cb(null, results);
    &#125;);
  &#125;</code></pre>
<ol start="3">
<li>在 index.js 新增刪除留言的路由：</li>
</ol>
<pre><code class="javascript=">app.get(&#39;/delete_comments/:id&#39;, commentController.delete)</code></pre>
<ol start="4">
<li>新增控制 delete 的方法。注意這裡的參數除了網址列上的 id，也需傳入 session 以確認是否為該 comment 作者：：</li>
</ol>
<pre><code class="javascript=">  delete: (req, res) =&gt; &#123;
    // 除了網址列上的 id，也需傳入 session 以確認是否為該 comment 作者
    commentModel.delete(req.session.username, req.params.id, err =&gt; &#123;
      res.redirect(&#39;/&#39;);
    &#125;)
  &#125;</code></pre>
<ol start="5">
<li>實作 delete 的 commentModel 部分：</li>
</ol>
<pre><code class="javascript=">  delete: (username, id, cb) =&gt; &#123;
    db.query(
      `
        DELETE FROM comments WHERE id=? AND username=?
      `, [id, username], 
      (err, results) =&gt; &#123;
        if (err) return cb(err);
        cb(null);
    &#125;);  
  &#125;</code></pre>
<p>記得做好權限管裡，只有該則留言的’作者才能進行刪除：</p>
<p><img src="https://i.imgur.com/L9lV2x9.png"></p>
<h3 id="Step4-實作編輯功能"><a href="#Step4-實作編輯功能" class="headerlink" title="Step4. 實作編輯功能"></a>Step4. 實作編輯功能</h3><ol>
<li>同樣先從 View 部分開始，在 index.ejs 新增編輯按紐：</li>
</ol>
<pre><code class="htmlmixed=">    &lt;!-- 判斷使用者的 username 和 comment 的 username 是否相同--&gt;
    &lt;% if (username === comment.username) &#123;%&gt;
      &lt;a href=&quot;/update_comments/&lt;%= comment.id %&gt;&quot;&gt;編輯&lt;/a&gt;
      &lt;a href=&quot;/delete_comments/&lt;%= comment.id %&gt;&quot;&gt;刪除&lt;/a&gt;
    &lt;% &#125; %&gt;</code></pre>
<ol start="2">
<li>在 index.js 新增路由：</li>
</ol>
<pre><code class="javascript=">app.post(&#39;/comments&#39;, commentController.add, redirectBack)
app.get(&#39;/delete_comments/:id&#39;, commentController.delete)
// 讀取要編輯的 comment
app.get(&#39;/update_comments/:id&#39;, commentController.update)
// 執行修改 comment
app.post(&#39;/update_comments/:id&#39;, commentController.handleupdate)</code></pre>
<ol start="3">
<li>在新增 Controller 控制相對應的路由前，因為 update 需要讀取相對應 id 的 comment，因此需要在 Model 新增讀取單一 comment 的功能：</li>
</ol>
<pre><code class="javascript=">  // 讀取相對應 id 的 comment
  get: (id, cb) &#123;
    // 資料庫關聯
    db.query(
      `
      SELECT U.nickname, U.created_at, C.content, C.id, C.username, C.created_at 
      FROM comments as C
      LEFT JOIN users as U on U.username = C.username
      WHERE C.id = ?  
      `, [id],
      (err, results) =&gt; &#123;
        if (err) return cb(err);
        // 如果結果是 undefined 就會傳空物件，可避免程式出現錯誤
        cb(null, results[0] || &#123;&#125;);
      &#125;
    );
  &#125;,</code></pre>
<ol start="4">
<li>接著就可以繼續編輯 Controller 中的 update：</li>
</ol>
<pre><code class="javascript=">  update: (req, res) =&gt; &#123;
    commentModel.get(req.params.id, (err, result) =&gt; &#123;
      res.render(&#39;update&#39;, &#123;
        comment: result
      &#125;);
    &#125;);
  &#125;,</code></pre>
<ol start="5">
<li>再來實作 update 的 View 部分，因為直接修改網址就能進到這個頁面，要記得做驗證權限，必須是作者本人才能修改留言，這是透過前端處理：</li>
</ol>
<pre><code class="htmlmixed=">&lt;h1&gt;編輯留言&lt;/h1&gt;

&lt;a href=&quot;/&quot;&gt;返回&lt;/a&gt;

&lt;!-- 前端驗證 --&gt;
&lt;% if (username === comment.username) &#123; %&gt;
  &lt;form method=&quot;POST&quot; action=&quot;/update_comments/&lt;%= comment.id %&gt;&quot;&gt;
    &lt;textarea name=&quot;content&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;
    &lt;input type=&quot;submit&quot; /&gt;
  &lt;/form&gt;
&lt;% &#125; else &#123; %&gt;
  &lt;div&gt;ノンノンだよ！你沒有修改權限！&lt;/div&gt;
&lt;% &#125; %&gt;</code></pre>
<ul>
<li>有修改權限</li>
</ul>
<p><img src="https://i.imgur.com/GyCcRFg.png"></p>
<ul>
<li>沒有修改權限</li>
</ul>
<p><img src="https://i.imgur.com/J1iF7Ri.png"></p>
<ol start="6">
<li>最後剩下 handelUpdate 處理表單提交部分，首先是控制路由部分，透過比對 session 和 params.id 確認是否為本人，並傳入要修改的留言內容：</li>
</ol>
<pre><code class="javascript=">  handleUpdate: (req, res) =&gt; &#123;
    // 後端驗證: 必須是本人才有權限修改
    commentModel.update(req.session.username, req.params.id, req.body.content, err =&gt; &#123;
      res.redirect(&#39;/&#39;)
    &#125;);
  &#125;</code></pre>
<ol start="7">
<li>然後修改 Model 處理資料：</li>
</ol>
<pre><code class="javascript=">  update: (username, id, content, cb) =&gt; &#123;
  db.query(
    `
      UPDATE comments SET content=? WHERE  id=? AND username=?
    `, [content, id, username],
    (err, results) =&gt; &#123;
      if (err) return cb(err);
      cb(null);
    &#125;);
  &#125;</code></pre>
<p>這樣就完成具有新增、刪除和編輯功能的留言板了！再來我們要學習如何美化頁面，也就是 EJS 如何修改 template 來改變畫面。</p>
<h3 id="Step5-美化頁面"><a href="#Step5-美化頁面" class="headerlink" title="Step5. 美化頁面"></a>Step5. 美化頁面</h3><p>透過 <a href="(https://ejs.co/#install)">EJS</a> 提供的語法 <code>include()</code> 我們可以建立模版，獨立出每個頁面都有的元素，例如 head 和 navbar 等等，如此就能簡化程式碼，範例如下：</p>
<pre><code class="htmlmixed=">&lt;%- include(&#39;header&#39;); -%&gt;
&lt;h1&gt;
  Title
&lt;/h1&gt;
&lt;p&gt;
  My page
&lt;/p&gt;
&lt;%- include(&#39;footer&#39;); -%&gt;</code></pre>
<p>此外，include() 也可以傳入參數：</p>
<pre><code class="htmlmixed=">&lt;ul&gt;
  &lt;% users.forEach(function(user)&#123; %&gt;
    &lt;%- include(&#39;user/show&#39;, &#123;user: user&#125;); %&gt;
  &lt;% &#125;); %&gt;
&lt;/ul&gt;</code></pre>
<p>認識新語法之後，就來繼續修改畫面吧！</p>
<ol>
<li>首先在 index.ejs 加入 include() 語法，就像平常寫的 html 的架構。注意這裡的 <code>&lt;%- %&gt;</code> 是減號，代表會經過 html 解析：</li>
</ol>
<pre><code class="htmlmixed=">&lt;html&gt;
&lt;head&gt;
  &lt;%- include(&#39;template/head&#39;) %&gt;
&lt;/head&gt;

  &lt;h1&gt;簡易會員系統&lt;/h1&gt;

  &lt;h2&gt;&lt;%= errorMessage %&gt;&lt;/h2&gt;

  &lt;% if(username) &#123; %&gt;
  &lt;div&gt;Hello, &lt;%= username + &#39;!&#39; %&gt;&lt;/div&gt;
  &lt;a href=&quot;/logout&quot;&gt;登出&lt;/a&gt;

  &lt;form method=&quot;POST&quot; action=&quot;/comments&quot;&gt;
    &lt;textarea name=&quot;content&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;
    &lt;input type=&quot;submit&quot; /&gt;
  &lt;/form&gt;

  &lt;% &#125; else &#123; %&gt;
  &lt;a href=&quot;/register&quot;&gt;註冊&lt;/a&gt;
  &lt;a href=&quot;/login&quot;&gt;登入&lt;/a&gt;
  &lt;% &#125; %&gt;

  &lt;% comments.forEach(function(comment) &#123; %&gt;
  &lt;div&gt;
    &lt;h2&gt;&lt;%= comment.nickname %&gt;&lt;/h2&gt;
    &lt;p class=&quot;card-subtitle text-muted&quot;&gt;&lt;%= moment(comment.created_at).format(shortDateFormat) %&gt;&lt;/p&gt;
    &lt;p&gt;&lt;%= comment.content %&gt;&lt;/p&gt;
    &lt;% if (username === comment.username) &#123;%&gt;
    &lt;a href=&quot;/update_comments/&lt;%= comment.id %&gt;&quot;&gt;編輯&lt;/a&gt;
    &lt;a href=&quot;/delete_comments/&lt;%= comment.id %&gt;&quot;&gt;刪除&lt;/a&gt;
    &lt;% &#125; %&gt;
  &lt;/div&gt;
  &lt;% &#125;) %&gt;

&lt;/html&gt;</code></pre>
<ol start="2">
<li>再來編輯 head.ejs 部分，引入 <span class="exturl" data-url="aHR0cHM6Ly9nZXRib290c3RyYXAuY29tL2RvY3MvNC41L2dldHRpbmctc3RhcnRlZC9pbnRyb2R1Y3Rpb24v">Bootstrap<i class="fa fa-external-link-alt"></i></span> 提供的樣式和 meta tags：</li>
</ol>
<pre><code class="htmlmixed=">&lt;!-- Required meta tags --&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;

&lt;!-- Bootstrap CSS --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css&quot;
integrity=&quot;sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2&quot; crossorigin=&quot;anonymous&quot;&gt;</code></pre>
<p>成功引入之後，就會發現畫面套用了 Bootstrap 提供的樣式：</p>
<p><img src="https://i.imgur.com/EUjQqMo.png"></p>
<ol start="3">
<li>再來是 navbar，同樣在 index.ejs 中加上 include() 語法：</li>
</ol>
<pre><code class="htmlmixed=">&lt;%- include(&#39;template/navbar&#39;) %&gt;</code></pre>
<ol start="4">
<li>新增模版 navbar.ejs，可在 <span class="exturl" data-url="aHR0cHM6Ly9nZXRib290c3RyYXAuY29tL2RvY3MvNC41L2NvbXBvbmVudHMvbmF2YmFyLw==">Bootstrap/navbar<i class="fa fa-external-link-alt"></i></span> 找合適的模版來套用，並且把之前在 index.ejs 做的登入驗證同樣放到這裡，加上對應的路徑：</li>
</ol>
<pre><code class="htmlmixed=">&lt;nav class=&quot;navbar navbar-dark bg-dark&quot;&gt;
  &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot; &gt;這是一個留言版&lt;/a&gt;

  &lt;div&gt;
    &lt;% if(username) &#123; %&gt;
      &lt;div class=&quot;&quot;&gt;
        &lt;span class=&quot;text-light&quot;&gt;Hello, &lt;%= username + &#39;!&#39; %&gt;&lt;/span&gt;
        &lt;a class=&quot;btn btn-outline-light my-2 my-sm-0&quot; href=&quot;/logout&quot;&gt;登出&lt;/a&gt;
      &lt;/div&gt;
    &lt;% &#125; else &#123; %&gt;
      &lt;a class=&quot;btn btn-outline-light my-2 my-sm-0&quot; href=&quot;/login&quot;&gt;登入&lt;/a&gt;
      &lt;a class=&quot;btn btn-outline-warning my-2 my-sm-0&quot; href=&quot;/register&quot;&gt;註冊&lt;/a&gt;
    &lt;% &#125; %&gt;
  &lt;/div&gt;
&lt;/nav&gt;</code></pre>
<p>效果會長這樣：</p>
<p><img src="https://i.imgur.com/sepdlt7.png"></p>
<p>此外，像 head.ejs、navbar 這些通用模版，可放在 views/template 資料夾統一管理：</p>
<p><img src="https://i.imgur.com/2YdWdMx.png"></p>
<ol start="5">
<li>接著來修改註冊和登入頁面，同樣可在 Bootstrap 找合適的 <span class="exturl" data-url="aHR0cHM6Ly9nZXRib290c3RyYXAuY29tL2RvY3MvNC41L2NvbXBvbmVudHMvZm9ybXMv">forms<i class="fa fa-external-link-alt"></i></span> 版型：</li>
</ol>
<ul>
<li>register.ejs 註冊頁面</li>
</ul>
<pre><code class="htmlmixed=">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;%- include(&#39;../template/head&#39;) %&gt;
&lt;/head&gt;
  &lt;%- include(&#39;../template/navbar&#39;) %&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;!-- 若沒有錯誤會回傳一個空陣列 [] --&gt;
    &lt;% if (errorMessage.length &gt; 0) &#123; %&gt;
      &lt;div class=&quot;alert alert-danger&quot; role=&quot;alert&quot;&gt;
        &lt;%= errorMessage %&gt;
      &lt;/div&gt;
    &lt;% &#125; %&gt;
    &lt;form method=&quot;POST&quot; action=&quot;/register&quot;&gt;
      &lt;div class=&quot;form-group row&quot;&gt;
        &lt;label class=&quot;col-sm-2 col-form-label&quot;&gt;Username: &lt;/label&gt;
        &lt;div class=&quot;col-sm-10&quot;&gt;
          &lt;input class=&quot;form-control&quot; name=&quot;username&quot;&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group row&quot;&gt;
        &lt;label class=&quot;col-sm-2 col-form-label&quot;&gt;Nickname: &lt;/label&gt;
        &lt;div class=&quot;col-sm-10&quot;&gt;
          &lt;input class=&quot;form-control&quot; name=&quot;nickname&quot;&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group row&quot;&gt;
        &lt;label class=&quot;col-sm-2 col-form-label&quot;&gt;Password: &lt;/label&gt;
        &lt;div class=&quot;col-sm-10&quot;&gt;
          &lt;input class=&quot;form-control&quot; name=&quot;password&quot; type=&quot;password&quot;&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;button type=&quot;submit&quot; class=&quot;btn btn-dark mb-2&quot;&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  &lt;/div&gt;
&lt;/html&gt;</code></pre>
<ul>
<li>login.ejs 登入頁面</li>
</ul>
<pre><code class="htmlmixed=">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;%- include(&#39;../template/head&#39;) %&gt;
&lt;/head&gt;
  &lt;%- include(&#39;../template/navbar&#39;) %&gt;

  &lt;div class=&quot;container&quot;&gt;
    &lt;!-- 若沒有錯誤會回傳一個空陣列 [] --&gt;
    &lt;% if (errorMessage.length &gt; 0) &#123; %&gt;
    &lt;div class=&quot;alert alert-danger&quot; role=&quot;alert&quot;&gt;
      &lt;%= errorMessage %&gt;
    &lt;/div&gt;
    &lt;% &#125; %&gt;
    &lt;form method=&quot;POST&quot; action=&quot;/login&quot;&gt;
      &lt;div class=&quot;form-group row&quot;&gt;
        &lt;label class=&quot;col-sm-2 col-form-label&quot;&gt;Username: &lt;/label&gt;
        &lt;div class=&quot;col-sm-10&quot;&gt;
          &lt;input class=&quot;form-control&quot; name=&quot;username&quot;&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group row&quot;&gt;
        &lt;label class=&quot;col-sm-2 col-form-label&quot;&gt;Password: &lt;/label&gt;
        &lt;div class=&quot;col-sm-10&quot;&gt;
          &lt;input class=&quot;form-control&quot; name=&quot;password&quot; type=&quot;password&quot;&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;button type=&quot;submit&quot; class=&quot;btn btn-dark mb-2&quot;&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  &lt;/div&gt;

&lt;/html&gt;</code></pre>
<p>兩者寫法其實差不多，只有欄位和路徑需要修改，畫面效果如下：</p>
<p><img src="https://i.imgur.com/ySLeqVp.png"></p>
<ol start="6">
<li>再來是首頁 index.ejs，同樣幫 forms 還有留言卡套用樣式：</li>
</ol>
<pre><code class="htmlmixed=">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;%- include(&#39;template/head&#39;) %&gt;
&lt;/head&gt;
  &lt;%- include(&#39;template/navbar&#39;) %&gt;

  &lt;div class=&quot;container mx-auto mt-3&quot; style=&quot;width: 100%;&quot;&gt;
    &lt;% if (errorMessage.length &gt; 0) &#123; %&gt;
    &lt;div class=&quot;alert alert-danger&quot; role=&quot;alert&quot;&gt;
      &lt;%= errorMessage %&gt;
    &lt;/div&gt;
    &lt;% &#125; %&gt;

    &lt;% if(username) &#123; %&gt;
    &lt;form method=&quot;POST&quot; action=&quot;/comments&quot;&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;div class=&quot;text-dark&quot;&gt;留言內容&lt;/div&gt;
        &lt;textarea name=&quot;content&quot; class=&quot;form-control&quot;&gt;&lt;/textarea&gt;
      &lt;/div&gt;
      &lt;button type=&quot;submit&quot; class=&quot;btn btn-dark&quot;&gt;提交&lt;/button&gt;
    &lt;/form&gt;
    &lt;% &#125; else &#123; %&gt;
      &lt;div class=&quot;alert alert-warning&quot; role=&quot;alert&quot;&gt;留言請先登入&lt;/div&gt;
    &lt;% &#125; %&gt;

    &lt;div class=&quot;card-container d-flex flex-wrap&quot;&gt;
      &lt;% comments.forEach(function(comment) &#123; %&gt;
        &lt;div class=&quot;card m-2&quot; style=&quot;width: 18rem; height: 16rem;&quot;&gt;
          &lt;div class=&quot;card-header&quot;&gt;
            &lt;h5 class=&quot;card-title&quot;&gt;&lt;%= comment.nickname %&gt;&lt;/h5&gt;
            &lt;h6 class=&quot;card-subtitle text-muted&quot;&gt;&lt;%= moment(comment.created_at).format(shortDateFormat) %&gt;&lt;/h6&gt;
            &lt;% if (username === comment.username) &#123;%&gt;
            &lt;a href=&quot;/update_comments/&lt;%= comment.id %&gt;&quot; class=&quot;card-link&quot;&gt;編輯&lt;/a&gt;
            &lt;a href=&quot;/delete_comments/&lt;%= comment.id %&gt;&quot; class=&quot;card-link&quot;&gt;刪除&lt;/a&gt;
            &lt;% &#125; %&gt;
          &lt;/div&gt;
          &lt;div class=&quot;card-body&quot; style=&quot;overflow:scroll; overflow-x:hidden;&quot;&gt;
            &lt;p class=&quot;card-text&quot; &gt;&lt;%= comment.content %&gt;&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;% &#125;) %&gt;
    &lt;/div&gt;

  &lt;/div&gt;
&lt;/html&gt;</code></pre>
<p>效果如下：</p>
<p><img src="https://i.imgur.com/AVp2KF7.png"></p>
<ol start="6">
<li>最後是編輯留言頁面 update.ejs，也和其他頁面版型差不多：</li>
</ol>
<pre><code class="htmlmixed=">&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
  &lt;%- include(&#39;template/head&#39;) %&gt;
&lt;/head&gt;
  &lt;%- include(&#39;template/navbar&#39;) %&gt;

  &lt;div class=&quot;container mx-auto mt-4&quot; style=&quot;width: 100%;&quot;&gt;
    &lt;!-- 若沒有錯誤會回傳一個空陣列 [] --&gt;
    &lt;% if (errorMessage.length &gt; 0) &#123; %&gt;
    &lt;div class=&quot;alert alert-danger&quot; role=&quot;alert&quot;&gt;
      &lt;%= errorMessage %&gt;
    &lt;/div&gt;
    &lt;% &#125; %&gt;

    &lt;% if (username === comment.username) &#123; %&gt;
      &lt;form method=&quot;POST&quot; action=&quot;/update_comments/&lt;%= comment.id %&gt;&quot;&gt;
        &lt;div class=&quot;form-group&quot;&gt;
          &lt;div class=&quot;text-dark&quot;&gt;編輯留言&lt;/div&gt;
          &lt;textarea name=&quot;content&quot; class=&quot;form-control&quot;&gt;&lt;/textarea&gt;
        &lt;/div&gt;
        &lt;button type=&quot;submit&quot; class=&quot;btn btn-dark&quot;&gt;提交&lt;/button&gt;
      &lt;/form&gt;
    &lt;% &#125; else &#123; %&gt;
      &lt;div&gt;ノンノンだよ！你沒有修改權限！&lt;/div&gt;
    &lt;% &#125; %&gt;
  &lt;/div&gt;

&lt;/html&gt;</code></pre>
<p><img src="https://i.imgur.com/1JoojMH.png"></p>
<p>透過這個範例，我們學到該如何使用 include() 語法來引入模板，如此就能簡化程式碼，將重複使用的區塊給模組化；此外，也透過 BootStrap 提供的現成樣式，讓我們能快速修改頁面，達到想要的畫面效果。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>實際跟著範例操作之後，會發現透過 MVC 模式撰寫程式，思考邏輯會很類似。使用 Express 框架實作網頁時，會依照下方流程進行：</p>
<ol>
<li>思考產品全貌：哪些功能？哪些路由？</li>
<li>規劃資料庫結構</li>
<li>載入需要的模組，設定 app 路由部分</li>
<li>依照 MVC 架構撰寫程式碼：<ul>
<li>設定 Controller：針對不同路由進行控制</li>
<li>設定 Model：如何處理資料</li>
<li>設定 View：如何呈現畫面</li>
</ul>
</li>
</ol>
<p>也藉這個機會來複習 BootStrap 使用方式，這和之前「先刻版面再加入功能」的模式正好相反，反而是先把功能做好，再套用現有樣式，這也是藉由 MVC 將畫面和功能分割開來才能夠辦到。</p>
<p>在學會如何寫出一個簡單的會員註冊系統和留言版之後，其實就能夠應用到各種網頁，期待之後能夠熟悉 MVC 架構的寫法！</p>
]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>Back-End</tag>
        <tag>Express</tag>
        <tag>Middleware</tag>
      </tags>
  </entry>
  <entry>
    <title>[week 2] JavaScript 基礎 - 基本語法、值的型別、變數、迴圈、函數</title>
    <url>/javascript/</url>
    <content><![CDATA[<blockquote>
<p>本篇為 <span class="exturl" data-url="aHR0cHM6Ly9saWRlbXkuY29tL3AvanMxMDEtamF2YXNjcmlwdA==">[JS101] 用 JavaScript 一步步打造程式基礎<i class="fa fa-external-link-alt"></i></span> 這門課程的學習筆記。如有錯誤歡迎指正！</p>
</blockquote>
<pre><code>學習目標：

 P1 你能靈活運用變數、迴圈、判斷式等等基本概念來解題
 P1 你能一行行的說出現在程式在做什麼
 P1 你知道「回傳」跟「輸出」的差異
 P1 你可以把用文字寫好的演算法轉成程式碼</code></pre>
<a id="more"></a>
<hr>
<h2 id="JavaScript-是什麼？"><a href="#JavaScript-是什麼？" class="headerlink" title="JavaScript 是什麼？"></a>JavaScript 是什麼？</h2><p>JavaScript 是一種物件導向（Object-oriented programming）的腳本語言（Script language），主要用來改進 Web 瀏覽器的客戶端體驗。</p>
<p>腳本語言是一種直譯語言，因不需進行編譯，在撰寫和除錯上較為方便；但缺點是執行效率比不上編譯語言，且無法單獨執行，必須仰賴運行環境。例如：HTML 網頁中的 JavaScript 需要瀏覽器支援才能執行。</p>
<p>直到 Node.js 出現後，提供了 JavaScript 在瀏覽器以外的運行環境。目前實務開發中，通常使用瀏覽器的開發者工具來進行 debug（除錯）。</p>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cDovL3Rlc3QuZG9tb2p5dW4ubmV0L01FTU8vSmF2YVNjcmlwdC8=">JavaScript 基本認識 - JavaScript 入門學習筆記<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0B0b3Rvcm9MaXUvJUU3JUI3JUE4JUU4JUFEJUFGJUU4JUFBJTlFJUU4JUE4JTgwLXZzLSVFNyU5QiVCNCVFOCVBRCVBRiVFOCVBQSU5RSVFOCVBOCU4MC01ZjM0ZTZiYWUwNTE=">編譯語言 VS 直譯語言- Po-Ching Liu - Medium<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2NvZGVtZW1vLyVFNSVCRiU4MyVFNSVCRSU5NyVFNSU4OCU4NiVFNCVCQSVBQi1qcy0lRTUlQjAlODglRTclODIlQkElRTclODAlOEYlRTglQTYlQkQlRTUlOTklQTglRTglODAlOEMlRTclOTQlOUYlRTclOUElODQtc2NyaXB0LSVFOCU4NSVCMyVFNiU5QyVBQyVFOCVBQSU5RSVFOCVBOCU4MC02MGE2Mjg5ODg3MTA=">[心得分享] JS = 專為瀏覽器而生的 script (腳本語言)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rcy5nb29nbGUuY29tLnR3L2Jvb2tzP2lkPThKXzNCUUFBUUJBSiZwZz1TQTEtUEE1JmxwZz1TQTEtUEE1JmRxPSVFOCU4NSVCMyVFNiU5QyVBQyVFOCVBQSU5RSVFOCVBOCU4MCVFNiU5OCVBRiVFNCVCOCU4MCVFNyVBOCVBRSVFNyU5QiVCNCVFOCVBRCVBRiVFOCVBQSU5RSVFOCVBOCU4MCVFRiVCQyU4QyZzb3VyY2U9Ymwmb3RzPW9IbkJMMUNHbnkmc2lnPUFDZlUzVTBoZ1diLW1uZWpSR1gyWmhzQ2xvYnhhZlVucUEmaGw9emgtVFcmc2E9WCZ2ZWQ9MmFoVUtFd2lEMVo3UThJX3FBaFhNdzRzQkhVM0lEbzBRNkFFd0JYb0VDQWtRQVEjdj1vbmVwYWdlJnE9JUU4JTg1JUIzJUU2JTlDJUFDJUU4JUFBJTlFJUU4JUE4JTgwJUU2JTk4JUFGJUU0JUI4JTgwJUU3JUE4JUFFJUU3JTlCJUI0JUU4JUFEJUFGJUU4JUFBJTlFJUU4JUE4JTgwJUVGJUJDJThDJmY9ZmFsc2U=">JavaScript+jQuery Mobile+Node.js跨平台網頁設計範例教本(電子書)<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<h2 id="Node-js-環境建置"><a href="#Node-js-環境建置" class="headerlink" title="Node.js 環境建置"></a>Node.js 環境建置</h2><blockquote>
<p>進入<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">官網<i class="fa fa-external-link-alt"></i></span>會看到下列文字：<br>Node.js® is a JavaScript ==runtime== built on Chrome’s V8 JavaScript engine.<br>（Node.js 一個能執行 JavaScript 的==運行環境==，以 Google Chrome V8 引擎為核心。）</p>
</blockquote>
<p>安裝完成後，就可以在 Command Line 輸入指令：</p>
<h3 id="node-v：查看目前-Node-js-版本號"><a href="#node-v：查看目前-Node-js-版本號" class="headerlink" title="node -v：查看目前 Node.js 版本號"></a><code>node -v</code>：查看目前 Node.js 版本號</h3><p>出現版本號就代表安裝成功。</p>
<p><img src="https://i.imgur.com/IXXGrb0.png"></p>
<h3 id="node：直接在-CML-開啟-Node-環境"><a href="#node：直接在-CML-開啟-Node-環境" class="headerlink" title="node：直接在 CML 開啟 Node 環境"></a><code>node</code>：直接在 CML 開啟 Node 環境</h3><p>可在終端機輸入指令。按 Crtl+C 或輸入就<code>.exit</code> 即可退出。</p>
<p><img src="https://i.imgur.com/L3DJaob.png"></p>
<hr>
<h2 id="如何執行-JavaScript-文件？"><a href="#如何執行-JavaScript-文件？" class="headerlink" title="如何執行 JavaScript 文件？"></a>如何執行 JavaScript 文件？</h2><h3 id="在瀏覽器執行"><a href="#在瀏覽器執行" class="headerlink" title="在瀏覽器執行"></a>在瀏覽器執行</h3><ol>
<li>寫在 HTML 文件中的 <code>&lt;script &gt;</code> 標籤內</li>
</ol>
<p><img src="https://i.imgur.com/r1gMPnm.png" alt="HTML JS"></p>
<ol start="2">
<li>用瀏覽器開啟該檔案，點選右鍵選單的檢查，進入開發者工具介面</li>
<li>可在 Console 主控台檢視或直接撰寫。通常用來測試代碼的可行性、或直接 debug 抓錯</li>
</ol>
<p><img src="https://i.imgur.com/1U5LzRD.png" alt="Google JS"></p>
<h3 id="在-Command-Line-執行"><a href="#在-Command-Line-執行" class="headerlink" title="在 Command Line 執行"></a>在 Command Line 執行</h3><ol>
<li><code>vim index.js</code>：輸入 vim 指令建立檔案 index.js，並且編輯內容</li>
</ol>
<blockquote>
<p>也可使用 VSCode、Sublime 等程式碼編輯器來撰寫程式碼</p>
</blockquote>
<p><img src="https://i.imgur.com/4392JMK.png" alt="vim 介面"></p>
<ol start="2">
<li><code>node index.js</code>：在 CML 執行檔案 index.js</li>
</ol>
<p><img src="https://i.imgur.com/zkJPsbj.png" alt="node 執行"></p>
<hr>
<h2 id="基本語法"><a href="#基本語法" class="headerlink" title="基本語法"></a>基本語法</h2><h3 id="console-log-：將值輸出到瀏覽器控制台"><a href="#console-log-：將值輸出到瀏覽器控制台" class="headerlink" title="console.log()：將值輸出到瀏覽器控制台"></a>console.log()：將值輸出到瀏覽器控制台</h3><p>若要輸出字串，需用 ‘單引號’ 或 “雙引號” 括起來。</p>
<p><code>console.log(’Hello World’)　　//　輸出值：Hello World</code></p>
<h3 id="算術運算"><a href="#算術運算" class="headerlink" title="算術運算"></a>算術運算</h3><p><code>+</code>：加<br><code>-</code>：減<br><code>*</code>：乘<br><code>/</code>：除<br><code>%</code>：取餘數（例如 10 % 3，結果是 1）</p>
<h3 id="邏輯運算"><a href="#邏輯運算" class="headerlink" title="邏輯運算"></a>邏輯運算</h3><ul>
<li>邏輯運算子常在 if 判斷式中和布林值（true or false）一起使用</li>
<li>在 JavaScript 中會被判定為 false 的值為：<code>0</code>、<code>&quot;&quot;</code>、<code>null</code>、<code>false</code>、<code>undefined</code>、<code>NaN</code></li>
</ul>
<h4 id="：or"><a href="#：or" class="headerlink" title="||：or"></a><code>||</code>：or</h4><p>只要其中一個是 true 就會返回 true，除非全部為 false。意即只要其中一個條件滿足就成立。</p>
<p><img src="https://i.imgur.com/v0j07Ua.png" alt="or"></p>
<h4 id="amp-amp-：and"><a href="#amp-amp-：and" class="headerlink" title="&amp;&amp;：and"></a><code>&amp;&amp;</code>：and</h4><p>全部為 true 才會是 true，否則均返回 false。意即全部條件都必須成立。</p>
<p><img src="https://i.imgur.com/dbhRafe.png" alt="and"></p>
<h4 id="：not"><a href="#：not" class="headerlink" title="!：not"></a><code>!</code>：not</h4><p>做反向。</p>
<p><img src="https://i.imgur.com/2scURgc.png" alt="!"></p>
<h3 id="與-amp-amp-的短路性質"><a href="#與-amp-amp-的短路性質" class="headerlink" title="|| 與 &amp;&amp; 的短路性質"></a><code>||</code> 與 <code>&amp;&amp;</code> 的短路性質</h3><p>使用最短的路徑來求值，又稱<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTlGJUFEJUU4JUI3JUFGJUU2JUIxJTgyJUU1JTgwJUJD">短路求值<i class="fa fa-external-link-alt"></i></span>。只有當第一個運算數的值無法確定邏輯運算的結果時，才對第二個運算數進行求值。例如：</p>
<pre><code>1. 當 or 的第一個運算數為 true 時，最後結果必定為 true
2. 當 and 的第一個運算數的值為 false 時，其結果必定為 false</code></pre>
<p>在這種情況下，就不需要知道第二個運算數的具體值。也就是短路性質。</p>
<p>範例：</p>
<pre><code>console.log(3 || 10)　　　　//　output 3
console.log(false || 10)　　//　output 10
console.log(3 &amp;&amp; 10)　　　　　//　output 10
console.log(false &amp;&amp; 3)　　//　output false</code></pre>
<p><code>var obj = obj || &#123; &#125;;　　//　如果 obj 存在就維持原樣，如果不存在就給予空物件</code></p>
<p><code>var student = name || &quot;小明&quot;;　　//　如果沒有 name 就用預設為小明。用 || 來設定變數預設值</code></p>
<blockquote>
<p>更多短路邏輯的運用可參考這篇：<span class="exturl" data-url="aHR0cHM6Ly9zd2VldGVhc29uLnBpeG5ldC5uZXQvYmxvZy9wb3N0LzQzMDIyOTIxLWphdmFzY3JpcHQtJUU1JTlGJUJBJUU3JUE0JThFJUU2JTg5JTkzJUU1JUJBJTk1JUU3JUIzJUJCJUU1JTg4JTk3LSUyOCVFNCVCOCU4OSUyOS0tLSVFOSU4MiU4RiVFOCVCQyVBRiVFOSU4MSU4QiVFNyVBRSU5NyVFNSVBRCU5MCVFRiVCQyU4QyVFOCU4OCU4Nw==">想知道&amp;&amp;與&amp;及||與|之間的區別嗎？ | 程式前沿<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="位移運算子：-lt-lt-與-gt-gt"><a href="#位移運算子：-lt-lt-與-gt-gt" class="headerlink" title="位移運算子：&lt;&lt; 與 &gt;&gt;"></a>位移運算子：<code>&lt;&lt;</code> 與 <code>&gt;&gt;</code></h3><p>首先來複習二進位制：</p>
<p>0100 = 2^3<em>0 + 2^2</em>1 + 2^1<em>0 + 2^0</em>0 = 2^2 = 4<br>1000 = 2^3<em>1 + 2^2</em>0 + 2^1<em>0 + 2^0</em>0 = 2^3 = 8</p>
<h4 id="lt-lt-：將位元往左移一位，可作為乘以-2。"><a href="#lt-lt-：將位元往左移一位，可作為乘以-2。" class="headerlink" title="&lt;&lt;：將位元往左移一位，可作為乘以 2。"></a>&lt;&lt;：將位元往左移一位，可作為乘以 2。</h4><p><img src="https://i.imgur.com/7f9YfSO.png" alt="&lt;&lt; 左移"></p>
<h4 id="gt-gt-：將位元往右移一位，可作為除以-2。若無法整除則會直接捨去。"><a href="#gt-gt-：將位元往右移一位，可作為除以-2。若無法整除則會直接捨去。" class="headerlink" title="&gt;&gt;：將位元往右移一位，可作為除以 2。若無法整除則會直接捨去。"></a>&gt;&gt;：將位元往右移一位，可作為除以 2。若無法整除則會直接捨去。</h4><p><img src="https://i.imgur.com/RP4O8zV.png" alt="&gt;&gt; 右移"></p>
<ul>
<li>由於電腦使用的是二進位系統，位元運算的速度通常會快於乘法和除法運算。</li>
</ul>
<h3 id="位元運算"><a href="#位元運算" class="headerlink" title="位元運算"></a>位元運算</h3><p>and<br>or<br>xor<br>not<br>(待補)</p>
<hr>
<h3 id="遞增、遞減運算子：-與"><a href="#遞增、遞減運算子：-與" class="headerlink" title="遞增、遞減運算子：++ 與 --"></a>遞增、遞減運算子：<code>++</code> 與 <code>--</code></h3><pre><code>var a = 0　　//　等號是賦值
a = a + 1　　//　可簡化為　a += 1 或 a++
a = a - 1　　//　可簡化為　a -= 1 或 a--</code></pre>
<h4 id="遞增（-，increment）：運算前或運算後「遞增」"><a href="#遞增（-，increment）：運算前或運算後「遞增」" class="headerlink" title="遞增（++，increment）：運算前或運算後「遞增」"></a>遞增（<code>++</code>，increment）：運算前或運算後「遞增」</h4><h4 id="遞減（-，decrement）：運算前或運算後「遞減」"><a href="#遞減（-，decrement）：運算前或運算後「遞減」" class="headerlink" title="遞減（--，decrement）：運算前或運算後「遞減」"></a>遞減（<code>--</code>，decrement）：運算前或運算後「遞減」</h4><blockquote>
<p>其中以 ++ 運算子為例：</p>
</blockquote>
<p>++ 運算子的回傳值，取決於相對於運算元的位置。</p>
<ol>
<li>先遞增（<code>++a</code>）：用在運算元之前，執行遞增，然後回傳遞增後的值。</li>
<li>後遞增（<code>a++</code>）：用在運算元後方，執行遞增，然後回傳未遞增前的值。</li>
</ol>
<pre><code>var i = 1, j = ++i　　//　i 與 j 兩者皆為 2
var i = 1, j = i++　　//　i 為 2, j 是 1　</code></pre>
<blockquote>
<p>若以邏輯運算為例：</p>
</blockquote>
<ol>
<li>先遞增<pre><code>var a = 0
</code></pre>
</li>
</ol>
<p>console.log(++a &amp;&amp; 30)　　　//　印出 30，此時 a 為 1<br>console.log(‘a:’ , a)　　　//　 印出 a:1</p>
<p>//　先跑 a+=1，再 console.log(a &amp;&amp; 30)</p>
<pre><code>2. 後遞增
</code></pre>
<p>var a = 0</p>
<p>console.log(a++ &amp;&amp; 30)　　　//　印出 0，此時 a 為 0<br>console.log(‘a:’ , a)　　　//　 印出 a:1</p>
<p>//　先跑 console.log(a &amp;&amp; 30)，再 a+=1</p>
<pre><code>
---

## 值的型態

### JavaScript 的資料型態可分為：

- 原始型態（primitive types）

1. boolean（真偽值）：ture 和 false
2. number（數字）：例如 1、3.14159、NaN（無效的數字）
3. string（字串）：例如 `&#39;Hello World&#39;`
4. null：沒有值存在（no value）
5. undefined：值不存在（absence） 

- 其他都屬於物件型態（object types）
1. array（陣列）：例如 [1, 2, 3]
2. function（函式）
3. date...etc

### `typeof &lt;value&gt;`：用來判斷參數型態
</code></pre>
<p>console.log(‘typeof true’, typeof true)<br>//輸出 typeof true boolean</p>
<pre><code>
![](https://i.imgur.com/rT6DR1N.png)

在 [MDN 網站](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/typeof) 列出 typeof 的可能回傳值：

![](https://4.bp.blogspot.com/-dBndQxibqJ8/V3xngW8lK5I/AAAAAAAAnDU/L5PVWe-8j-gL3vzcA4xMznzsgqq4AcnkACLcB/s1600/1.png)

&gt; null 使用 typeof 運算子，回傳的結果會是字串 &quot;object&quot;，這指出 null 可被認為是象徵「無物件」（no object）的一種特殊物件值。（參考資料：[犀牛書](https://www.tenlong.com.tw/products/9789862764411)）
&gt; 
&gt; 這其實是 JavaScript 最初發現的一個錯誤，然後被 ECMAScript 沿用了。現在，null 被認為是物件的佔位符，從而解釋了這一矛盾
&gt; （參考資料：[你懂JavaScript 嗎？#4 型別（Types） ](https://ithelp.ithome.com.tw/articles/10200841)）

---

## 變數（Variable）

- 用來暫時儲存資料的地方
- 想像成裝東西的箱子，`宣告變數`是將這個箱子取名，`加上等號賦值`是在裡面裝東西
</code></pre>
<p>其他情形：</p>
<ol>
<li>當宣告變數，卻沒有給這個變數賦值，用 console.log 會印出 undefined</li>
<li>若想印出一個沒有宣告的文字，會出現錯誤訊息 not defined<pre><code></code></pre>
</li>
</ol>
<h3 id="宣告變數"><a href="#宣告變數" class="headerlink" title="宣告變數"></a>宣告變數</h3><ul>
<li>不可用數字開頭</li>
<li>不可取名為<span class="exturl" data-url="aHR0cDovL3d3dy53M2JhaS5jb20vemgtVFcvanMvanNfcmVzZXJ2ZWQuaHRtbA==">保留字詞<i class="fa fa-external-link-alt"></i></span>，例如 var、function、for </li>
<li>變數盡量用語譯化的方式命名，例如 peopleCount、total</li>
<li>變數的取名規則需統一，可分為下列兩種：</li>
</ul>
<ol>
<li>蛇式命名（snake_case）:名稱中間的標點以底線連接<br><code>var this_is_a_box</code></li>
<li>駝峰式命名（camelCase）:除了第一個單詞外，後面的單詞首字母均為大寫<br><code>var thisIsABox</code></li>
</ol>
<h3 id="變數的儲存模型"><a href="#變數的儲存模型" class="headerlink" title="變數的儲存模型"></a>變數的儲存模型</h3><p>前面提到變數是像箱子的儲存模型，參考 Huli 寫的<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BodWxpdHcvdmFyaWFibGUtYW5kLWZyb250ZGVzay1hNTNhMDQ0MGFmM2M=">這篇文章<i class="fa fa-external-link-alt"></i></span>，舉以下範例來說明其特性：</p>
<pre><code>// 範例一

var A = [1, 2, 3]
var B = [1, 2, 3]
var C = A
console.log(A == B)　　　// 回傳 false
console.log(C == B)　　　// 回傳 false
console.log(C == A)　　　// 回傳 true</code></pre>
<ol>
<li>即使代表的東西相同，但 A 和 B 其實存放在不同的格子，而 A 和 C 相同。</li>
<li><code>==</code> 與 <code>===</code> 是去看「格子的內容」是否相等，而不是檢查「所代表的東西」是否相等。</li>
</ol>
<pre><code>// 範例二

var F = [1, 2, 3]
var G = F

// 往裡面放東西
F.push(4)　　　　　　　　
console.log(F, G)　　　// 回傳 [1, 2, 3, 4] [1, 2, 3, 4]

// 改放全新的東西
F = [1, 3, 5]　　　　　
console.log(F, G)　　　// 回傳 [1, 3, 5] [1, 2, 3, 4]</code></pre>
<ol>
<li>「往裡面放東西」與「改放全新的東西」是兩件完全不同的事情。</li>
<li>一般的變數存資訊，物件存記憶體位置。</li>
</ol>
<ul>
<li>一般的變數：變數裡面存的內容就真的是那個資訊，例如：數字、字串</li>
<li>物件：變數裡面存的內容其實是「指引」，指引存的是記憶體位置，例如：陣列或物件</li>
</ul>
<h3 id="變數的運算"><a href="#變數的運算" class="headerlink" title="變數的運算"></a>變數的運算</h3><ul>
<li>注意值的型態：字串和數字相加時，會變成字串相加</li>
</ul>
<pre><code>var a = &#39;10&#39;https://www.bilibili.com/video/BV1Hz411i7ph/
var b = 20
console.log(a + b)　　　// 印出 1020</code></pre>
<p>解決方法：</p>
<ol>
<li><code>console.log(Number(a) + b)</code>：用 <code>Number()</code> 將字串轉成數字</li>
<li><code>console.log(parseInt(a, 10) + b)</code>：用 <code>parseInt()</code> 將字串轉換成整數，10 代表預設的十進位 </li>
</ol>
<ul>
<li>注意<span class="exturl" data-url="aHR0cDovL2Jsb2cuZGN2aWV3LmNvbS9hcnRpY2xlLnBocD9hPVZtaFFOVlkrQ3pvPQ==">浮動數誤差<i class="fa fa-external-link-alt"></i></span>：電腦在儲存小數值可能會產生誤差</li>
</ul>
<pre><code>var a = 0.1 + 0.2
console.log(a == 0.3)　　　// 印出 false
console.log(a)            // 印出 0.30000000000000004
</code></pre>
<h3 id="萬年經典題：-與"><a href="#萬年經典題：-與" class="headerlink" title="萬年經典題：== 與 ==="></a>萬年經典題：<code>==</code> 與 <code>===</code></h3><p><code>=</code>：代表賦值<br><code>==</code> 和 <code>===</code>：均用來判斷是否相等</p>
<pre><code>var a = 10 == 10　　// 會從右執行到左，10 == 10 true
console.log(a)　　　// 所以 a 印出 true</code></pre>
<p>差別在於 <code>===</code> 會判斷「型態」：</p>
<pre><code>console.log(0 == ’0’)  // true
console.log(0 === ’0’)  // false，因為數字和字串型態不同</code></pre>
<blockquote>
<p>永遠都用三個等號，如此最能夠避免型態不同而發生錯誤。</p>
</blockquote>
<hr>
<h2 id="陣列（Array）"><a href="#陣列（Array）" class="headerlink" title="陣列（Array）"></a>陣列（Array）</h2><blockquote>
<p>在寫程式時遇到重複的動作，一定有方法能夠優化。</p>
</blockquote>
<ul>
<li>通常用來存放性質相近的資料</li>
<li>想像成一個列表物件，裡面含有幾個數值</li>
</ul>
<pre><code>// 陣列基本操作

box[1, 2, 3]
// box 代表陣列名稱
// [] 內的值代表索引值（index），陣列中索引是從 0 開始

console.log(box.length)　　　　　　　　// 印出 3，代表陣列長度
console.log(box[1])　　　　　　　　// 索引為 1 時，印出 2</code></pre>
<pre><code>// 範例練習

var score = [20, 5, 100]
console.log(score, score.length)　　 　//　印出 [20, 5, 100] 3
console.log(score[score.length - 1])　//　印出 100，陣列長度減一代表最後一個數的索引
score.push(60)　　　　　　　　　　　　　//　在陣列最後新增一個數
score[score.length] = 80　　　　　　　//　在陣列最後新增一個數
console.log(score.length)　　　　　　//　印出 5</code></pre>
<h2 id="物件（Object）"><a href="#物件（Object）" class="headerlink" title="物件（Object）"></a>物件（Object）</h2><ul>
<li>物件是一批相關的數據或功能</li>
<li>通常包含幾個變數及函式，當它們包含在物件中時被稱做屬性（properties）或函式（methods）</li>
</ul>
<pre><code>// 試著建立一個物件

var heidi = &#123;
    name: &#39;heidi&#39;,
    scores: [20, 60, 100],
    address: &#39;Japan&#39;,
&#125;

console.log(heidi, typeof heidi) // 印出物件屬性、型別
console.log(heidi.address)　　　　// 用點（.）取出物件屬性

var key = &#39;name&#39;
console.log(heidi[key])　　　　　　// 這裡 heidi[key] 等於 heidi.name</code></pre>
<p><img src="https://i.imgur.com/XKReoRy.png"></p>
<hr>
<h3 id="從-Object-的等號真正的理解變數"><a href="#從-Object-的等號真正的理解變數" class="headerlink" title="從 Object 的等號真正的理解變數"></a>從 Object 的等號真正的理解變數</h3><p>由 <code>console.log(1 === 1)</code>，會回傳 true 這個例子，來判斷下列情形：</p>
<pre><code>console.log([] === [])
console.log([1] === [1])
console.log(&#123;&#125; === &#123;&#125;)
console.log(&#123;a: 1&#125; === &#123;a: 1&#125;)</code></pre>
<p>結果卻是：</p>
<p><img src="https://i.imgur.com/x9CYSuk.png"></p>
<p>變數是一個箱子，在放入數字的情況下：</p>
<pre><code>var a = 30
console.log(a === 30)    // 印出 true，兩者相等</code></pre>
<p>但如果在變數裡放入物件，結果卻會如下：</p>
<pre><code>var obj = &#123;
    a:1
&#125;
console.log(obj === &#123;a:1&#125;)    // 印出 false，兩者不相等</code></pre>
<p>可以想像成「記憶體位置」：儘管兩個箱子儲存的數值相同，但因記憶體位置不同，指向的元素不同，所以不會相等。</p>
<p><img src="https://i.imgur.com/ZAY1PrG.png"></p>
<p>如果換成下列情形：</p>
<pre><code>var obj = &#123;
    a:1
&#125;
var obj2 = obj
console.log(obj === obj2)        // 印出 true</code></pre>
<p>兩者理所當然會相等，但若將 <code>obj2.a = 2</code>：更改 obj2 物件中 a 的值，會連 obj 的值也一起更動：</p>
<pre><code>var obj = &#123;
    a:1
&#125;
var obj2 = obj
obj2.a = 2
console.log(&#39;obj&#39;, obj2)         // obj &#123; a: 2 &#125;
console.log(&#39;obj2&#39;, obj2)        // obj2 &#123; a: 2 &#125;
console.log(obj === obj2)        // 印出 true，兩者相等</code></pre>
<p>會發現 obj 的值也一起被更改了。這是因為 obj 和 obj2 指向同一個記憶體位置，指向同一個物件。</p>
<p><img src="https://i.imgur.com/cgfJMmd.png"></p>
<p>但如果 <code>obj2 = &#123;b:1&#125;</code>：obj2 等於一個新的物件，會指向一個新的記憶體位置：</p>
<pre><code>var obj = &#123;
    a:1
&#125;
var obj2 = obj
obj2.a = 2
obj2 = &#123;b:1&#125;
console.log(&#39;obj&#39;, obj2)         // obj &#123; a: 2 &#125;
console.log(&#39;obj2&#39;, obj2)        // obj2 &#123; b: 1 &#125;
console.log(obj === obj2)        // 印出 false，兩者不相等</code></pre>
<p>這是因為「往裡面放東西」與「改放全新的東西」是兩件完全不同的事情。後者會指向一個新的記憶體，可參考下圖理解：</p>
<p><img src="https://i.imgur.com/JkzALWA.png"></p>
<hr>
<h2 id="判斷式"><a href="#判斷式" class="headerlink" title="判斷式"></a>判斷式</h2><p>判斷式在 JavaScript 中用來==控制流程==。當指定的條件成立時，就會執行後續的指令。判斷式的語法有兩種：<code>if...else</code> 和 <code>switch</code>。</p>
<h3 id="if-else-statement"><a href="#if-else-statement" class="headerlink" title="if-else statement"></a><code>if-else</code> statement</h3><ul>
<li>if 後面的小括號內：條件式，由比較運算子或邏輯運算子組成</li>
<li>當條件成立時：會執行 if 大括號內的程式碼：</li>
<li>當條件不成立，但也想執行特定動作：在 if 大括號外面使用 else</li>
</ul>
<pre><code>// 基本架構

if (條件)&#123;
  如果條件成立，執行 A;
&#125; else &#123;
  如果條件不成立，執行 B;
&#125;</code></pre>
<pre><code>// 練習：判斷是否為 5 的倍數

var number = 10
if (number % 5 === 0) &#123;
    console.log(&#39;是5的倍數&#39;)
&#125; else &#123;
    console.log(&#39;不是5的倍數&#39;)
&#125;
// 印出 是5的倍數</code></pre>
<h3 id="if-else-if-statement"><a href="#if-else-if-statement" class="headerlink" title="if-else if statement"></a>if-else if statement</h3><ul>
<li>當判斷情境更複雜時，搭配 <code>else if</code>，用來新增條件判斷</li>
<li><code>else if</code> 可以有很多個</li>
</ul>
<pre><code>// 基本架構

if (條件一) &#123;
  如果條件一成立，執行 A;
&#125; else if (條件二) &#123;
  如果條件一不成立；但條件二成立，執行 B;
&#125; else &#123;
  如果條件一跟二都不成立，執行 C;
&#125;</code></pre>
<pre><code>// 練習：判斷是否及格

var score = 70

if (score == 100) &#123;
    console.log(&#39;you are no1!&#39;)
&#125; else if (score &gt;= 60)&#123;
    console.log(&#39;pass&#39;)
&#125; else &#123;
    console.log(&#39;fail&#39;)
&#125;
// 印出 pass</code></pre>
<pre><code>var kg = 60
var m = 1.6
var BMI = kg / (m**2)　　　// 指數

console.log(&#39;BMI:&#39;, BMI.toFixed(2))
// 印出 BMI: 23.44，函數 toFixed() 可取到小數點下的指定位數

if (BMI &lt; 18.5) &#123;
    console.log(&#39;體重過輕&#39;)
&#125; else if (BMI &lt; 24) &#123;
    console.log(&#39;正常範圍&#39;)
&#125; else if (BMI &lt; 27) &#123;
    console.log(&#39;過重&#39;)
&#125; else if (BMI &lt; 30) &#123;
    console.log(&#39;輕度肥胖&#39;)
&#125; else if (BMI &lt; 35) &#123;
    console.log(&#39;中度肥胖&#39;)
&#125; else &#123;
    console.log(&#39;重度肥胖&#39;)   
&#125;</code></pre>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h3><ul>
<li>通常用於「有很多條件」要判斷的情況，適合用來處理只有「整數」或「字元」類型的資料</li>
<li>switch-case 判斷式沒有辦法處理「數值範圍」的問題</li>
<li>每個 <code>case 條件:</code> 後方都會加上 <code>break</code>：用途是停止執行後面的程式碼，否則 <code>switch</code> 會從匹配的 <code>case</code> 標籤開始執行到尾端</li>
</ul>
<pre><code class="javascript=">// 基本架構

switch(參數)&#123;
case 條件一:　　　　　　　　// 如果 n===條件一 就從這裡開始
  條件一成立時執行區塊一;
  break;            　    // 在這裡停止執行

case 條件二:
  條件二成立時執行區塊二;
  break;

default:　　　　　　　　　　// 如果都沒有找到相同值
  條件都不成立時執行區塊三;
  break;
&#125;</code></pre>
<h4 id="switch-case-vs-if-else"><a href="#switch-case-vs-if-else" class="headerlink" title="switch case vs if else"></a>switch case vs if else</h4><ul>
<li>效能差異：當比對的參數多時，switch 的可讀性和效能較佳</li>
<li>判別差異：switch 在判斷上採取嚴謹模式（同等性由 <code>===</code> 運算子判斷），亦即型別也要相同</li>
</ul>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRyZWFkMDEuY29tL2NvbnRlbnQvMTU0OTYwMjE5OC5odG1s">switch…case 和 if…else效率比較和優化<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIxMTU2MQ==">JavaScript 基礎知識-switch &amp; if else 的判別差異<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<h3 id="三元運算子（ternary）"><a href="#三元運算子（ternary）" class="headerlink" title="三元運算子（ternary）"></a>三元運算子（ternary）</h3><ul>
<li>也可稱作 Conditional Expression（條件表達式）</li>
<li>其實就是 if-else 的簡單寫法，適合巢狀結構（建議最多一層）</li>
</ul>
<pre><code>// 語法：

condition ? A : B　　　　// 條件 ? 符合條件結果 : 不符合條件結果

// 範例：

console.log(10 &gt; 5 ? &#39;bigger&#39; : &#39;smaller&#39;)　　// 印出 bigger</code></pre>
<p>以判斷是否及格為例：</p>
<pre><code>// if-else 寫法：

var score = 60
var message = &#39;&#39;

if (score &gt;= 60) &#123;
    message = &#39;pass&#39;
&#125; else &#123;
    message = &#39;fail&#39;
&#125;

// 三元運算子寫法：

var score = 60
var message = score &gt;= 60 ? &#39;pass&#39; : &#39;fail&#39;
// 兩種寫法均回傳 pass</code></pre>
<h2 id="迴圈（loop）"><a href="#迴圈（loop）" class="headerlink" title="迴圈（loop）"></a>迴圈（loop）</h2><ul>
<li>迴圈是程式流程控制的一環，用來重複執行相似的工作</li>
<li>必須設定==終止條件==，否則執行時將進入無窮迴圈（可按 <code>Ctrl+C</code> 跳出）</li>
</ul>
<h3 id="do…while-迴圈"><a href="#do…while-迴圈" class="headerlink" title="do…while 迴圈"></a>do…while 迴圈</h3><ul>
<li>先執行後才判斷條件，代表迴圈主體至少會被執行一次</li>
</ul>
<pre><code>// 語法：

do &#123;
  statement　　　　　　　// 先執行一次
&#125; while (condition)　　// 若符合條件，會再進行下一次迴圈

// 範例：

var i = 1

do &#123;
    console.log(i)       // 印出 1 到 100 
    i++
&#125; while (i&lt;=100)         // 直到 i = 101 時跳出迴圈

console.log(&#39;i=&#39;, i)     // 印出 i = 101</code></pre>
<h3 id="while-迴圈"><a href="#while-迴圈" class="headerlink" title="while 迴圈"></a>while 迴圈</h3><ul>
<li>其實就是 do…while 迴圈的變形版本。差別在於 do…while 會至少被執行一次，才進行條件判斷</li>
<li>由於迴圈主體需至少執行一次的情況並不常見，通常還是會使用 while 迴圈</li>
</ul>
<pre><code>// 語法：

while (condition) &#123;
    statement
&#125;

// 將上方 do…while 範例改寫，會得到相同輸出結果：

var i = 1

while (i &lt;= 100) &#123;　　　// 直到 i = 101 時跳出迴圈
    console.log(i)　　　// 印出 1 到 100
    i++
&#125;

console.log(&#39;i=&#39;, i)　// 印出 i = 101</code></pre>
<h3 id="for-迴圈"><a href="#for-迴圈" class="headerlink" title="for 迴圈"></a>for 迴圈</h3><ul>
<li>類似 while 迴圈，但 for 迴圈通常用於「已知重複次數」的情況，也就是設定初始值和終止條件</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cud2liaWJpLmNvbS9pbmZvLnBocD90aWQ9MTgy">for 迴圈基本架構<i class="fa fa-external-link-alt"></i></span>，需要三個運算式作為參數：initialize（初始值）、condition（條件判斷）、increment（遞增迴圈變數）</li>
<li>三個運算式可省略任何一個，但中間的兩個分號必須存在。例如：<code>for (;;)</code> 會是無窮迴圈</li>
</ul>
<pre><code>// 語法：

for (初始值; 終止條件; 遞增迴圈變數)&#123;
    要執行的程式碼
&#125;

// 也就是：

for ( 變數 = 初始值 ; 變數 &lt; 限制值 ; 變數 + 步進值 ) &#123;
　要執行的程式碼
&#125;</code></pre>
<pre><code>// 範例：

for (var i = 1; i&lt;=100; i++) &#123;
    console.log(i)
&#125;
// 印出 1 到 100</code></pre>
<pre><code>// 可和 while 迴圈進行對照：

var i = 1　　　　　　// 初始值
while(i &lt;= 100) &#123;　　 // 終止條件
    console.log(i)
    i++            // i 每一圈要做的事情
&#125;
// 同樣印出 1 到 100</code></pre>
<h3 id="break-與-continue"><a href="#break-與-continue" class="headerlink" title="break 與 continue"></a>break 與 continue</h3><ul>
<li>用來改變迴圈的執行流程</li>
<li>只能用在迴圈或 switch 述句中</li>
</ul>
<h4 id="break（中斷）：中斷整個迴圈語句，也就是「跳出」迴圈區塊"><a href="#break（中斷）：中斷整個迴圈語句，也就是「跳出」迴圈區塊" class="headerlink" title="break（中斷）：中斷整個迴圈語句，也就是「跳出」迴圈區塊"></a><code>break</code>（中斷）：中斷整個迴圈語句，也就是「跳出」迴圈區塊</h4><pre><code>// 範例：

var i = 1

do &#123;
    console.log(i)　　　 // 印出 1 到 6
    if (i === 6) &#123;
        break　　　　  　// 當 i 等於 6 時跳出迴圈
    &#125;
    i++
&#125; while (i &lt;= 10)

console.log(&#39;i=&#39;, i)　　// 印出 i = 6</code></pre>
<p>執行結果如下圖：</p>
<p><img src="https://i.imgur.com/V9mi4KK.png" alt="break"></p>
<h4 id="continue（繼續）：繼續下一次迴圈語句，會忽略在-continue-之後的語句，直接跳到下一次的迴圈開頭"><a href="#continue（繼續）：繼續下一次迴圈語句，會忽略在-continue-之後的語句，直接跳到下一次的迴圈開頭" class="headerlink" title="continue（繼續）：繼續下一次迴圈語句，會忽略在 continue 之後的語句，直接跳到下一次的迴圈開頭"></a><code>continue</code>（繼續）：繼續下一次迴圈語句，會忽略在 continue 之後的語句，直接跳到下一次的迴圈開頭</h4><pre><code>// 範例：

var i = 1

do &#123;
    console.log(i)　　　// 印出 1 到 10
    i++
// 當 i 為奇數時，直接跳到　while 檢查條件，進入下一個迴圈
    if (i % 2 === 1) &#123;　　　　
        continue
    &#125;
    console.log(&#39;i++&#39;, i)　　// 只會印出偶數的 i
&#125; while (i &lt;= 10)

console.log(&#39;i=&#39;, i)　　// 印出 i = 11</code></pre>
<p>執行結果如下圖：</p>
<p><img src="https://i.imgur.com/FoASLD1.png" alt="continue"></p>
<hr>
<h2 id="函式（Function）"><a href="#函式（Function）" class="headerlink" title="函式（Function）"></a>函式（Function）</h2><p>以前學的國中數學 <code>y = f(x)</code> 其實就是一種函式：</p>
<pre><code>y = f(x)
y：回傳值 / f(x)：函式 / x：參數</code></pre>
<pre><code>// 範例：

y = f(x) = 2x
f(1) = 2*1 = 2

// 也可以是多項參數：

y = f(a, b, c) = a+2b+3c
f(1, 1, 1) = 1+2+3 = 6
</code></pre>
<h3 id="最基本的函式結構"><a href="#最基本的函式結構" class="headerlink" title="最基本的函式結構"></a>最基本的函式結構</h3><p>在 JavaScript 的函式架構：</p>
<pre><code>function 函數名稱(參數) &#123;
   return 要回傳的內容
&#125;</code></pre>
<pre><code>// 範例：

function abc(a, b, c) &#123;
    return a + 2*b + 3*c
&#125;

console.log(abc(1, 1, 1))　　　　// 印出 6</code></pre>
<p>範例：在陣列產生 n 個元素的函式</p>
<pre><code>function generateArray(n)&#123;
    var result = [] 　　　　　　　　// 宣告一個變數為空陣列
    for(var i = 1; i&lt;=n; i++)&#123;
        result.push(i)　　　　　　// 把數字放進陣列
    &#125;
    return result         　　   // 記得回傳結果
&#125;

// generateArray(3) =&gt; [1, 2, 3]
// generateArray(10) =&gt; [1, 2, 3, ... , 10]

console.log(generateArray(0))　　// 印出 [] 空陣列
console.log(generateArray)
// 函式後面需加上括號才能呼叫，否則會印出 [Function: generateArray]</code></pre>
<p>也可以不寫 return，寫法如下：</p>
<pre><code>function log(n) &#123;
    for(var i = 1; i &lt;= n; i++) &#123;
    console.log(i)　　　　// 直接在函式裡面印出結果
    &#125;
&#125;
log(10)　　　　　// 回傳 1 到 10</code></pre>
<p>範例：印出 1~100 的偶數</p>
<blockquote>
<p>小技巧：不知如何解題時，可先從寫下 Function 架構開始</p>
</blockquote>
<pre><code>// 先寫出函式架構：

function print1to100() &#123;

&#125;
print1to100()</code></pre>
<p>要產生 1~100 的數字，可能需要迴圈：</p>
<pre><code>function print1to100() &#123;
    for (var i=1; i&lt;=100; i++)
    logEven(i)  　　　　　　　　　　// log 偶數
&#125;</code></pre>
<p>需要再寫一個函式，來判斷 i 是否為偶數：</p>
<pre><code>function logEven(number) &#123;
    if (number%2 === 0)　　　　　// 若為偶數，就印出數字
    console.log(number)
&#125;
function print1to100() &#123;
    for (var i=1; i&lt;=100; i++)
    logEven(i)  　　　　　　　　　
&#125;

print1to100()　　　　　　　　　// 印出 1~100 的偶數</code></pre>
<h3 id="宣告函式的不同種方式"><a href="#宣告函式的不同種方式" class="headerlink" title="宣告函式的不同種方式"></a>宣告函式的不同種方式</h3><ul>
<li>在語法上大致分為 4 種方式，可參考這篇介紹：<span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIwNzc0MA==">函數定義 (Function Definition) 的 100 種寫法<i class="fa fa-external-link-alt"></i></span></li>
<li>其中最常使用的為宣告式，以及匿名表達式。</li>
</ul>
<h4 id="第一種：宣告式（Function-Declarations）"><a href="#第一種：宣告式（Function-Declarations）" class="headerlink" title="第一種：宣告式（Function Declarations）"></a>第一種：宣告式（Function Declarations）</h4><ul>
<li>是最常見的標準寫法。</li>
<li>使用 <code>function</code> 關鍵字作函數的宣告和定義。</li>
</ul>
<pre><code>function hello() &#123;
   console.log(&#39;hello&#39;)
&#125;

hello()　　　　　// 執行函式，回傳 hello</code></pre>
<h4 id="第二種：匿名函數（anonymous-function），或稱匿名表達式"><a href="#第二種：匿名函數（anonymous-function），或稱匿名表達式" class="headerlink" title="第二種：匿名函數（anonymous function），或稱匿名表達式"></a>第二種：匿名函數（anonymous function），或稱匿名表達式</h4><ul>
<li>前面提到函式也是一種資料型態。因此可先宣告一個變數，再定義一個函數內容放到該變數裡。</li>
<li>此方式定義的函數，實際上是匿名函數，只是將函數存在某個變數裡。</li>
</ul>
<pre><code>var hello = function (a, b) &#123;
    return a + b
&#125;

console.log(hello(3, 6))　　　　　// 印出 9</code></pre>
<h3 id="console-log-括號內可傳入函式"><a href="#console-log-括號內可傳入函式" class="headerlink" title="console.log() 括號內可傳入函式"></a>console.log() 括號內可傳入函式</h3><p>我們在先前的範例，console.log() 都只傳入數字、字串等，但其實也可傳入函式，如以下範例：</p>
<pre><code>function transform(arr, transformFunction) &#123; 
    var result = []
    for(var i=0; i&lt;arr.length; i++) &#123;
        result.push(transformFunction(arr[i]))
    &#125;
    return result
&#125;

function double(x) &#123;　　　　　　
    return x*2
&#125;

// transform([1, 2, 3], double) =&gt; [2, 4, 6]

console.log (
    transform([1, 2, 3] ,double)　　　
)
// 傳入 transform 函式，並且在 transform 函式中傳入 double 函式
// 印出 [2, 4, 6]</code></pre>
<p>上述範例中，在 transform 函式裡面，double 函式取代了參數 transformFunction，也就是執行 double 函式內部的運算。</p>
<p>也可直接把整組函式丟到 console.log() 括號內，就不需再額外命名。好處是可直接修改函式定義，如以下範例：</p>
<p><img src="https://i.imgur.com/IatovLR.png" alt="function 傳入 log"></p>
<hr>
<h3 id="引數（Argument）與參數（Parameter）"><a href="#引數（Argument）與參數（Parameter）" class="headerlink" title="引數（Argument）與參數（Parameter）"></a>引數（Argument）與參數（Parameter）</h3><p>參數：方法定義中的變數<br>引數：在呼叫方法時真正傳入的值</p>
<pre><code>// 範例：
function add(a, b) &#123;        // 參數就是 a 和 b
    console.log(arguments)    // 可印出引數
    return a+b
&#125;

add(2, 5)                   // 引數是 2 和　5</code></pre>
<p>結果如下圖，印出 <code>&#123; &#39;0&#39;: 2, &#39;1&#39;: 5 &#125;</code>。</p>
<p><img src="https://i.imgur.com/9BaESkL.png"></p>
<h4 id="Argument-物件"><a href="#Argument-物件" class="headerlink" title="Argument 物件"></a>Argument 物件</h4><p>由上述範例可知，<code>arguments</code> 物件其實是種「類陣列物件」。</p>
<ul>
<li>arguments[0]：代表第一個引數</li>
<li>arguments[1]：代表第二個引數</li>
</ul>
<p>並且具有 length 屬性。</p>
<pre><code>function add(a, b) &#123;
 console.log(arguments.length)    // 印出 2
 return a+b
&#125;
add(2, 5)
// 一共傳了兩個引數</code></pre>
<blockquote>
<p>參考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL2FyZ3VtZW50cw==">MDN - Arguments 物件<i class="fa fa-external-link-alt"></i></span>，由於 arguments 帶其他屬性，可能因此需要用物件的方式來儲存資訊。</p>
</blockquote>
<h3 id="function-傳參數的運作機制（待補）"><a href="#function-傳參數的運作機制（待補）" class="headerlink" title="function 傳參數的運作機制（待補）"></a>function 傳參數的運作機制（待補）</h3><pre><code>function swap(a, b) &#123;
在函式當傳入值時就會這樣跑
  var a = number1
  var b = number2
  所以只是把 number1 跟 number2 給複製了一份
  number1 number2 a b 是各自獨立的變數

 var temp = a
 a = b
 b = temp
 console.log(&quot;a: b:&quot;, a, b)
&#125;
var number1 = 10
var number2 = 20
console.log(number1, number2)
swap(number1, number2)
console.log(number1, number2)
number1 . number2 . a . b 是各自獨立的變數</code></pre>
<pre><code>function addValue(obj) &#123;
這裡的操作如下：
  var obj = a &#123;&#125;
  這是 Obj 的特性，如同前篇介紹的，物件是存取記憶體位置
  在這邊的操作等於是命名另外一個物件 obj = a，
  所以現在有 obj 跟 a 都指向同個記憶體位置

  obj.number++ // 在這邊等於把該記憶體位置儲存的內容+1 
 return 1
&#125;
var a = &#123;
 number: 10
&#125;
addValue(a)
console.log(a)
//&#123; number: 11 &#125;</code></pre>
<p>例外情況是數字.字串.布林，這三者較簡單，所以在操作的時候會變成直接複製。而較複雜的部份因為使用指向的方式，所以只要有一個地方修改，就等修改其他指向該記憶體位置的操作。</p>
<pre><code>function addValue(obj) &#123;
 obj = &#123;
 number: 100
 &#125;
 return 1
&#125;
var a = &#123;
 number: 10
&#125;
addValue(a)
console.log(a)
//&#123; number: 10 &#125; </code></pre>
<p>在這邊的操作是把 obj 指向了另外一個新的記憶體，等於 obj 指向了另外一個記憶體位置</p>
<p>這種情況以專有名詞稱作：</p>
<p>pass by value<br>pass by reference. （JavaScript 中沒有）<br>pass by sharing</p>
<blockquote>
<p>可以參考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRlY2hicmlkZ2UuY2MvMjAxOC8wNi8yMy9qYXZhc2NyaXB0LWNhbGwtYnktdmFsdWUtb3ItcmVmZXJlbmNlLw==">深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<hr>
<h2 id="return-的作用與使用時機"><a href="#return-的作用與使用時機" class="headerlink" title="return 的作用與使用時機"></a>return 的作用與使用時機</h2><p>首先可以把 function 分成兩類：</p>
<h3 id="第一種：不需要知道結果"><a href="#第一種：不需要知道結果" class="headerlink" title="第一種：不需要知道結果"></a>第一種：不需要知道結果</h3><p>也就是只需要呼叫 function，但不需知道執行結果的情況。</p>
<pre><code>// 範例：
function sayhello() &#123;
    console.log(&#39;hello&#39;)
    // 若沒有回傳，會預設 return undefined
&#125;

sayhello()
// 印出 hello</code></pre>
<pre><code>// 也可以傳參數進去：
function sayhello(name) &#123;
    console.log(&#39;hello&#39;, name)
&#125;

sayhello(&#39;nick&#39;)
// 印出 hello nick</code></pre>
<p>也可以回傳些什麼，如以下範例，但 return 並不會影響結果。</p>
<pre><code>function sayhello(name) &#123;
    console.log(&#39;hello&#39;, name)
    return “i am a”         // return 的值會是 a
&#125;

var a = sayhello(‘nick’)    // 印出 hello nick
console.log(a)              // 印出 i am a</code></pre>
<h3 id="第二種：需要回傳值"><a href="#第二種：需要回傳值" class="headerlink" title="第二種：需要回傳值"></a>第二種：需要回傳值</h3><p>例如需要函式進行運算，然後回傳結果。</p>
<pre><code>function double(x) &#123;
    return x * 2
&#125;

var result = double(3)
console.log(result)
// 印出 6</code></pre>
<blockquote>
<p>注意：在 function 一旦執行 return 就會跳出，return 以下的任何程式碼都不會再執行。</p>
</blockquote>
<pre><code>舉例
function double(x) &#123;
    return 123            // 執行 return 就會跳出
    console.log(abc)
    return x * 2
&#125;

var result = double(3)
console.log(result)　　　　// 只會印出回傳值 123</code></pre>
<h2 id="常用內建函式"><a href="#常用內建函式" class="headerlink" title="常用內建函式"></a>常用內建函式</h2><h3 id="Number-類型的內建函式"><a href="#Number-類型的內建函式" class="headerlink" title="Number 類型的內建函式"></a>Number 類型的內建函式</h3><blockquote>
<p>可參考：<br><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVy">Number - JavaScript - MDN - Mozilla<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aA==">Math - JavaScript - MDN - Mozilla<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li><code>Number()</code>：將字串轉數字</li>
</ul>
<pre><code>var a = 10
var b = &#39;20&#39;

console.log(a + Number(b))    // 印出 30</code></pre>
<ul>
<li><code>parseInt()</code>：將字串轉整數。預設為十進位，例如：<code>parseInt(a, 10)</code></li>
</ul>
<pre><code>var a = 10
var b = &#39;20.35&#39;

console.log(parseInt(b))    // 印出 20</code></pre>
<ul>
<li><code>parseFloat()</code>：將字串轉浮點數。也就是有小數點</li>
</ul>
<pre><code>var a = 10
var b = &#39;20.35&#39;

console.log(parseFloat(b))    // 印出 20.35</code></pre>
<ul>
<li><code>toFixed()</code>：取到小數點後第幾位。括號內不輸入就會取整數。可與 <code>parseFloat()</code> 搭配使用</li>
</ul>
<pre><code>var a = 10
var b = &#39;20.357&#39;

console.log(parseFloat(b).toFixed(2))    // 印出 20.36，前一位會四捨五入</code></pre>
<ul>
<li><code>.toString()</code>：數字轉字串</li>
</ul>
<p>或是將數字加空字串（<code>&#39;&#39;</code>），因為「<code>數字 + 字串 = 字串</code>」。</p>
<pre><code>var a = 2

// 第一種方法
a.toString() 

// 第二種方法：數字 + 空字串 = 字串
(a+&#39;&#39;)</code></pre>
<ul>
<li><code>Number.MAX_VALUE</code>, <code>Number.MIN_VALUE</code>：得知在 JavaScript 可儲存的最大、最小值，若超出這個值，計算就會不精準</li>
</ul>
<pre><code>console.log(Number.MAX_VALUE)
// 印出 1.7976931348623157e+308
console.log(Number.MIN_VALUE)
// 印出 5e-324</code></pre>
<ul>
<li><code>Math.PI</code>：圓周率。常數通常用大寫表示</li>
<li><code>Math.ceil()</code>：無條件進位，取大於這個數的最小整數</li>
</ul>
<pre><code>console.log(Math.ceil(3.14))
// 印出 4</code></pre>
<ul>
<li><code>Math.floor()</code>：無條件捨去，取小於這個數的最大整數</li>
</ul>
<pre><code>console.log(Math.floor(10.9))
// 印出 10</code></pre>
<ul>
<li><code>Math.round()</code>：四捨五入</li>
</ul>
<pre><code>console.log(Math.round(10.5))
// 印出 11</code></pre>
<ul>
<li><code>Math.sqrt()</code>：開根號</li>
</ul>
<pre><code>console.log(Math.sqrt(9))
// 印出 3</code></pre>
<ul>
<li><code>Math.pow()</code>：次方</li>
</ul>
<pre><code>console.log(Math.pow(2, 10))
// 印出 1024，也就是 2 的十次方</code></pre>
<ul>
<li><code>Math.random()</code>：產生從 0~1 隨機數（不包含 1）</li>
</ul>
<pre><code>console.log(Math.random())
// 產生 0~1 隨機數
console.log(Math.floor(Math.random()*10 + 1))
// 乘以十可產生 0~10 的隨機數（不包含 10）
// 無條件捨去，可產生 1~10 的整數</code></pre>
<h3 id="String-類型的內建函式"><a href="#String-類型的內建函式" class="headerlink" title="String 類型的內建函式"></a>String 類型的內建函式</h3><blockquote>
<p>可參考：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5n">String - JavaScript - MDN - Mozilla<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li><code>toUpperCase</code>, <code>toLowerCase()</code>：將字串轉換大、小寫</li>
</ul>
<pre><code>var a = &#39;abc&#39;.toUpperCase()
console.log(a)　　　　　　　　　// 印出 ABC

var B = &#39;ABC!!!&#39;.toLowerCase()
console.log(B)　　　　　　　　　// 印出 abc!!!</code></pre>
<p>或是參考 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQVNDSUk=">ASCII code<i class="fa fa-external-link-alt"></i></span> 進行轉換：</p>
<ul>
<li><code>.charCodeAt()</code>：取得字串特定位置的字元 ASCII 編碼</li>
</ul>
<pre><code>console.log(&quot;ABC&quot;.charCodeAt(0))
// 印出 65（A 的編碼）
console.log(&quot;cba&quot;.charCodeAt(3))
// 印出 97（a 的編碼）

// 由此可知大、小寫字母的索引相差 32</code></pre>
<ul>
<li><code>String.fromCharCode()</code>：將 ASCII 編碼的數字轉換成字元</li>
</ul>
<pre><code>var str = String.fromCharCode(65)
console.log(str)
// 印出 A

// 將上述兩種函式組合應用：

var str = String.fromCharCode(&quot;Abc&quot;.charCodeAt(0) + 32)
console.log(str)
// 印出 a</code></pre>
<p>利用 ASCII code 進行字串比大小，可判斷該字元為大小寫、是否在條件範圍內：</p>
<pre><code>var char =&#39;J&#39;
console.log(char &gt;= &#39;A&#39; &amp;&amp; char &lt;= &#39;Z&#39;)
// 印出 true，判斷為大寫

var char =&#39;g&#39;
console.log(char &gt;= &#39;A&#39; &amp;&amp; char &lt;= &#39;Z&#39;)
// 印出 false，判斷為小寫
</code></pre>
<ul>
<li><code>indexOf()</code>：可回傳「指定字串」在字串中第一次出現的位置。若找不到則回傳 -1</li>
</ul>
<pre><code>var str = &#39;hey hello world&#39;
var index = str.indexOf(&#39;hello&#39;)
console.log(index)                        // 印出 4，hello 第一次出現在 index = 4

var index = str.indexOf(&#39;hello!!&#39;)
console.log(index)                        // 印出 -1，代表字串不存在</code></pre>
<ul>
<li><code>replace()</code>：取代字串。只能換第一個指定字串。要全換的話可使用<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25z">正規表達式<i class="fa fa-external-link-alt"></i></span>來達成</li>
</ul>
<pre><code>// replace()換第一個：
var str = &#39;hey hey hello world&#39;.replace(&#39;hey&#39;, &#39;!!!&#39;)
console.log(str)          
// 印出 !!! hey hello world

// 正規表達式可全換：
var str = &#39;hey hey hello world&#39;.replace(/hey/g, &#39;!!!&#39;)
console.log(str)  
// 印出 !!! !!! hello world，/hey/g 的 g 代表 global</code></pre>
<ul>
<li><code>split()</code>：透過「指定分隔符」來分開字串，回傳值為陣列</li>
</ul>
<pre><code>var str = &#39;data1,data2,data3&#39;
var arr = str.split(&#39;,&#39;)                // 取出分號
console.log(arr)
// 印出 [&#39;data1&#39;, &#39;data2&#39;, &#39;data3&#39;]

let input = [&#39;1 * 3&#39;]
let temp = input[0].split(&#39; &#39;)          // 取出空格
console.log(temp)
// 印出 [1, *, 3]</code></pre>
<ul>
<li><code>trim()</code>：移除目前字串開頭和結尾的所有空格</li>
</ul>
<pre><code>var str = &#39;   data1,data2,data3   &#39;
console.log(str.trim())
// 印出 data1,data2,data3</code></pre>
<ul>
<li><code>string.length</code>：可回傳字串長度。此指令不是函式</li>
</ul>
<pre><code>var str = &#39;hello world&#39;
console.log(str.length)
// 印出 11</code></pre>
<p>可應用在迴圈：</p>
<pre><code>var str = &#39;hello!&#39;

for (var i=0; i&lt;str.length; i++)&#123;
  console.log(str[i])            // 可在每行印出第 i 個字元
&#125;</code></pre>
<p><img src="https://i.imgur.com/16SoONi.png"></p>
<h3 id="Array-類型的內建函式"><a href="#Array-類型的內建函式" class="headerlink" title="Array 類型的內建函式"></a>Array 類型的內建函式</h3><blockquote>
<p>可參考：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXk=">Array - JavaScript - MDN - Mozilla<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ul>
<li><code>join.()</code>：將陣列中所有元素連接成一個字串，預設分隔符是逗號（在 Windows 系統）</li>
</ul>
<pre><code>var arr = [1, 2, 3]
console.log(arr.join())        // 印出 1,2,3
console.log(arr.join(&#39;!&#39;))       // 印出 1!2!3
console.log(arr.join(&#39;&#39;))       // 印出 123</code></pre>
<ul>
<li><code>map()</code>：把陣列中的每個元素帶入指定函式，然後建立一個新的陣列</li>
</ul>
<pre><code>var arr = [1, 2, 3]

function negtive(x) &#123;
  return x*-1
&#125;

console.log(arr.map(negtive))    // 印出 [-1, -2 ,-3]

// 或是用匿名函式的寫法，直接放入函式定義：
var arr = [1, 2, 3]

console.log(
  arr
  .map(function (x) &#123;
     return x * 2
  &#125;)
)                                // 印出 [2, 4, 6]</code></pre>
<ul>
<li><code>filter()</code>：概念和 <code>map()</code> 類似，是根據指定的測試函數，從一個陣列中過濾出符合條件的元素，並建立新的陣列</li>
</ul>
<pre><code>var arr = [1, 2, -3, 5, -7]

console.log(
  arr
  .filter(function (x) &#123;
    return x &gt; 0              // 只留下 x 大於 0
  &#125;)
)
// 印出 [1, 2, 5]

var arr = [1, 3, 5, 7]
arr.filter(x =&gt; x &gt; 4)        // 只留下 x 大於 4 
// 印出 [5, 7]
</code></pre>
<ul>
<li><code>slice()</code>：可截取出陣列某部份元素，會建立一個新的陣列</li>
</ul>
<pre><code>var arr = [0, 1, 2, 3, 4, 5]
console.log(arr.slice(2, 4))        // 印出 [2, 3]，不包含結尾元素</code></pre>
<ul>
<li><code>splice()</code>：可用來刪除與新增元素，會改變原本的陣列</li>
</ul>
<pre><code>var months = [&#39;Jan&#39;, &#39;March&#39;, &#39;April&#39;, &#39;June&#39;]
months.splice(1, 0, &#39;Feb&#39;)
// 在 index 1 新增 &#39;Feb&#39;
console.log(months)
// 印出 [&#39;Jan&#39;, &#39;Feb&#39;, &#39;March&#39;, &#39;April&#39;, &#39;June&#39;]

months.splice(4, 1, &#39;May&#39;)
// 把 index 4 的 &#39;June&#39; 換成 &#39;May&#39;
console.log(months)
// 印出 [&#39;Jan&#39;, &#39;Feb&#39;, &#39;March&#39;, &#39;April&#39;]</code></pre>
<ul>
<li><code>sort()</code>：依照字母順序排列陣列中的所有元素，會改變原本的陣列</li>
</ul>
<pre><code>var arr = [1 ,30 ,4 ,21]

// 要由小排到大
arr.sort(function(a,b) &#123;        // 想像順序是 a b
  if (a===b) return 0
  if (b&gt;a) return -1            // 回傳 -1，代表不互換
  return 1                      // 回傳 1（任何正數），代表 a b 互換位置
&#125;)

console.log(arr)                // 印出 [1, 4, 21, 30]

// 可用三元運算子簡化：
arr.sort(function(a, b) &#123;  
    if (a===b) return 0  
    return a &gt; b ? 1:-1
&#125;)

// 也可再簡化：
arr.sort(function(a, b) &#123;  
    return a - b                 
&#125;)</code></pre>
<hr>
<h2 id="Immutable（不可變）"><a href="#Immutable（不可變）" class="headerlink" title="Immutable（不可變）"></a>Immutable（不可變）</h2><p>除了物件以外，其他基本型別（primitive types）具有不可變的特性。</p>
<pre><code>var a = &quot;hello&quot;
a = &quot;yo&quot;

a: &quot;hello&quot; 0x01    // 不會改變原本 hello 的值
a: &quot;yo&quot; 0x02       // 而是建立新的記憶體空間儲存 yo</code></pre>
<p>以內建函式 <code>toUpperCase()</code> 為例，如以下寫法：</p>
<pre><code>var a = &#39;hello&#39;
a = a.toUpperCase()        // a 指向了新的記憶體位置
console.log(a)
// 印出 HELLO</code></pre>
<p>由於字串具有不可變的特性，不論呼叫什麼函式均無法改變 a 的值，如以下範例：</p>
<pre><code>var a = &#39;hello&#39;
a.toUpperCase()            // 若直接對 a 字串呼叫函式，不會有任何改變
console.log(a)
// 仍印出 hello，只能如上個範例，回傳一個新的值改變字串</code></pre>
<p>而物件型別，例如 Array，呼叫某些函式的時候，有可能會更動到原本記憶體位置儲存的東西：</p>
<pre><code>var arr = [2, 4, 6]
arr.push(8)                 // 更動到原本的陣列
console.log(arr)
// 印出 [2, 4, 6, 8]

// 若改成下列錯誤寫法：
var arr = [2, 4, 6]
arr = arr.push(8)        
// 會做兩件事情：新增元素到陣列、回傳陣列長度（arr.length）
console.log(arr)
// 印出 4，也就是新的陣列長度</code></pre>
<hr>
<p>參考資料：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDIxNTMwMQ==">JavaScript 初心者筆記: 判斷式 - if…else / switch 篇<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlcnR3LmNvbS8lRTclQTglOEIlRTUlQkMlOEYlRTglQUElOUUlRTglQTglODAvMzE2Mzg1Lw==">Java中for、while、do while三種迴圈語句的區別介紹<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9leWVzb2ZraWRzLmdpdGJvb2tzLmlvL2phdmFzY3JpcHQtc3RhcnQtZnJvbS1lczYvY29udGVudC9wYXJ0My9sb29wLmh0bWw=">迴圈· 從ES6開始的JavaScript學習生活<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BodWdoX1Byb2dyYW1fbGVhcm5pbmdfZGlhcnlfSnMvamF2YXNjcmlwdC0lRTUlOUYlQkElRTclQTQlOEUtJUU1JTg3JUJEJUU1JUJDJThGJUU3JTlBJTg0JUU1JTlGJUJBJUU2JTlDJUFDJUU0JUJCJThCJUU3JUI0JUI5LWU2NDdiNGU0NWFmMQ==">JavaScript 基礎：函式的基本介紹- Hugh’s Program learning<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
